-- This script was automatically @generated by Maui, it is not intended for manual editing.
local ModuleRoot={{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.include.RuntimeLib)
local Make = TS.import(script, TS.getModule(script, "@rbxts", "make"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Provider = TS.import(script, TS.getModule(script, "@rbxts", "roact-rodux-hooked").out).Provider
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local IS_DEV = TS.import(script, script.Parent, "constants").IS_DEV
local setStore = TS.import(script, script.Parent, "jobs").setStore
local toggleDashboard = TS.import(script, script.Parent, "store", "actions", "dashboard.action").toggleDashboard
local configureStore = TS.import(script, script.Parent, "store", "store").configureStore
local App = TS.import(script, script.Parent, "App").default
local store = configureStore()
setStore(store)
local mount = TS.async(function()
	local container = Make("Folder", {})
	Roact.mount(Roact.createElement(Provider, {
		store = store,
	}, {
		Roact.createElement(App),
	}), container)
	return container:WaitForChild(1)
end)
local function render(app)
	local protect = syn and syn.protect_gui or protect_gui
	if protect then
		protect(app)
	end
	if IS_DEV then
		app.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
	elseif gethui then
		app.Parent = gethui()
	else
		app.Parent = game:GetService("CoreGui")
	end
end
local main = TS.async(function()
	if getgenv and getgenv()._ORCA_IS_LOADED ~= nil then
		error("Orca is already loaded!")
	end
	local app = TS.await(mount())
	render(app)
	if time() > 3 then
		task.defer(function()
			return store:dispatch(toggleDashboard())
		end)
	end
	if getgenv then
		getgenv()._ORCA_IS_LOADED = true
	end
end)
main():catch(function(err)
	warn("Orca failed to load: " .. tostring(err))
end)
 end,Properties={Name="main"},Reference=63,ClassName="LocalScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local IS_DEV = getgenv == nil
local _condition = VERSION
if _condition == nil then
	_condition = "studio"
end
local VERSION_TAG = _condition
return {
	IS_DEV = IS_DEV,
	VERSION_TAG = VERSION_TAG,
}
 end,Properties={Name="constants"},Reference=17,ClassName="ModuleScript"},{Children={{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Clock").default
return exports
 end,Properties={Name="Clock"},Reference=97,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useEffect = _roact_hooked.useEffect
local useMemo = _roact_hooked.useMemo
local useState = _roact_hooked.useState
local TextService = TS.import(script, TS.getModule(script, "@rbxts", "services")).TextService
local Acrylic = TS.import(script, script.Parent.Parent.Parent, "components", "Acrylic").default
local Border = TS.import(script, script.Parent.Parent.Parent, "components", "Border").default
local Fill = TS.import(script, script.Parent.Parent.Parent, "components", "Fill").default
local _Glow = TS.import(script, script.Parent.Parent.Parent, "components", "Glow")
local Glow = _Glow.default
local GlowRadius = _Glow.GlowRadius
local useAppSelector = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "rodux-hooks").useAppSelector
local useSpring = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useTheme = TS.import(script, script.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local setInterval = TS.import(script, script.Parent.Parent.Parent, "utils", "timeout").setInterval
local px = TS.import(script, script.Parent.Parent.Parent, "utils", "udim2").px
local MIN_CLOCK_SIZE = px(56, 56)
local CLOCK_PADDING = 14
local function getTime()
	return (string.gsub(os.date("%I:%M %p"), "^0([0-9])", "%1"))
end
local function Clock()
	local isOpen = useAppSelector(function(state)
		return state.dashboard.isOpen
	end)
	local theme = useTheme("clock")
	local _binding = useState(getTime())
	local currentTime = _binding[1]
	local setTime = _binding[2]
	local textWidth = useMemo(function()
		return TextService:GetTextSize(currentTime, 20, "GothamBold", Vector2.new(200, 56))
	end, { currentTime })
	useEffect(function()
		local interval = setInterval(function()
			return setTime(getTime())
		end, 1000)
		return function()
			return interval:clear()
		end
	end, {})
	local _attributes = {}
	local _arg0 = px(textWidth.X + CLOCK_PADDING, 0)
	_attributes.Size = MIN_CLOCK_SIZE + _arg0
	_attributes.Position = useSpring(isOpen and UDim2.new(0, 0, 1, 0) or UDim2.new(0, 0, 1, 48 + 56 + 20), {})
	_attributes.AnchorPoint = Vector2.new(0, 1)
	_attributes.BackgroundTransparency = 1
	local _children = {
		Roact.createElement(Glow, {
			radius = GlowRadius.Size146,
			size = UDim2.new(1, 80, 0, 146),
			position = px(-40, -20),
			color = theme.dropshadow,
			gradient = theme.dropshadowGradient,
			transparency = theme.transparency,
		}),
		Roact.createElement(Fill, {
			color = theme.background,
			gradient = theme.backgroundGradient,
			transparency = theme.transparency,
			radius = 8,
		}),
	}
	local _length = #_children
	local _child = theme.outlined and Roact.createFragment({
		border = Roact.createElement(Border, {
			color = theme.foreground,
			radius = 8,
			transparency = 0.8,
		}),
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children[_length + 1] = Roact.createElement("ImageLabel", {
		Image = "rbxassetid://8992234911",
		ImageColor3 = theme.foreground,
		Size = px(36, 36),
		Position = px(10, 10),
		BackgroundTransparency = 1,
	})
	_children[_length + 2] = Roact.createElement("TextLabel", {
		Text = currentTime,
		Font = "GothamBold",
		TextColor3 = theme.foreground,
		TextSize = 20,
		TextXAlignment = "Left",
		TextYAlignment = "Center",
		Size = px(0, 0),
		Position = px(51, 27),
		BackgroundTransparency = 1,
	})
	local _child_1 = theme.acrylic and Roact.createElement(Acrylic)
	if _child_1 then
		if _child_1.elements ~= nil or _child_1.props ~= nil and _child_1.component ~= nil then
			_children[_length + 3] = _child_1
		else
			for _k, _v in ipairs(_child_1) do
				_children[_length + 2 + _k] = _v
			end
		end
	end
	return Roact.createElement("Frame", _attributes, _children)
end
local default = hooked(Clock)
return {
	default = default,
}
 end,Properties={Name="Clock"},Reference=98,ClassName="ModuleScript"}}},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Dashboard").default
return exports
 end,Properties={Name="Dashboard"},Reference=99,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Provider = TS.import(script, TS.getModule(script, "@rbxts", "roact-rodux-hooked").out).Provider
local DashboardPage = TS.import(script, script.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local configureStore = TS.import(script, script.Parent.Parent.Parent, "store", "store").configureStore
local Dashboard = TS.import(script, script.Parent, "Dashboard").default
return function(target)
	local handle = Roact.mount(Roact.createElement(Provider, {
		store = configureStore({
			dashboard = {
				isOpen = true,
				page = DashboardPage.Home,
				hint = nil,
				apps = {},
			},
		}),
	}, {
		Roact.createElement(Dashboard),
	}), target, "Dashboard")
	return function()
		return Roact.unmount(handle)
	end
end
 end,Properties={Name="Dashboard.story"},Reference=101,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useMemo = _roact_hooked.useMemo
local Canvas = TS.import(script, script.Parent.Parent.Parent, "components", "Canvas").default
local ScaleContext = TS.import(script, script.Parent.Parent.Parent, "context", "scale-context").ScaleContext
local useAppSelector = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "rodux-hooks").useAppSelector
local useSpring = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useViewportSize = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "use-viewport-size").useViewportSize
local hex = TS.import(script, script.Parent.Parent.Parent, "utils", "color3").hex
local map = TS.import(script, script.Parent.Parent.Parent, "utils", "number-util").map
local scale = TS.import(script, script.Parent.Parent.Parent, "utils", "udim2").scale
local Hint = TS.import(script, script.Parent.Parent, "Hint").default
local Clock = TS.import(script, script.Parent.Parent, "Clock").default
local Navbar = TS.import(script, script.Parent.Parent, "Navbar").default
local Pages = TS.import(script, script.Parent.Parent, "Pages").default
local PADDING_MIN_HEIGHT = 980
local PADDING_MAX_HEIGHT = 1080
local MIN_PADDING_Y = 14
local MAX_PADDING_Y = 48
local function getPaddingY(height)
	if height < PADDING_MAX_HEIGHT and height >= PADDING_MIN_HEIGHT then
		return map(height, PADDING_MIN_HEIGHT, PADDING_MAX_HEIGHT, MIN_PADDING_Y, MAX_PADDING_Y)
	elseif height < PADDING_MIN_HEIGHT then
		return MIN_PADDING_Y
	else
		return MAX_PADDING_Y
	end
end
local function getScale(height)
	if height < PADDING_MIN_HEIGHT then
		return map(height, PADDING_MIN_HEIGHT, 130, 1, 0)
	else
		return 1
	end
end
local function Dashboard()
	local viewportSize = useViewportSize()
	local isOpen = useAppSelector(function(state)
		return state.dashboard.isOpen
	end)
	local _binding = useMemo(function()
		return { viewportSize:map(function(s)
			return getScale(s.Y)
		end), viewportSize:map(function(s)
			return getPaddingY(s.Y)
		end) }
	end, { viewportSize })
	local scaleFactor = _binding[1]
	local padding = _binding[2]
	return Roact.createElement(ScaleContext.Provider, {
		value = scaleFactor,
	}, {
		Roact.createElement("Frame", {
			Size = scale(1, 1),
			BackgroundColor3 = hex("#000000"),
			BackgroundTransparency = useSpring(isOpen and 0 or 1, {}),
			BorderSizePixel = 0,
		}, {
			Roact.createElement("UIGradient", {
				Transparency = NumberSequence.new(1, 0.25),
				Rotation = 90,
			}),
		}),
		Roact.createElement(Canvas, {
			padding = {
				top = 48,
				bottom = padding,
				left = 48,
				right = 48,
			},
		}, {
			Roact.createElement(Canvas, {
				padding = {
					bottom = padding:map(function(p)
						return 56 + p
					end),
				},
			}, {
				Roact.createElement(Pages),
				Roact.createElement(Hint),
			}),
			Roact.createElement(Navbar),
			Roact.createElement(Clock),
		}),
	})
end
local default = hooked(Dashboard)
return {
	default = default,
}
 end,Properties={Name="Dashboard"},Reference=100,ClassName="ModuleScript"}}},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Hint").default
return exports
 end,Properties={Name="Hint"},Reference=102,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useEffect = _roact_hooked.useEffect
local useState = _roact_hooked.useState
local useAppSelector = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "rodux-hooks").useAppSelector
local useDelayedUpdate = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useSpring = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useScale = TS.import(script, script.Parent.Parent.Parent, "hooks", "use-scale").useScale
local hex = TS.import(script, script.Parent.Parent.Parent, "utils", "color3").hex
local scale = TS.import(script, script.Parent.Parent.Parent, "utils", "udim2").scale
local function Hint()
	local scaleFactor = useScale()
	local hint = useAppSelector(function(state)
		return state.dashboard.hint
	end)
	local isDashboardOpen = useAppSelector(function(state)
		return state.dashboard.isOpen
	end)
	local _condition = hint
	if _condition == nil then
		_condition = ""
	end
	local _binding = useState(_condition)
	local hintDisplay = _binding[1]
	local setHintDisplay = _binding[2]
	local isHintVisible = useDelayedUpdate(hint ~= nil and isDashboardOpen, 500, function(visible)
		return not visible
	end)
	useEffect(function()
		if isHintVisible and hint ~= nil then
			setHintDisplay(hint)
		end
	end, { hint, isHintVisible })
	return Roact.createElement("TextLabel", {
		RichText = true,
		Text = hintDisplay,
		TextXAlignment = "Right",
		TextYAlignment = "Bottom",
		TextColor3 = hex("#FFFFFF"),
		TextTransparency = useSpring(isHintVisible and 0.4 or 1, {}),
		Font = "GothamSemibold",
		TextSize = 18,
		BackgroundTransparency = 1,
		Position = useSpring(isHintVisible and scale(1, 1) or UDim2.new(1, 0, 1, 48), {}),
	}, {
		Roact.createElement("UIScale", {
			Scale = scaleFactor,
		}),
	})
end
local default = hooked(Hint)
return {
	default = default,
}
 end,Properties={Name="Hint"},Reference=103,ClassName="ModuleScript"}}},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Navbar").default
return exports
 end,Properties={Name="Navbar"},Reference=104,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useState = _roact_hooked.useState
local useAppDispatch = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "rodux-hooks").useAppDispatch
local useSpring = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useIsPageOpen = TS.import(script, script.Parent.Parent.Parent, "hooks", "use-current-page").useIsPageOpen
local useTheme = TS.import(script, script.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local setDashboardPage = TS.import(script, script.Parent.Parent.Parent, "store", "actions", "dashboard.action").setDashboardPage
local _dashboard_model = TS.import(script, script.Parent.Parent.Parent, "store", "models", "dashboard.model")
local PAGE_TO_ICON = _dashboard_model.PAGE_TO_ICON
local PAGE_TO_INDEX = _dashboard_model.PAGE_TO_INDEX
local _udim2 = TS.import(script, script.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local TAB_SIZE = px(100, 56)
local function NavbarTab(_param)
	local page = _param.page
	local theme = useTheme("navbar")
	local isActive = useIsPageOpen(page)
	local dispatch = useAppDispatch()
	local _binding = useState(false)
	local isHovered = _binding[1]
	local setHovered = _binding[2]
	return Roact.createElement("TextButton", {
		Text = "",
		AutoButtonColor = false,
		Active = not isActive,
		Size = TAB_SIZE,
		Position = scale(PAGE_TO_INDEX[page] / 4, 0),
		BackgroundTransparency = 1,
		[Roact.Event.Activated] = function()
			return dispatch(setDashboardPage(page))
		end,
		[Roact.Event.MouseEnter] = function()
			return setHovered(true)
		end,
		[Roact.Event.MouseLeave] = function()
			return setHovered(false)
		end,
	}, {
		Roact.createElement("ImageLabel", {
			Image = PAGE_TO_ICON[page],
			ImageColor3 = theme.foreground,
			ImageTransparency = useSpring(isActive and 0 or (isHovered and 0.5 or 0.75), {}),
			Size = px(36, 36),
			Position = scale(0.5, 0.5),
			AnchorPoint = Vector2.new(0.5, 0.5),
			BackgroundTransparency = 1,
		}),
	})
end
local default = hooked(NavbarTab)
return {
	default = default,
}
 end,Properties={Name="NavbarTab"},Reference=107,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Provider = TS.import(script, TS.getModule(script, "@rbxts", "roact-rodux-hooked").out).Provider
local DashboardPage = TS.import(script, script.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local configureStore = TS.import(script, script.Parent.Parent.Parent, "store", "store").configureStore
local Navbar = TS.import(script, script.Parent, "Navbar").default
return function(target)
	local handle = Roact.mount(Roact.createElement(Provider, {
		store = configureStore({
			dashboard = {
				isOpen = true,
				page = DashboardPage.Home,
				hint = nil,
				apps = {},
			},
		}),
	}, {
		Roact.createElement(Navbar),
	}), target, "Navbar")
	return function()
		return Roact.unmount(handle)
	end
end
 end,Properties={Name="Navbar.story"},Reference=106,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Acrylic = TS.import(script, script.Parent.Parent.Parent, "components", "Acrylic").default
local Border = TS.import(script, script.Parent.Parent.Parent, "components", "Border").default
local Canvas = TS.import(script, script.Parent.Parent.Parent, "components", "Canvas").default
local Fill = TS.import(script, script.Parent.Parent.Parent, "components", "Fill").default
local _Glow = TS.import(script, script.Parent.Parent.Parent, "components", "Glow")
local Glow = _Glow.default
local GlowRadius = _Glow.GlowRadius
local useAppSelector = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "rodux-hooks").useAppSelector
local useSpring = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useCurrentPage = TS.import(script, script.Parent.Parent.Parent, "hooks", "use-current-page").useCurrentPage
local useTheme = TS.import(script, script.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local _dashboard_model = TS.import(script, script.Parent.Parent.Parent, "store", "models", "dashboard.model")
local DashboardPage = _dashboard_model.DashboardPage
local PAGE_TO_INDEX = _dashboard_model.PAGE_TO_INDEX
local _color3 = TS.import(script, script.Parent.Parent.Parent, "utils", "color3")
local getColorInSequence = _color3.getColorInSequence
local hex = _color3.hex
local _udim2 = TS.import(script, script.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local NavbarTab = TS.import(script, script.Parent, "NavbarTab").default
local NAVBAR_SIZE = px(400, 56)
local Underglow
local function Navbar()
	local theme = useTheme("navbar")
	local page = useCurrentPage()
	local isOpen = useAppSelector(function(state)
		return state.dashboard.isOpen
	end)
	local alpha = useSpring(PAGE_TO_INDEX[page] / 4, {
		frequency = 3.9,
		dampingRatio = 0.76,
	})
	local _attributes = {
		Size = NAVBAR_SIZE,
		Position = useSpring(isOpen and UDim2.new(0.5, 0, 1, 0) or UDim2.new(0.5, 0, 1, 48 + 56 + 20), {}),
		AnchorPoint = Vector2.new(0.5, 1),
		BackgroundTransparency = 1,
	}
	local _children = {
		Roact.createElement(Glow, {
			radius = GlowRadius.Size146,
			size = UDim2.new(1, 80, 0, 146),
			position = px(-40, -20),
			color = theme.dropshadow,
			gradient = theme.dropshadowGradient,
			transparency = theme.transparency,
		}),
		Roact.createElement(Underglow, {
			transparency = theme.glowTransparency,
			position = alpha:map(function(a)
				return a + 0.125
			end),
			sequenceColor = alpha:map(function(a)
				return getColorInSequence(theme.accentGradient.color, a + 0.125)
			end),
		}),
		Roact.createElement(Fill, {
			color = theme.background,
			gradient = theme.backgroundGradient,
			radius = 8,
			transparency = theme.transparency,
		}),
		Roact.createElement(Canvas, {
			size = px(100, 56),
			position = alpha:map(function(a)
				return scale(math.round(a * 800) / 800, 0)
			end),
			clipsDescendants = true,
		}, {
			Roact.createElement("Frame", {
				Size = NAVBAR_SIZE,
				Position = alpha:map(function(a)
					return scale(-4 * (math.round(a * 800) / 800), 0)
				end),
				BackgroundColor3 = hex("#FFFFFF"),
				BorderSizePixel = 0,
			}, {
				Roact.createElement("UIGradient", {
					Color = theme.accentGradient.color,
					Transparency = theme.accentGradient.transparency,
					Rotation = theme.accentGradient.rotation,
				}),
				Roact.createElement("UICorner", {
					CornerRadius = UDim.new(0, 8),
				}),
			}),
		}),
	}
	local _length = #_children
	local _child = theme.outlined and Roact.createFragment({
		border = Roact.createElement(Border, {
			color = theme.foreground,
			radius = 8,
			transparency = 0.8,
		}),
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children[_length + 1] = Roact.createElement(NavbarTab, {
		page = DashboardPage.Home,
	})
	_children[_length + 2] = Roact.createElement(NavbarTab, {
		page = DashboardPage.Apps,
	})
	_children[_length + 3] = Roact.createElement(NavbarTab, {
		page = DashboardPage.Scripts,
	})
	_children[_length + 4] = Roact.createElement(NavbarTab, {
		page = DashboardPage.Options,
	})
	local _child_1 = theme.acrylic and Roact.createElement(Acrylic)
	if _child_1 then
		if _child_1.elements ~= nil or _child_1.props ~= nil and _child_1.component ~= nil then
			_children[_length + 5] = _child_1
		else
			for _k, _v in ipairs(_child_1) do
				_children[_length + 4 + _k] = _v
			end
		end
	end
	return Roact.createElement("Frame", _attributes, _children)
end
local default = hooked(Navbar)
function Underglow(props)
	return Roact.createElement("ImageLabel", {
		Image = "rbxassetid://8992238178",
		ImageColor3 = props.sequenceColor,
		ImageTransparency = props.transparency,
		Size = px(148, 104),
		Position = props.position:map(function(a)
			return UDim2.new(a, 0, 0, -18)
		end),
		AnchorPoint = Vector2.new(0.5, 0),
		BackgroundTransparency = 1,
	})
end
return {
	default = default,
}
 end,Properties={Name="Navbar"},Reference=105,ClassName="ModuleScript"}}},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Pages").default
return exports
 end,Properties={Name="Pages"},Reference=108,Children={{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Options").default
return exports
 end,Properties={Name="Options"},Reference=135,Children={{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Shortcuts").default
return exports
 end,Properties={Name="Shortcuts"},Reference=140,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useState = _roact_hooked.useState
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Card = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Card").default
local _rodux_hooks = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "rodux-hooks")
local useAppDispatch = _rodux_hooks.useAppDispatch
local useAppStore = _rodux_hooks.useAppStore
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local toggleDashboard = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "dashboard.action").toggleDashboard
local setJobActive = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "jobs.action").setJobActive
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local _ShortcutItem = TS.import(script, script.Parent, "ShortcutItem")
local ShortcutItem = _ShortcutItem.default
local ENTRY_HEIGHT = _ShortcutItem.ENTRY_HEIGHT
local PADDING = _ShortcutItem.PADDING
local ENTRY_COUNT = 6
local function Shortcuts()
	local store = useAppStore()
	local dispatch = useAppDispatch()
	local theme = useTheme("options").shortcuts
	local _binding = useState(nil)
	local selectedItem = _binding[1]
	local setSelectedItem = _binding[2]
	return Roact.createElement(Card, {
		index = 1,
		page = DashboardPage.Options,
		theme = theme,
		size = px(326, 416),
		position = UDim2.new(0, 0, 1, 0),
	}, {
		Roact.createElement("TextLabel", {
			Text = "Shortcuts",
			Font = "GothamBlack",
			TextSize = 20,
			TextColor3 = theme.foreground,
			TextXAlignment = "Left",
			TextYAlignment = "Top",
			Position = px(24, 24),
			BackgroundTransparency = 1,
		}),
		Roact.createElement(Canvas, {
			size = px(326, 348),
			position = px(0, 68),
			padding = {
				left = 24,
				right = 24,
				top = 8,
			},
			clipsDescendants = true,
		}, {
			Roact.createElement("ScrollingFrame", {
				Size = scale(1, 1),
				CanvasSize = px(0, ENTRY_COUNT * (ENTRY_HEIGHT + PADDING) + PADDING),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				ScrollBarImageTransparency = 1,
				ScrollBarThickness = 0,
				ClipsDescendants = false,
			}, {
				Roact.createElement(ShortcutItem, {
					onActivate = function()
						dispatch(toggleDashboard())
					end,
					onSelect = setSelectedItem,
					selectedItem = selectedItem,
					action = "toggleDashboard",
					description = "Open Orca",
					index = 0,
				}),
				Roact.createElement(ShortcutItem, {
					onActivate = function()
						dispatch(setJobActive("flight", not store:getState().jobs.flight.active))
					end,
					onSelect = setSelectedItem,
					selectedItem = selectedItem,
					action = "toggleFlight",
					description = "Toggle flight",
					index = 1,
				}),
				Roact.createElement(ShortcutItem, {
					onActivate = function()
						dispatch(setJobActive("freecam", not store:getState().jobs.freecam.active))
					end,
					onSelect = setSelectedItem,
					selectedItem = selectedItem,
					action = "setFreecam",
					description = "Set freecam",
					index = 2,
				}),
				Roact.createElement(ShortcutItem, {
					onActivate = function()
						dispatch(setJobActive("ghost", not store:getState().jobs.ghost.active))
					end,
					onSelect = setSelectedItem,
					selectedItem = selectedItem,
					action = "setGhost",
					description = "Set ghost mode",
					index = 3,
				}),
				Roact.createElement(ShortcutItem, {
					onActivate = function()
						dispatch(setJobActive("walkSpeed", not store:getState().jobs.walkSpeed.active))
					end,
					onSelect = setSelectedItem,
					selectedItem = selectedItem,
					action = "setSpeed",
					description = "Set walk speed",
					index = 4,
				}),
				Roact.createElement(ShortcutItem, {
					onActivate = function()
						dispatch(setJobActive("jumpHeight", not store:getState().jobs.jumpHeight.active))
					end,
					onSelect = setSelectedItem,
					selectedItem = selectedItem,
					action = "setJumpHeight",
					description = "Set jump height",
					index = 5,
				}),
			}),
		}),
	})
end
local default = hooked(Shortcuts)
return {
	default = default,
}
 end,Properties={Name="Shortcuts"},Reference=142,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local pure = _roact_hooked.pure
local useEffect = _roact_hooked.useEffect
local useState = _roact_hooked.useState
local UserInputService = TS.import(script, TS.getModule(script, "@rbxts", "services")).UserInputService
local Border = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Border").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Fill = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Fill").default
local _Glow = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Glow")
local Glow = _Glow.default
local GlowRadius = _Glow.GlowRadius
local _rodux_hooks = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "rodux-hooks")
local useAppDispatch = _rodux_hooks.useAppDispatch
local useAppSelector = _rodux_hooks.useAppSelector
local useDelayedUpdate = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useIsPageOpen = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-current-page").useIsPageOpen
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local _options_action = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "options.action")
local removeShortcut = _options_action.removeShortcut
local setShortcut = _options_action.setShortcut
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local lerp = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "number-util").lerp
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local PADDING = 20
local ENTRY_HEIGHT = 60
local ENTRY_WIDTH = 326 - 24 * 2
local ENTRY_TEXT_PADDING = 16
local function ShortcutItem(_param)
	local onActivate = _param.onActivate
	local onSelect = _param.onSelect
	local selectedItem = _param.selectedItem
	local action = _param.action
	local description = _param.description
	local index = _param.index
	local dispatch = useAppDispatch()
	local buttonTheme = useTheme("options").shortcuts.shortcutButton
	local isOpen = useIsPageOpen(DashboardPage.Options)
	local isVisible = useDelayedUpdate(isOpen, isOpen and 250 + index * 40 or 230)
	local shortcut = useAppSelector(function(state)
		return state.options.shortcuts[action]
	end)
	local _exp = Enum.KeyCode:GetEnumItems()
	local _arg0 = function(item)
		return item.Value == shortcut
	end
	-- \226\150\188 ReadonlyArray.find \226\150\188
	local _result = nil
	for _i, _v in ipairs(_exp) do
		if _arg0(_v, _i - 1, _exp) == true then
			_result = _v
			break
		end
	end
	-- \226\150\178 ReadonlyArray.find \226\150\178
	local shortcutEnum = _result
	local selected = selectedItem == action
	local _binding = useState(false)
	local hovered = _binding[1]
	local setHovered = _binding[2]
	useEffect(function()
		if selectedItem ~= nil then
			return nil
		end
		local handle = UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if not gameProcessed and input.KeyCode.Value == shortcut then
				onActivate()
			end
		end)
		return function()
			handle:Disconnect()
		end
	end, { selectedItem, shortcut })
	useEffect(function()
		if not selected then
			return nil
		end
		local handle = UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if gameProcessed then
				return nil
			end
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				onSelect(nil)
				return nil
			end
			local _exp_1 = input.KeyCode
			repeat
				if _exp_1 == (Enum.KeyCode.Unknown) then
					break
				end
				if _exp_1 == (Enum.KeyCode.Escape) then
					dispatch(removeShortcut(action))
					onSelect(nil)
					break
				end
				if _exp_1 == (Enum.KeyCode.Backspace) then
					dispatch(removeShortcut(action))
					onSelect(nil)
					break
				end
				if _exp_1 == (Enum.KeyCode.Return) then
					onSelect(nil)
					break
				end
				dispatch(setShortcut(action, input.KeyCode.Value))
				onSelect(nil)
				break
			until true
		end)
		return function()
			handle:Disconnect()
		end
	end, { selected })
	local _result_1
	if selected then
		_result_1 = buttonTheme.accent
	else
		local _result_2
		if hovered then
			local _condition = buttonTheme.backgroundHovered
			if _condition == nil then
				_condition = buttonTheme.background:Lerp(buttonTheme.accent, 0.1)
			end
			_result_2 = _condition
		else
			_result_2 = buttonTheme.background
		end
		_result_1 = _result_2
	end
	local background = useSpring(_result_1, {})
	local _result_2
	if selected then
		_result_2 = buttonTheme.accent
	else
		local _result_3
		if hovered then
			local _condition = buttonTheme.backgroundHovered
			if _condition == nil then
				_condition = buttonTheme.dropshadow:Lerp(buttonTheme.accent, 0.5)
			end
			_result_3 = _condition
		else
			_result_3 = buttonTheme.dropshadow
		end
		_result_2 = _result_3
	end
	local dropshadow = useSpring(_result_2, {})
	local foreground = useSpring(selected and buttonTheme.foregroundAccent and buttonTheme.foregroundAccent or buttonTheme.foreground, {})
	local _attributes = {
		size = px(ENTRY_WIDTH, ENTRY_HEIGHT),
		position = useSpring(isVisible and px(0, (PADDING + ENTRY_HEIGHT) * index) or px(-ENTRY_WIDTH - 24, (PADDING + ENTRY_HEIGHT) * index), {}),
		zIndex = index,
	}
	local _children = {
		Roact.createElement(Glow, {
			radius = GlowRadius.Size70,
			color = dropshadow,
			size = UDim2.new(1, 36, 1, 36),
			position = px(-18, 5 - 18),
			transparency = useSpring(selected and buttonTheme.glowTransparency or (hovered and lerp(buttonTheme.dropshadowTransparency, buttonTheme.glowTransparency, 0.5) or buttonTheme.dropshadowTransparency), {}),
		}),
		Roact.createElement(Fill, {
			color = background,
			transparency = buttonTheme.backgroundTransparency,
			radius = 8,
		}),
		Roact.createElement("TextLabel", {
			Text = description,
			Font = "GothamBold",
			TextSize = 16,
			TextColor3 = foreground,
			TextXAlignment = "Left",
			TextYAlignment = "Center",
			TextTransparency = useSpring(selected and 0 or (hovered and buttonTheme.foregroundTransparency / 2 or buttonTheme.foregroundTransparency), {}),
			Position = px(ENTRY_TEXT_PADDING, 1),
			Size = UDim2.new(1, -ENTRY_TEXT_PADDING, 1, -1),
			BackgroundTransparency = 1,
			ClipsDescendants = true,
		}),
		Roact.createElement("TextLabel", {
			Text = shortcutEnum and shortcutEnum.Name or "Not bound",
			Font = "GothamBold",
			TextSize = 16,
			TextColor3 = foreground,
			TextXAlignment = "Center",
			TextYAlignment = "Center",
			TextTransparency = useSpring(selected and 0 or (hovered and buttonTheme.foregroundTransparency / 2 or buttonTheme.foregroundTransparency), {}),
			TextTruncate = "AtEnd",
			AnchorPoint = Vector2.new(1, 0),
			Position = UDim2.new(1, 0, 0, 1),
			Size = UDim2.new(0, 124, 1, -1),
			BackgroundTransparency = 1,
			ClipsDescendants = true,
		}),
		Roact.createElement("Frame", {
			Size = buttonTheme.outlined and UDim2.new(0, 1, 1, -2) or UDim2.new(0, 1, 1, -36),
			Position = buttonTheme.outlined and UDim2.new(1, -124, 0, 1) or UDim2.new(1, -124, 0, 18),
			BackgroundColor3 = foreground,
			BackgroundTransparency = 0.8,
			BorderSizePixel = 0,
		}),
	}
	local _length = #_children
	local _child = buttonTheme.outlined and Roact.createElement(Border, {
		color = foreground,
		transparency = 0.8,
		radius = 8,
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children[_length + 1] = Roact.createElement("TextButton", {
		[Roact.Event.Activated] = function()
			return onSelect(action)
		end,
		[Roact.Event.MouseEnter] = function()
			return setHovered(true)
		end,
		[Roact.Event.MouseLeave] = function()
			return setHovered(false)
		end,
		Text = "",
		Size = scale(1, 1),
		Transparency = 1,
	})
	return Roact.createElement(Canvas, _attributes, _children)
end
local default = pure(ShortcutItem)
return {
	PADDING = PADDING,
	ENTRY_HEIGHT = ENTRY_HEIGHT,
	ENTRY_WIDTH = ENTRY_WIDTH,
	ENTRY_TEXT_PADDING = ENTRY_TEXT_PADDING,
	default = default,
}
 end,Properties={Name="ShortcutItem"},Reference=141,ClassName="ModuleScript"}}},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Themes").default
return exports
 end,Properties={Name="Themes"},Reference=143,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useState = _roact_hooked.useState
local Border = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Border").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Fill = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Fill").default
local _Glow = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Glow")
local Glow = _Glow.default
local GlowRadius = _Glow.GlowRadius
local _rodux_hooks = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "rodux-hooks")
local useAppDispatch = _rodux_hooks.useAppDispatch
local useAppSelector = _rodux_hooks.useAppSelector
local useDelayedUpdate = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useIsPageOpen = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-current-page").useIsPageOpen
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local setTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "options.action").setTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local _color3 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "color3")
local getLuminance = _color3.getLuminance
local hex = _color3.hex
local lerp = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "number-util").lerp
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local PADDING = 20
local ENTRY_HEIGHT = 60
local ENTRY_WIDTH = 326 - 24 * 2
local ENTRY_TEXT_PADDING = 16
local ThemePreview
local function ThemeItem(_param)
	local theme = _param.theme
	local index = _param.index
	local dispatch = useAppDispatch()
	local buttonTheme = useTheme("options").themes.themeButton
	local isOpen = useIsPageOpen(DashboardPage.Options)
	local isVisible = useDelayedUpdate(isOpen, isOpen and 300 + index * 40 or 280)
	local isSelected = useAppSelector(function(state)
		return state.options.currentTheme == theme.name
	end)
	local _binding = useState(false)
	local hovered = _binding[1]
	local setHovered = _binding[2]
	local _result
	if isSelected then
		_result = buttonTheme.accent
	else
		local _result_1
		if hovered then
			local _condition = buttonTheme.backgroundHovered
			if _condition == nil then
				_condition = buttonTheme.background:Lerp(buttonTheme.accent, 0.1)
			end
			_result_1 = _condition
		else
			_result_1 = buttonTheme.background
		end
		_result = _result_1
	end
	local background = useSpring(_result, {})
	local _result_1
	if isSelected then
		_result_1 = buttonTheme.accent
	else
		local _result_2
		if hovered then
			local _condition = buttonTheme.backgroundHovered
			if _condition == nil then
				_condition = buttonTheme.dropshadow:Lerp(buttonTheme.accent, 0.5)
			end
			_result_2 = _condition
		else
			_result_2 = buttonTheme.dropshadow
		end
		_result_1 = _result_2
	end
	local dropshadow = useSpring(_result_1, {})
	local foreground = useSpring(isSelected and buttonTheme.foregroundAccent and buttonTheme.foregroundAccent or buttonTheme.foreground, {})
	local _attributes = {
		size = px(ENTRY_WIDTH, ENTRY_HEIGHT),
		position = useSpring(isVisible and px(0, (PADDING + ENTRY_HEIGHT) * index) or px(-ENTRY_WIDTH - 24, (PADDING + ENTRY_HEIGHT) * index), {}),
		zIndex = index,
	}
	local _children = {
		Roact.createElement(Glow, {
			radius = GlowRadius.Size70,
			color = dropshadow,
			size = UDim2.new(1, 36, 1, 36),
			position = px(-18, 5 - 18),
			transparency = useSpring(isSelected and buttonTheme.glowTransparency or (hovered and lerp(buttonTheme.dropshadowTransparency, buttonTheme.glowTransparency, 0.5) or buttonTheme.dropshadowTransparency), {}),
		}),
		Roact.createElement(Fill, {
			color = background,
			transparency = buttonTheme.backgroundTransparency,
			radius = 8,
		}),
		Roact.createElement("TextLabel", {
			Text = theme.name,
			Font = "GothamBold",
			TextSize = 16,
			TextColor3 = foreground,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextYAlignment = Enum.TextYAlignment.Center,
			TextTransparency = useSpring(isSelected and 0 or (hovered and buttonTheme.foregroundTransparency / 2 or buttonTheme.foregroundTransparency), {}),
			BackgroundTransparency = 1,
			Position = px(ENTRY_TEXT_PADDING, 1),
			Size = UDim2.new(1, -ENTRY_TEXT_PADDING, 1, -1),
			ClipsDescendants = true,
		}),
		Roact.createElement(ThemePreview, {
			color = background,
			previewTheme = theme.preview,
		}),
	}
	local _length = #_children
	local _child = buttonTheme.outlined and Roact.createElement(Border, {
		color = foreground,
		transparency = 0.8,
		radius = 8,
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children[_length + 1] = Roact.createElement("TextButton", {
		[Roact.Event.Activated] = function()
			return not isSelected and dispatch(setTheme(theme.name))
		end,
		[Roact.Event.MouseEnter] = function()
			return setHovered(true)
		end,
		[Roact.Event.MouseLeave] = function()
			return setHovered(false)
		end,
		Text = "",
		Transparency = 1,
		Size = scale(1, 1),
	})
	return Roact.createElement(Canvas, _attributes, _children)
end
local default = hooked(ThemeItem)
function ThemePreview(_param)
	local color = _param.color
	local previewTheme = _param.previewTheme
	return Roact.createElement("Frame", {
		AnchorPoint = Vector2.new(1, 0),
		Size = UDim2.new(0, 114, 1, -4),
		Position = UDim2.new(1, -2, 0, 2),
		BackgroundColor3 = color,
		Transparency = 1,
		BorderSizePixel = 0,
	}, {
		Roact.createElement("UICorner", {
			CornerRadius = UDim.new(0, 6),
		}),
		Roact.createElement("Frame", {
			AnchorPoint = Vector2.new(0, 0.5),
			Size = px(25, 25),
			Position = UDim2.new(0, 12, 0.5, 0),
			BackgroundColor3 = hex("#ffffff"),
			BorderSizePixel = 0,
		}, {
			Roact.createElement("UICorner", {
				CornerRadius = UDim.new(1, 0),
			}),
			Roact.createElement("UIGradient", {
				Color = previewTheme.foreground.color,
				Transparency = previewTheme.foreground.transparency,
				Rotation = previewTheme.foreground.rotation,
			}),
			Roact.createElement("UIStroke", {
				Color = getLuminance(previewTheme.foreground.color) > 0.5 and hex("#000000") or hex("#ffffff"),
				Transparency = 0.5,
				Thickness = 2,
			}),
		}),
		Roact.createElement("Frame", {
			AnchorPoint = Vector2.new(0.5, 0.5),
			Size = px(25, 25),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			BackgroundColor3 = hex("#ffffff"),
			BorderSizePixel = 0,
		}, {
			Roact.createElement("UICorner", {
				CornerRadius = UDim.new(1, 0),
			}),
			Roact.createElement("UIGradient", {
				Color = previewTheme.background.color,
				Transparency = previewTheme.background.transparency,
				Rotation = previewTheme.background.rotation,
			}),
			Roact.createElement("UIStroke", {
				Color = getLuminance(previewTheme.background.color) > 0.5 and hex("#000000") or hex("#ffffff"),
				Transparency = 0.5,
				Thickness = 2,
			}),
		}),
		Roact.createElement("Frame", {
			AnchorPoint = Vector2.new(1, 0.5),
			Size = px(25, 25),
			Position = UDim2.new(1, -12, 0.5, 0),
			BackgroundColor3 = hex("#ffffff"),
			BorderSizePixel = 0,
		}, {
			Roact.createElement("UICorner", {
				CornerRadius = UDim.new(1, 0),
			}),
			Roact.createElement("UIGradient", {
				Color = previewTheme.accent.color,
				Transparency = previewTheme.accent.transparency,
				Rotation = previewTheme.accent.rotation,
			}),
			Roact.createElement("UIStroke", {
				Color = getLuminance(previewTheme.accent.color) > 0.5 and hex("#000000") or hex("#ffffff"),
				Transparency = 0.5,
				Thickness = 2,
			}),
		}),
	})
end
return {
	PADDING = PADDING,
	ENTRY_HEIGHT = ENTRY_HEIGHT,
	ENTRY_WIDTH = ENTRY_WIDTH,
	ENTRY_TEXT_PADDING = ENTRY_TEXT_PADDING,
	default = default,
}
 end,Properties={Name="ThemeItem"},Reference=144,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useMemo = _roact_hooked.useMemo
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Card = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Card").default
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local getThemes = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "themes").getThemes
local arrayToMap = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "array-util").arrayToMap
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local _ThemeItem = TS.import(script, script.Parent, "ThemeItem")
local ThemeItem = _ThemeItem.default
local ENTRY_HEIGHT = _ThemeItem.ENTRY_HEIGHT
local PADDING = _ThemeItem.PADDING
local function Themes()
	local theme = useTheme("options").themes
	local themes = useMemo(getThemes, {})
	local _attributes = {
		index = 2,
		page = DashboardPage.Options,
		theme = theme,
		size = px(326, 416),
		position = UDim2.new(0, 374, 1, 0),
	}
	local _children = {
		Roact.createElement("TextLabel", {
			Text = "Themes",
			Font = "GothamBlack",
			TextSize = 20,
			TextColor3 = theme.foreground,
			TextXAlignment = "Left",
			TextYAlignment = "Top",
			Position = px(24, 24),
			BackgroundTransparency = 1,
		}),
	}
	local _length = #_children
	local _attributes_1 = {
		size = px(326, 348),
		position = px(0, 68),
		padding = {
			left = 24,
			right = 24,
			top = 8,
		},
		clipsDescendants = true,
	}
	local _children_1 = {}
	local _length_1 = #_children_1
	local _attributes_2 = {
		Size = scale(1, 1),
		CanvasSize = px(0, #themes * (ENTRY_HEIGHT + PADDING) + PADDING),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		ScrollBarImageTransparency = 1,
		ScrollBarThickness = 0,
		ClipsDescendants = false,
	}
	local _children_2 = {}
	local _length_2 = #_children_2
	for _k, _v in pairs(arrayToMap(themes, function(theme, index)
		return { theme.name, Roact.createElement(ThemeItem, {
			theme = theme,
			index = index,
		}) }
	end)) do
		_children_2[_k] = _v
	end
	_children_1[_length_1 + 1] = Roact.createElement("ScrollingFrame", _attributes_2, _children_2)
	_children[_length + 1] = Roact.createElement(Canvas, _attributes_1, _children_1)
	return Roact.createElement(Card, _attributes, _children)
end
local default = hooked(Themes)
return {
	default = default,
}
 end,Properties={Name="Themes"},Reference=145,ClassName="ModuleScript"}}},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local pure = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).pure
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useScale = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "use-scale").useScale
local scale = TS.import(script, script.Parent.Parent.Parent.Parent, "utils", "udim2").scale
local Config = TS.import(script, script.Parent, "Config").default
local Shortcuts = TS.import(script, script.Parent, "Shortcuts").default
local Themes = TS.import(script, script.Parent, "Themes").default
local function Options()
	local scaleFactor = useScale()
	return Roact.createElement(Canvas, {
		position = scale(0, 1),
		anchor = Vector2.new(0, 1),
	}, {
		Roact.createElement("UIScale", {
			Scale = scaleFactor,
		}),
		Roact.createElement(Config),
		Roact.createElement(Themes),
		Roact.createElement(Shortcuts),
	})
end
local default = pure(Options)
return {
	default = default,
}
 end,Properties={Name="Options"},Reference=139,ClassName="ModuleScript"},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Config").default
return exports
 end,Properties={Name="Config"},Reference=136,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Card = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Card").default
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local _ConfigItem = TS.import(script, script.Parent, "ConfigItem")
local ConfigItem = _ConfigItem.default
local ENTRY_HEIGHT = _ConfigItem.ENTRY_HEIGHT
local PADDING = _ConfigItem.PADDING
local ENTRY_COUNT = 1
local function Config()
	local theme = useTheme("options").config
	return Roact.createElement(Card, {
		index = 0,
		page = DashboardPage.Options,
		theme = theme,
		size = px(326, 184),
		position = UDim2.new(0, 0, 1, -416 - 48),
	}, {
		Roact.createElement("TextLabel", {
			Text = "Options",
			Font = "GothamBlack",
			TextSize = 20,
			TextColor3 = theme.foreground,
			TextXAlignment = "Left",
			TextYAlignment = "Top",
			Position = px(24, 24),
			BackgroundTransparency = 1,
		}),
		Roact.createElement(Canvas, {
			size = px(326, 348),
			position = px(0, 68),
			padding = {
				left = 24,
				right = 24,
				top = 8,
			},
			clipsDescendants = true,
		}, {
			Roact.createElement("ScrollingFrame", {
				Size = scale(1, 1),
				CanvasSize = px(0, ENTRY_COUNT * (ENTRY_HEIGHT + PADDING) + PADDING),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				ScrollBarImageTransparency = 1,
				ScrollBarThickness = 0,
				ClipsDescendants = false,
			}, {
				Roact.createElement(ConfigItem, {
					action = "acrylicBlur",
					description = "Acrylic background blurring",
					hint = "<font face='GothamBlack'>Toggle BG blur</font> in some themes. May be detectable when enabled.",
					index = 0,
				}),
			}),
		}),
	})
end
local default = hooked(Config)
return {
	default = default,
}
 end,Properties={Name="Config"},Reference=137,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local pure = _roact_hooked.pure
local useState = _roact_hooked.useState
local Border = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Border").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Fill = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Fill").default
local _Glow = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Glow")
local Glow = _Glow.default
local GlowRadius = _Glow.GlowRadius
local _rodux_hooks = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "rodux-hooks")
local useAppDispatch = _rodux_hooks.useAppDispatch
local useAppSelector = _rodux_hooks.useAppSelector
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local _dashboard_action = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "dashboard.action")
local clearHint = _dashboard_action.clearHint
local setHint = _dashboard_action.setHint
local setConfig = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "options.action").setConfig
local lerp = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "number-util").lerp
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local PADDING = 20
local ENTRY_HEIGHT = 60
local ENTRY_WIDTH = 326 - 24 * 2
local ENTRY_TEXT_PADDING = 16
local function ConfigItem(_param)
	local action = _param.action
	local description = _param.description
	local hint = _param.hint
	local index = _param.index
	local dispatch = useAppDispatch()
	local buttonTheme = useTheme("options").config.configButton
	local active = useAppSelector(function(state)
		return state.options.config[action]
	end)
	local _binding = useState(false)
	local hovered = _binding[1]
	local setHovered = _binding[2]
	local _result
	if active then
		_result = buttonTheme.accent
	else
		local _result_1
		if hovered then
			local _condition = buttonTheme.backgroundHovered
			if _condition == nil then
				_condition = buttonTheme.background:Lerp(buttonTheme.accent, 0.1)
			end
			_result_1 = _condition
		else
			_result_1 = buttonTheme.background
		end
		_result = _result_1
	end
	local background = useSpring(_result, {})
	local _result_1
	if active then
		_result_1 = buttonTheme.accent
	else
		local _result_2
		if hovered then
			local _condition = buttonTheme.backgroundHovered
			if _condition == nil then
				_condition = buttonTheme.dropshadow:Lerp(buttonTheme.accent, 0.5)
			end
			_result_2 = _condition
		else
			_result_2 = buttonTheme.dropshadow
		end
		_result_1 = _result_2
	end
	local dropshadow = useSpring(_result_1, {})
	local foreground = useSpring(active and buttonTheme.foregroundAccent and buttonTheme.foregroundAccent or buttonTheme.foreground, {})
	local _attributes = {
		size = px(ENTRY_WIDTH, ENTRY_HEIGHT),
		position = px(0, (PADDING + ENTRY_HEIGHT) * index),
		zIndex = index,
	}
	local _children = {
		Roact.createElement(Glow, {
			radius = GlowRadius.Size70,
			color = dropshadow,
			size = UDim2.new(1, 36, 1, 36),
			position = px(-18, 5 - 18),
			transparency = useSpring(active and buttonTheme.glowTransparency or (hovered and lerp(buttonTheme.dropshadowTransparency, buttonTheme.glowTransparency, 0.5) or buttonTheme.dropshadowTransparency), {}),
		}),
		Roact.createElement(Fill, {
			color = background,
			transparency = buttonTheme.backgroundTransparency,
			radius = 8,
		}),
		Roact.createElement("TextLabel", {
			Text = description,
			Font = "GothamBold",
			TextSize = 16,
			TextColor3 = foreground,
			TextXAlignment = "Left",
			TextYAlignment = "Center",
			TextTransparency = useSpring(active and 0 or (hovered and buttonTheme.foregroundTransparency / 2 or buttonTheme.foregroundTransparency), {}),
			Position = px(ENTRY_TEXT_PADDING, 1),
			Size = UDim2.new(1, -ENTRY_TEXT_PADDING, 1, -1),
			BackgroundTransparency = 1,
			ClipsDescendants = true,
		}),
	}
	local _length = #_children
	local _child = buttonTheme.outlined and Roact.createElement(Border, {
		color = foreground,
		transparency = 0.8,
		radius = 8,
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children[_length + 1] = Roact.createElement("TextButton", {
		[Roact.Event.Activated] = function()
			return dispatch(setConfig(action, not active))
		end,
		[Roact.Event.MouseEnter] = function()
			setHovered(true)
			dispatch(setHint(hint))
		end,
		[Roact.Event.MouseLeave] = function()
			setHovered(false)
			dispatch(clearHint())
		end,
		Text = "",
		Size = scale(1, 1),
		Transparency = 1,
	})
	return Roact.createElement(Canvas, _attributes, _children)
end
local default = pure(ConfigItem)
return {
	PADDING = PADDING,
	ENTRY_HEIGHT = ENTRY_HEIGHT,
	ENTRY_WIDTH = ENTRY_WIDTH,
	ENTRY_TEXT_PADDING = ENTRY_TEXT_PADDING,
	default = default,
}
 end,Properties={Name="ConfigItem"},Reference=138,ClassName="ModuleScript"}}}}},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local useDelayedUpdate = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useCurrentPage = TS.import(script, script.Parent.Parent.Parent, "hooks", "use-current-page").useCurrentPage
local DashboardPage = TS.import(script, script.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local Apps = TS.import(script, script.Parent, "Apps").default
local Home = TS.import(script, script.Parent, "Home").default
local Options = TS.import(script, script.Parent, "Options").default
local Scripts = TS.import(script, script.Parent, "Scripts").default
local function Pages()
	local currentPage = useCurrentPage()
	local isScriptsVisible = useDelayedUpdate(currentPage == DashboardPage.Scripts, 2000, function(isVisible)
		return isVisible
	end)
	local _children = {
		home = Roact.createFragment({
			home = Roact.createElement(Home),
		}),
		apps = Roact.createFragment({
			apps = Roact.createElement(Apps),
		}),
	}
	local _length = #_children
	local _child = isScriptsVisible and Roact.createFragment({
		scripts = Roact.createElement(Scripts),
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children.options = Roact.createFragment({
		options = Roact.createElement(Options),
	})
	return Roact.createFragment(_children)
end
local default = hooked(Pages)
return {
	default = default,
}
 end,Properties={Name="Pages"},Reference=146,ClassName="ModuleScript"},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Scripts").default
return exports
 end,Properties={Name="Scripts"},Reference=147,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useEffect = _roact_hooked.useEffect
local Border = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "Border").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Fill = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "Fill").default
local ParallaxImage = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "ParallaxImage").default
local useDelayedUpdate = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useIsMount = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "common", "use-did-mount").useIsMount
local useForcedUpdate = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "common", "use-forced-update").useForcedUpdate
local useSetState = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "common", "use-set-state").default
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useIsPageOpen = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "use-current-page").useIsPageOpen
local useParallaxOffset = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "use-parallax-offset").useParallaxOffset
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local hex = TS.import(script, script.Parent.Parent.Parent.Parent, "utils", "color3").hex
local scale = TS.import(script, script.Parent.Parent.Parent.Parent, "utils", "udim2").scale
local shineSpringOptions = {
	dampingRatio = 3,
	frequency = 2,
}
local function ScriptCard(_param)
	local index = _param.index
	local backgroundImage = _param.backgroundImage
	local backgroundImageSize = _param.backgroundImageSize
	local dropshadow = _param.dropshadow
	local dropshadowSize = _param.dropshadowSize
	local dropshadowPosition = _param.dropshadowPosition
	local anchorPoint = _param.anchorPoint
	local size = _param.size
	local position = _param.position
	local onActivate = _param.onActivate
	local children = _param[Roact.Children]
	local rerender = useForcedUpdate()
	local isCurrentlyOpen = useIsPageOpen(DashboardPage.Scripts)
	local _result
	if useIsMount() then
		_result = false
	else
		_result = isCurrentlyOpen
	end
	local isOpen = _result
	local isTransitioning = useDelayedUpdate(isOpen, index * 30)
	useEffect(function()
		return rerender()
	end, {})
	local offset = useParallaxOffset()
	local _binding = useSetState({
		isHovered = false,
		isPressed = false,
	})
	local _binding_1 = _binding[1]
	local isHovered = _binding_1.isHovered
	local isPressed = _binding_1.isPressed
	local setButtonState = _binding[2]
	local _attributes = {
		anchor = anchorPoint,
		size = size,
	}
	local _result_1
	if isTransitioning then
		_result_1 = position
	else
		local _uDim2 = UDim2.new(0, 0, 1, 48 * 3 + 56)
		_result_1 = position + _uDim2
	end
	_attributes.position = useSpring(_result_1, {
		frequency = 2.2,
		dampingRatio = 0.75,
	})
	local _children = {}
	local _length = #_children
	local _attributes_1 = {
		anchor = Vector2.new(0.5, 0.5),
		size = useSpring(isHovered and not isPressed and UDim2.new(1, 48, 1, 48) or scale(1, 1), {
			frequency = 2,
		}),
		position = scale(0.5, 0.5),
	}
	local _children_1 = {
		Roact.createElement("ImageLabel", {
			Image = dropshadow,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Size = scale(dropshadowSize.X, dropshadowSize.Y),
			Position = scale(dropshadowPosition.X, dropshadowPosition.Y),
			BackgroundTransparency = 1,
		}),
		Roact.createElement(ParallaxImage, {
			image = backgroundImage,
			imageSize = backgroundImageSize,
			padding = Vector2.new(50, 50),
			offset = offset,
		}, {
			Roact.createElement("UICorner", {
				CornerRadius = UDim.new(0, 16),
			}),
		}),
	}
	local _length_1 = #_children_1
	local _attributes_2 = {
		clipsDescendants = true,
	}
	local _children_2 = {}
	local _length_2 = #_children_2
	if children then
		for _k, _v in pairs(children) do
			if type(_k) == "number" then
				_children_2[_length_2 + _k] = _v
			else
				_children_2[_k] = _v
			end
		end
	end
	_children_1[_length_1 + 1] = Roact.createElement(Canvas, _attributes_2, _children_2)
	_children_1[_length_1 + 2] = Roact.createElement(Fill, {
		radius = 16,
		color = hex("#ffffff"),
		transparency = useSpring(isHovered and 0 or 1, shineSpringOptions),
	}, {
		Roact.createElement("UIGradient", {
			Transparency = NumberSequence.new(0.75, 1),
			Offset = useSpring(isHovered and Vector2.new(0, 0) or Vector2.new(-1, -1), shineSpringOptions),
			Rotation = 45,
		}),
	})
	_children_1[_length_1 + 3] = Roact.createElement(Border, {
		radius = 18,
		size = 3,
		color = hex("#ffffff"),
		transparency = useSpring(isHovered and 0 or 1, shineSpringOptions),
	}, {
		Roact.createElement("UIGradient", {
			Transparency = NumberSequence.new(0.7, 0.9),
			Offset = useSpring(isHovered and Vector2.new(0, 0) or Vector2.new(-1, -1), shineSpringOptions),
			Rotation = 45,
		}),
	})
	_children_1[_length_1 + 4] = Roact.createElement(Border, {
		color = hex("#ffffff"),
		radius = 16,
		transparency = useSpring(isHovered and 1 or 0.8, {}),
	})
	_children[_length + 1] = Roact.createElement(Canvas, _attributes_1, _children_1)
	_children[_length + 2] = Roact.createElement("TextButton", {
		[Roact.Event.Activated] = function()
			return onActivate()
		end,
		[Roact.Event.MouseEnter] = function()
			return setButtonState({
				isHovered = true,
			})
		end,
		[Roact.Event.MouseLeave] = function()
			return setButtonState({
				isHovered = false,
				isPressed = false,
			})
		end,
		[Roact.Event.MouseButton1Down] = function()
			return setButtonState({
				isPressed = true,
			})
		end,
		[Roact.Event.MouseButton1Up] = function()
			return setButtonState({
				isPressed = false,
			})
		end,
		Size = scale(1, 1),
		Text = "",
		Transparency = 1,
	})
	return Roact.createElement(Canvas, _attributes, _children)
end
local default = hooked(ScriptCard)
return {
	default = default,
}
 end,Properties={Name="ScriptCard"},Reference=149,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local BASE_WINDOW_HEIGHT = 880
local BASE_WINDOW_WIDTH = 1824
local BASE_PADDING = 48
return {
	BASE_WINDOW_HEIGHT = BASE_WINDOW_HEIGHT,
	BASE_WINDOW_WIDTH = BASE_WINDOW_WIDTH,
	BASE_PADDING = BASE_PADDING,
}
 end,Properties={Name="constants"},Reference=151,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local pure = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).pure
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "Canvas").default
local http = TS.import(script, script.Parent.Parent.Parent.Parent, "utils", "http")
local scale = TS.import(script, script.Parent.Parent.Parent.Parent, "utils", "udim2").scale
local _constants = TS.import(script, script.Parent, "constants")
local BASE_PADDING = _constants.BASE_PADDING
local BASE_WINDOW_HEIGHT = _constants.BASE_WINDOW_HEIGHT
local Content = TS.import(script, script.Parent, "Content").default
local ScriptCard = TS.import(script, script.Parent, "ScriptCard").default
local runScriptFromUrl = TS.async(function(url, src)
	local _exitType, _returns = TS.try(function()
		local content = TS.await(http.get(url))
		local fn, err = loadstring(content, "@" .. src)
		local _arg1 = "Failed to call loadstring on Lua script from '" .. (url .. ("': " .. tostring(err)))
		assert(fn, _arg1)
		task.defer(fn)
	end, function(e)
		warn("Failed to run Lua script from '" .. (url .. ("': " .. tostring(e))))
		return TS.TRY_RETURN, { "" }
	end)
	if _exitType then
		return unpack(_returns)
	end
end)
local function Scripts()
	return Roact.createElement(Canvas, {
		position = scale(0, 1),
		anchor = Vector2.new(0, 1),
	}, {
		Roact.createElement(ScriptCard, {
			onActivate = function()
				return runScriptFromUrl("https://solarishub.dev/script.lua", "Solaris")
			end,
			index = 4,
			backgroundImage = "rbxassetid://8992292705",
			backgroundImageSize = Vector2.new(1023, 682),
			dropshadow = "rbxassetid://8992292536",
			dropshadowSize = Vector2.new(1.15, 1.25),
			dropshadowPosition = Vector2.new(0.5, 0.55),
			anchorPoint = Vector2.new(0, 0),
			size = UDim2.new(1 / 3, -BASE_PADDING * (2 / 3), (416 + BASE_PADDING / 2) / BASE_WINDOW_HEIGHT, -BASE_PADDING / 2),
			position = scale(0, 0),
		}, {
			Roact.createElement(Content, {
				header = "Solaris",
				body = "A collection\nof your favorite\nscripts.",
				footer = "solarishub.dev",
			}),
		}),
		Roact.createElement(ScriptCard, {
			onActivate = function()
				return runScriptFromUrl("https://raw.githubusercontent.com/1201for/V.G-Hub/main/V.Ghub", "V.G Hub")
			end,
			index = 1,
			backgroundImage = "rbxassetid://8992292381",
			backgroundImageSize = Vector2.new(1021, 1023),
			dropshadow = "rbxassetid://8992291993",
			dropshadowSize = Vector2.new(1.15, 1.25),
			dropshadowPosition = Vector2.new(0.5, 0.55),
			anchorPoint = Vector2.new(0, 1),
			size = UDim2.new(1 / 3, -BASE_PADDING * (2 / 3), (416 + BASE_PADDING / 2) / BASE_WINDOW_HEIGHT, -BASE_PADDING / 2),
			position = scale(0, 1),
		}, {
			Roact.createElement(Content, {
				header = "V.G Hub",
				body = "Featuring over\n100 games.",
				footer = "github.com/1201for",
			}),
		}),
		Roact.createElement(ScriptCard, {
			onActivate = function()
				return runScriptFromUrl("https://raw.githubusercontent.com/CMD-X/CMD-X/master/Source", "CMD-X")
			end,
			index = 5,
			backgroundImage = "rbxassetid://8992291779",
			backgroundImageSize = Vector2.new(818, 1023),
			dropshadow = "rbxassetid://8992291581",
			dropshadowSize = Vector2.new(1.15, 1.4),
			dropshadowPosition = Vector2.new(0.5, 0.6),
			anchorPoint = Vector2.new(0.5, 0),
			size = UDim2.new(1 / 3, -BASE_PADDING * (2 / 3), (242 + BASE_PADDING / 2) / BASE_WINDOW_HEIGHT, -BASE_PADDING / 2),
			position = scale(0.5, 0),
		}, {
			Roact.createElement(Content, {
				header = "CMD-X",
				footer = "github.com/CMD-X",
			}),
		}),
		Roact.createElement(ScriptCard, {
			onActivate = function()
				return runScriptFromUrl("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source", "Infinite Yield")
			end,
			index = 3,
			backgroundImage = "rbxassetid://8992291444",
			backgroundImageSize = Vector2.new(1023, 682),
			dropshadow = "rbxassetid://8992291268",
			dropshadowSize = Vector2.new(1.15, 1.4),
			dropshadowPosition = Vector2.new(0.5, 0.6),
			anchorPoint = Vector2.new(0.5, 0),
			size = UDim2.new(1 / 3, -BASE_PADDING * (2 / 3), (242 + BASE_PADDING) / BASE_WINDOW_HEIGHT, -BASE_PADDING),
			position = UDim2.new(0.5, 0, 1 - (590 + BASE_PADDING / 2) / BASE_WINDOW_HEIGHT, BASE_PADDING / 2),
		}, {
			Roact.createElement(Content, {
				header = "Infinite Yield",
				footer = "github.com/EdgeIY",
			}),
		}),
		Roact.createElement(ScriptCard, {
			onActivate = function()
				return runScriptFromUrl("https://pastebin.com/raw/mMbsHWiQ", "Dex Explorer")
			end,
			index = 1,
			backgroundImage = "rbxassetid://8992290931",
			backgroundImageSize = Vector2.new(818, 1023),
			dropshadow = "rbxassetid://8992291101",
			dropshadowSize = Vector2.new(1.15, 1.35),
			dropshadowPosition = Vector2.new(0.5, 0.55),
			anchorPoint = Vector2.new(0.5, 1),
			size = UDim2.new(1 / 3, -BASE_PADDING * (2 / 3), (300 + BASE_PADDING / 2) / BASE_WINDOW_HEIGHT, -BASE_PADDING / 2),
			position = scale(0.5, 1),
		}, {
			Roact.createElement(Content, {
				header = "Dex Explorer",
				footer = "github.com/LorekeeperZinnia",
			}),
		}),
		Roact.createElement(ScriptCard, {
			onActivate = function()
				return runScriptFromUrl("https://raw.githubusercontent.com/ic3w0lf22/Unnamed-ESP/master/UnnamedESP.lua", "Unnamed ESP")
			end,
			index = 6,
			backgroundImage = "rbxassetid://8992290714",
			backgroundImageSize = Vector2.new(1023, 682),
			dropshadow = "rbxassetid://8992290570",
			dropshadowSize = Vector2.new(1.15, 1.35),
			dropshadowPosition = Vector2.new(0.5, 0.55),
			anchorPoint = Vector2.new(1, 0),
			size = UDim2.new(1 / 3, -BASE_PADDING * (2 / 3), (300 + BASE_PADDING / 2) / BASE_WINDOW_HEIGHT, -BASE_PADDING / 2),
			position = scale(1, 0),
		}, {
			Roact.createElement(Content, {
				header = "Unnamed ESP",
				footer = "github.com/ic3w0lf22",
			}),
		}),
		Roact.createElement(ScriptCard, {
			onActivate = function()
				return runScriptFromUrl("https://projectevo.xyz/script/loader.lua", "EvoV2")
			end,
			index = 2,
			backgroundImage = "rbxassetid://8992290314",
			backgroundImageSize = Vector2.new(682, 1023),
			dropshadow = "rbxassetid://8992290105",
			dropshadowSize = Vector2.new(1.15, 1.22),
			dropshadowPosition = Vector2.new(0.5, 0.53),
			anchorPoint = Vector2.new(1, 1),
			size = UDim2.new(1 / 3, -BASE_PADDING * (2 / 3), (532 + BASE_PADDING / 2) / BASE_WINDOW_HEIGHT, -BASE_PADDING / 2),
			position = scale(1, 1),
		}, {
			Roact.createElement(Content, {
				header = "EvoV2",
				body = "Reliable cheats for\nRoblox's top shooter\ngames, reimagined.",
				footer = "projectevo.xyz",
			}),
		}),
	})
end
local default = pure(Scripts)
return {
	default = default,
}
 end,Properties={Name="Scripts"},Reference=150,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useScale = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "use-scale").useScale
local hex = TS.import(script, script.Parent.Parent.Parent.Parent, "utils", "color3").hex
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local HeaderCenter, HeaderTopLeft
local function Content(_param)
	local header = _param.header
	local body = _param.body
	local footer = _param.footer
	local scaleFactor = useScale()
	local _attributes = {
		padding = {
			top = scaleFactor:map(function(s)
				return s * 48
			end),
			left = scaleFactor:map(function(s)
				return s * 48
			end),
			bottom = scaleFactor:map(function(s)
				return s * 48
			end),
			right = scaleFactor:map(function(s)
				return s * 48
			end),
		},
	}
	local _children = {}
	local _length = #_children
	local _child = body == nil and Roact.createElement(HeaderCenter, {
		header = header,
		scaleFactor = scaleFactor,
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	local _child_1 = body ~= nil and Roact.createElement(HeaderTopLeft, {
		header = header,
		scaleFactor = scaleFactor,
	})
	if _child_1 then
		if _child_1.elements ~= nil or _child_1.props ~= nil and _child_1.component ~= nil then
			_children[_length + 1] = _child_1
		else
			for _k, _v in ipairs(_child_1) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	local _child_2 = body ~= nil and (Roact.createElement("TextLabel", {
		Text = body,
		TextColor3 = hex("#FFFFFF"),
		Font = "GothamBlack",
		TextSize = 36,
		TextXAlignment = "Left",
		TextYAlignment = "Top",
		Size = scale(1, 70 / 416),
		Position = scaleFactor:map(function(s)
			return px(0, 110 * s)
		end),
		BackgroundTransparency = 1,
	}, {
		Roact.createElement("UIScale", {
			Scale = scaleFactor,
		}),
	}))
	if _child_2 then
		if _child_2.elements ~= nil or _child_2.props ~= nil and _child_2.component ~= nil then
			_children[_length + 1] = _child_2
		else
			for _k, _v in ipairs(_child_2) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children[_length + 1] = Roact.createElement("TextLabel", {
		Text = footer,
		TextColor3 = hex("#FFFFFF"),
		Font = "GothamBlack",
		TextSize = 18,
		TextXAlignment = "Center",
		TextYAlignment = "Bottom",
		AnchorPoint = Vector2.new(0.5, 1),
		Size = scale(1, 20 / 416),
		Position = scale(0.5, 1),
		BackgroundTransparency = 1,
	}, {
		Roact.createElement("UIScale", {
			Scale = scaleFactor,
		}),
	})
	return Roact.createElement(Canvas, _attributes, _children)
end
function HeaderTopLeft(props)
	return Roact.createElement("TextLabel", {
		Text = props.header,
		TextColor3 = hex("#FFFFFF"),
		Font = "GothamBlack",
		TextSize = 64,
		TextXAlignment = "Left",
		TextYAlignment = "Top",
		Size = scale(1, 70 / 416),
		BackgroundTransparency = 1,
	}, {
		Roact.createElement("UIScale", {
			Scale = props.scaleFactor,
		}),
	})
end
function HeaderCenter(props)
	return Roact.createElement("TextLabel", {
		Text = props.header,
		TextColor3 = hex("#FFFFFF"),
		Font = "GothamBlack",
		TextSize = 48,
		TextXAlignment = "Center",
		TextYAlignment = "Center",
		AnchorPoint = Vector2.new(0.5, 0.5),
		Size = scale(1, 1),
		Position = scale(0.5, 0.5),
		BackgroundTransparency = 1,
	}, {
		Roact.createElement("UIScale", {
			Scale = props.scaleFactor,
		}),
	})
end
local default = hooked(Content)
return {
	default = default,
}
 end,Properties={Name="Content"},Reference=148,ClassName="ModuleScript"}}},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Apps").default
return exports
 end,Properties={Name="Apps"},Reference=109,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local pure = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).pure
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useScale = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "use-scale").useScale
local scale = TS.import(script, script.Parent.Parent.Parent.Parent, "utils", "udim2").scale
local Players = TS.import(script, script.Parent, "Players").default
local function Apps()
	local scaleFactor = useScale()
	return Roact.createElement(Canvas, {
		position = scale(0, 1),
		anchor = Vector2.new(0, 1),
	}, {
		Roact.createElement("UIScale", {
			Scale = scaleFactor,
		}),
		Roact.createElement(Players),
	})
end
local default = pure(Apps)
return {
	default = default,
}
 end,Properties={Name="Apps"},Reference=110,ClassName="ModuleScript"},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Players").default
return exports
 end,Properties={Name="Players"},Reference=111,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local Border = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Border").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useAppSelector = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "rodux-hooks").useAppSelector
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local px = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2").px
local function Avatar()
	local theme = useTheme("apps").players
	local playerSelected = useAppSelector(function(state)
		local _result
		if state.dashboard.apps.playerSelected ~= nil then
			_result = (Players:FindFirstChild(state.dashboard.apps.playerSelected))
		else
			_result = nil
		end
		return _result
	end)
	return Roact.createElement(Canvas, {
		anchor = Vector2.new(0.5, 0),
		size = px(186, 186),
		position = UDim2.new(0.5, 0, 0, 24),
	}, {
		Roact.createElement("ImageLabel", {
			Image = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. (tostring(playerSelected and playerSelected.UserId or Players.LocalPlayer.UserId) .. "&width=150&height=150&format=png"),
			Size = px(150, 150),
			Position = px(18, 18),
			BackgroundColor3 = theme.avatar.background,
			BackgroundTransparency = theme.avatar.transparency,
		}, {
			Roact.createElement("UICorner", {
				CornerRadius = UDim.new(1, 0),
			}),
		}),
		Roact.createElement(Border, {
			size = 4,
			radius = "circular",
		}, {
			Roact.createElement("UIGradient", {
				Color = theme.avatar.gradient.color,
				Transparency = theme.avatar.gradient.transparency,
				Rotation = theme.avatar.gradient.rotation,
			}),
		}),
	})
end
local default = hooked(Avatar)
return {
	default = default,
}
 end,Properties={Name="Avatar"},Reference=113,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useEffect = _roact_hooked.useEffect
local useMemo = _roact_hooked.useMemo
local useState = _roact_hooked.useState
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local TextService = _services.TextService
local Border = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Border").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Fill = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Fill").default
local _Glow = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Glow")
local Glow = _Glow.default
local GlowRadius = _Glow.GlowRadius
local IS_DEV = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "constants").IS_DEV
local useLinear = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "flipper-hooks").useLinear
local _rodux_hooks = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "rodux-hooks")
local useAppDispatch = _rodux_hooks.useAppDispatch
local useAppSelector = _rodux_hooks.useAppSelector
local useDelayedUpdate = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useIsPageOpen = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-current-page").useIsPageOpen
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local _dashboard_action = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "dashboard.action")
local playerDeselected = _dashboard_action.playerDeselected
local playerSelected = _dashboard_action.playerSelected
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local arrayToMap = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "array-util").arrayToMap
local lerp = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "number-util").lerp
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local PADDING = 20
local ENTRY_HEIGHT = 60
local ENTRY_WIDTH = 326 - 24 * 2
local ENTRY_TEXT_PADDING = 60
local textFadeSequence = NumberSequence.new({ NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.05, 0), NumberSequenceKeypoint.new(0.9, 0), NumberSequenceKeypoint.new(0.95, 1), NumberSequenceKeypoint.new(1, 1) })
local function usePlayers()
	local _binding = useState(Players:GetPlayers())
	local players = _binding[1]
	local setPlayers = _binding[2]
	useEffect(function()
		local addedHandle = Players.PlayerAdded:Connect(function()
			setPlayers(Players:GetPlayers())
		end)
		local removingHandle = Players.PlayerRemoving:Connect(function()
			setPlayers(Players:GetPlayers())
		end)
		return function()
			addedHandle:Disconnect()
			removingHandle:Disconnect()
		end
	end, {})
	return players
end
local PlayerEntry
local function Selection()
	local dispatch = useAppDispatch()
	local players = usePlayers()
	local playerSelected = useAppSelector(function(state)
		return state.dashboard.apps.playerSelected
	end)
	local sortedPlayers = useMemo(function()
		local _arg0 = function(p)
			return p.Name == playerSelected
		end
		-- \226\150\188 ReadonlyArray.find \226\150\188
		local _result = nil
		for _i, _v in ipairs(players) do
			if _arg0(_v, _i - 1, players) == true then
				_result = _v
				break
			end
		end
		-- \226\150\178 ReadonlyArray.find \226\150\178
		local selected = _result
		local _arg0_1 = function(p)
			return p.Name ~= playerSelected and (p ~= Players.LocalPlayer or IS_DEV)
		end
		-- \226\150\188 ReadonlyArray.filter \226\150\188
		local _newValue = {}
		local _length = 0
		for _k, _v in ipairs(players) do
			if _arg0_1(_v, _k - 1, players) == true then
				_length += 1
				_newValue[_length] = _v
			end
		end
		-- \226\150\178 ReadonlyArray.filter \226\150\178
		local _arg0_2 = function(a, b)
			return string.lower(a.Name) < string.lower(b.Name)
		end
		-- \226\150\188 Array.sort \226\150\188
		table.sort(_newValue, _arg0_2)
		-- \226\150\178 Array.sort \226\150\178
		local sorted = _newValue
		local _result_1
		if selected then
			local _array = { selected }
			local _length_1 = #_array
			table.move(sorted, 1, #sorted, _length_1 + 1, _array)
			_result_1 = _array
		else
			_result_1 = sorted
		end
		return _result_1
	end, { players, playerSelected })
	useEffect(function()
		local _condition = playerSelected ~= nil
		if _condition then
			local _arg0 = function(player)
				return player.Name == playerSelected
			end
			-- \226\150\188 ReadonlyArray.find \226\150\188
			local _result = nil
			for _i, _v in ipairs(sortedPlayers) do
				if _arg0(_v, _i - 1, sortedPlayers) == true then
					_result = _v
					break
				end
			end
			-- \226\150\178 ReadonlyArray.find \226\150\178
			_condition = not _result
		end
		if _condition then
			dispatch(playerDeselected())
		end
	end, { players, playerSelected })
	local _attributes = {
		size = px(326, 280),
		position = px(0, 368),
		padding = {
			left = 24,
			right = 24,
			top = 8,
		},
		clipsDescendants = true,
	}
	local _children = {}
	local _length = #_children
	local _attributes_1 = {
		Size = scale(1, 1),
		CanvasSize = px(0, #sortedPlayers * (ENTRY_HEIGHT + PADDING) + PADDING),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		ScrollBarImageTransparency = 1,
		ScrollBarThickness = 0,
		ClipsDescendants = false,
	}
	local _children_1 = {}
	local _length_1 = #_children_1
	for _k, _v in pairs(arrayToMap(sortedPlayers, function(player, index)
		return { player.Name, Roact.createElement(PlayerEntry, {
			name = player.Name,
			displayName = player.DisplayName,
			userId = player.UserId,
			index = index,
		}) }
	end)) do
		_children_1[_k] = _v
	end
	_children[_length + 1] = Roact.createElement("ScrollingFrame", _attributes_1, _children_1)
	return Roact.createElement(Canvas, _attributes, _children)
end
local default = hooked(Selection)
local function PlayerEntryComponent(_param)
	local name = _param.name
	local userId = _param.userId
	local displayName = _param.displayName
	local index = _param.index
	local dispatch = useAppDispatch()
	local theme = useTheme("apps").players.playerButton
	local isOpen = useIsPageOpen(DashboardPage.Apps)
	local isVisible = useDelayedUpdate(isOpen, isOpen and 170 + index * 40 or 150)
	local isSelected = useAppSelector(function(state)
		return state.dashboard.apps.playerSelected == name
	end)
	local _binding = useState(false)
	local hovered = _binding[1]
	local setHovered = _binding[2]
	local text = "  " .. (displayName .. (" (@" .. (name .. ")")))
	local textSize = useMemo(function()
		return TextService:GetTextSize(text, 14, Enum.Font.GothamBold, Vector2.new(1000, ENTRY_HEIGHT))
	end, { text })
	local textScrollOffset = useLinear(hovered and ENTRY_WIDTH - ENTRY_TEXT_PADDING - 20 - textSize.X or 0, {
		velocity = hovered and 40 or 150,
	}):map(function(x)
		return UDim.new(0, math.min(x, 0))
	end)
	local _result
	if isSelected then
		_result = theme.accent
	else
		local _result_1
		if hovered then
			local _condition = theme.backgroundHovered
			if _condition == nil then
				_condition = theme.background:Lerp(theme.accent, 0.1)
			end
			_result_1 = _condition
		else
			_result_1 = theme.background
		end
		_result = _result_1
	end
	local background = useSpring(_result, {})
	local _result_1
	if isSelected then
		_result_1 = theme.accent
	else
		local _result_2
		if hovered then
			local _condition = theme.backgroundHovered
			if _condition == nil then
				_condition = theme.dropshadow:Lerp(theme.accent, 0.5)
			end
			_result_2 = _condition
		else
			_result_2 = theme.dropshadow
		end
		_result_1 = _result_2
	end
	local dropshadow = useSpring(_result_1, {})
	local foreground = useSpring(isSelected and theme.foregroundAccent and theme.foregroundAccent or theme.foreground, {})
	local _attributes = {
		size = px(ENTRY_WIDTH, ENTRY_HEIGHT),
		position = useSpring(isVisible and px(0, (PADDING + ENTRY_HEIGHT) * index) or px(-ENTRY_WIDTH - 24, (PADDING + ENTRY_HEIGHT) * index), {}),
		zIndex = index,
	}
	local _children = {
		Roact.createElement(Glow, {
			radius = GlowRadius.Size70,
			color = dropshadow,
			size = UDim2.new(1, 36, 1, 36),
			position = px(-18, 5 - 18),
			transparency = useSpring(isSelected and theme.glowTransparency or (hovered and lerp(theme.dropshadowTransparency, theme.glowTransparency, 0.5) or theme.dropshadowTransparency), {}),
		}),
		Roact.createElement(Fill, {
			color = background,
			transparency = useSpring(theme.backgroundTransparency, {}),
			radius = 8,
		}),
		Roact.createElement("TextLabel", {
			Text = text,
			Font = "GothamBold",
			TextSize = 14,
			TextColor3 = foreground,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextYAlignment = Enum.TextYAlignment.Center,
			TextTransparency = useSpring(isSelected and 0 or (hovered and theme.foregroundTransparency / 2 or theme.foregroundTransparency), {}),
			BackgroundTransparency = 1,
			Position = px(ENTRY_TEXT_PADDING, 1),
			Size = UDim2.new(1, -ENTRY_TEXT_PADDING, 1, -1),
			ClipsDescendants = true,
		}, {
			Roact.createElement("UIPadding", {
				PaddingLeft = textScrollOffset,
			}),
			Roact.createElement("UIGradient", {
				Transparency = textFadeSequence,
			}),
		}),
		Roact.createElement("ImageLabel", {
			Image = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. (tostring(userId) .. "&width=60&height=60&format=png"),
			Size = UDim2.new(0, ENTRY_HEIGHT, 0, ENTRY_HEIGHT),
			BackgroundTransparency = 1,
		}, {
			Roact.createElement("UICorner", {
				CornerRadius = UDim.new(0, 8),
			}),
		}),
	}
	local _length = #_children
	local _child = theme.outlined and Roact.createElement(Border, {
		color = foreground,
		transparency = 0.8,
		radius = 8,
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children[_length + 1] = Roact.createElement("TextButton", {
		[Roact.Event.Activated] = function()
			local player = Players:FindFirstChild(name)
			local _condition = not isSelected
			if _condition then
				local _result_2 = player
				if _result_2 ~= nil then
					_result_2 = _result_2:IsA("Player")
				end
				_condition = _result_2
			end
			if _condition then
				dispatch(playerSelected(player))
			else
				dispatch(playerDeselected())
			end
		end,
		[Roact.Event.MouseEnter] = function()
			return setHovered(true)
		end,
		[Roact.Event.MouseLeave] = function()
			return setHovered(false)
		end,
		Text = "",
		Transparency = 1,
		Size = scale(1, 1),
	})
	return Roact.createElement(Canvas, _attributes, _children)
end
PlayerEntry = hooked(PlayerEntryComponent)
return {
	default = default,
}
 end,Properties={Name="Selection"},Reference=115,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Card = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Card").default
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local px = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2").px
local Actions = TS.import(script, script.Parent, "Actions").default
local Avatar = TS.import(script, script.Parent, "Avatar").default
local Selection = TS.import(script, script.Parent, "Selection").default
local Username = TS.import(script, script.Parent, "Username").default
local function Players()
	local theme = useTheme("apps").players
	return Roact.createElement(Card, {
		index = 1,
		page = DashboardPage.Apps,
		theme = theme,
		size = px(326, 648),
		position = UDim2.new(0, 0, 1, 0),
	}, {
		Roact.createElement(Avatar),
		Roact.createElement(Username),
		Roact.createElement(Actions),
		Roact.createElement(Selection),
	})
end
local default = hooked(Players)
return {
	default = default,
}
 end,Properties={Name="Players"},Reference=114,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useAppSelector = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "rodux-hooks").useAppSelector
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local function Username()
	local theme = useTheme("apps").players
	local playerSelected = useAppSelector(function(state)
		local _result
		if state.dashboard.apps.playerSelected ~= nil then
			_result = (Players:FindFirstChild(state.dashboard.apps.playerSelected))
		else
			_result = nil
		end
		return _result
	end)
	return Roact.createElement(Canvas, {
		anchor = Vector2.new(0.5, 0),
		size = px(278, 49),
		position = UDim2.new(0.5, 0, 0, 231),
	}, {
		Roact.createElement("TextLabel", {
			Font = "GothamBlack",
			Text = playerSelected and playerSelected.DisplayName or "N/A",
			TextSize = 20,
			TextColor3 = theme.foreground,
			TextXAlignment = "Center",
			TextYAlignment = "Top",
			Size = scale(1, 1),
			BackgroundTransparency = 1,
		}),
		Roact.createElement("TextLabel", {
			Font = "GothamBold",
			Text = playerSelected and playerSelected.Name or "Select a player",
			TextSize = 16,
			TextColor3 = theme.foreground,
			TextXAlignment = "Center",
			TextYAlignment = "Bottom",
			TextTransparency = 0.7,
			Size = scale(1, 1),
			BackgroundTransparency = 1,
		}),
	})
end
local default = hooked(Username)
return {
	default = default,
}
 end,Properties={Name="Username"},Reference=116,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local ActionButton = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "ActionButton").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local px = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2").px
local function Actions()
	local theme = useTheme("apps").players
	return Roact.createElement(Canvas, {
		anchor = Vector2.new(0.5, 0),
		size = px(278, 49),
		position = UDim2.new(0.5, 0, 0, 304),
	}, {
		Roact.createElement(ActionButton, {
			action = "teleport",
			hint = "<font face='GothamBlack'>Teleport to</font> this player, tap again to cancel",
			theme = theme,
			image = "rbxassetid://8992042585",
			position = px(0, 0),
			canDeactivate = true,
		}),
		Roact.createElement(ActionButton, {
			action = "hide",
			hint = "<font face='GothamBlack'>Hide</font> this player's character; persists between players",
			theme = theme,
			image = "rbxassetid://8992042653",
			position = px(72, 0),
			canDeactivate = true,
		}),
		Roact.createElement(ActionButton, {
			action = "kill",
			hint = "<font face='GothamBlack'>Kill</font> this player with a tool handle",
			theme = theme,
			image = "rbxassetid://8992042471",
			position = px(145, 0),
		}),
		Roact.createElement(ActionButton, {
			action = "spectate",
			hint = "<font face='GothamBlack'>Spectate</font> this player",
			theme = theme,
			image = "rbxassetid://8992042721",
			position = px(217, 0),
			canDeactivate = true,
		}),
	})
end
local default = hooked(Actions)
return {
	default = default,
}
 end,Properties={Name="Actions"},Reference=112,ClassName="ModuleScript"}}}}},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Home").default
return exports
 end,Properties={Name="Home"},Reference=117,Children={{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Server").default
return exports
 end,Properties={Name="Server"},Reference=130,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useState = _roact_hooked.useState
local BrightButton = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "BrightButton").default
local _rodux_hooks = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "rodux-hooks")
local useAppDispatch = _rodux_hooks.useAppDispatch
local useAppSelector = _rodux_hooks.useAppSelector
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local _dashboard_action = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "dashboard.action")
local clearHint = _dashboard_action.clearHint
local setHint = _dashboard_action.setHint
local setJobActive = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "jobs.action").setJobActive
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local function ServerAction(_param)
	local action = _param.action
	local hint = _param.hint
	local icon = _param.icon
	local size = _param.size
	local position = _param.position
	local dispatch = useAppDispatch()
	local theme = useTheme("home").server[action == "switchServer" and "switchButton" or "rejoinButton"]
	local active = useAppSelector(function(state)
		return state.jobs[action].active
	end)
	local _binding = useState(false)
	local hovered = _binding[1]
	local setHovered = _binding[2]
	local _result
	if active then
		_result = theme.accent
	else
		local _result_1
		if hovered then
			local _condition = theme.backgroundHovered
			if _condition == nil then
				_condition = theme.background:Lerp(theme.accent, 0.1)
			end
			_result_1 = _condition
		else
			_result_1 = theme.background
		end
		_result = _result_1
	end
	local background = useSpring(_result, {})
	local foreground = useSpring(active and theme.foregroundAccent and theme.foregroundAccent or theme.foreground, {})
	return Roact.createElement(BrightButton, {
		onActivate = function()
			return dispatch(setJobActive(action, not active))
		end,
		onHover = function(hovered)
			if hovered then
				setHovered(true)
				dispatch(setHint(hint))
			else
				setHovered(false)
				dispatch(clearHint())
			end
		end,
		size = size,
		position = position,
		radius = 8,
		color = background,
		borderEnabled = theme.outlined,
		borderColor = foreground,
		transparency = theme.backgroundTransparency,
	}, {
		Roact.createElement("ImageLabel", {
			Image = icon,
			ImageColor3 = foreground,
			ImageTransparency = useSpring(active and 0 or (hovered and theme.foregroundTransparency - 0.25 or theme.foregroundTransparency), {}),
			AnchorPoint = Vector2.new(0.5, 0.5),
			Size = px(36, 36),
			Position = scale(0.5, 0.5),
			BackgroundTransparency = 1,
		}),
	})
end
local default = hooked(ServerAction)
return {
	default = default,
}
 end,Properties={Name="ServerAction"},Reference=132,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local Card = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Card").default
local IS_DEV = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "constants").IS_DEV
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local px = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2").px
local ServerAction = TS.import(script, script.Parent, "ServerAction").default
local StatusLabel = TS.import(script, script.Parent, "StatusLabel").default
local function Server()
	local theme = useTheme("home").server
	return Roact.createElement(Card, {
		index = 2,
		page = DashboardPage.Home,
		theme = theme,
		size = px(326, 184),
		position = UDim2.new(0, 374, 1, -416 - 48),
	}, {
		Roact.createElement("TextLabel", {
			Text = "Server",
			Font = "GothamBlack",
			TextSize = 20,
			TextColor3 = theme.foreground,
			TextXAlignment = "Left",
			TextYAlignment = "Top",
			Position = px(24, 24),
			BackgroundTransparency = 1,
		}),
		Roact.createElement(StatusLabel, {
			index = 0,
			offset = 69,
			units = "players",
			getValue = function()
				return tostring(#Players:GetPlayers()) .. (" / " .. tostring(Players.MaxPlayers))
			end,
		}),
		Roact.createElement(StatusLabel, {
			index = 1,
			offset = 108,
			units = "elapsed",
			getValue = function()
				local uptime = IS_DEV and os.clock() or time()
				local days = math.floor(uptime / 86400)
				local hours = math.floor((uptime - days * 86400) / 3600)
				local minutes = math.floor((uptime - days * 86400 - hours * 3600) / 60)
				local seconds = math.floor(uptime - days * 86400 - hours * 3600 - minutes * 60)
				return days > 0 and tostring(days) .. " days" or (hours > 0 and tostring(hours) .. " hours" or (minutes > 0 and tostring(minutes) .. " minutes" or tostring(seconds) .. " seconds"))
			end,
		}),
		Roact.createElement(StatusLabel, {
			index = 2,
			offset = 147,
			units = "ping",
			getValue = function()
				return tostring(math.round(Players.LocalPlayer:GetNetworkPing() * 1000)) .. " ms"
			end,
		}),
		Roact.createElement(ServerAction, {
			action = "switchServer",
			hint = "<font face='GothamBlack'>Switch</font> to a different server",
			icon = "rbxassetid://8992259774",
			size = px(66, 50),
			position = UDim2.new(1, -66 - 24, 1, -100 - 16 - 12),
		}),
		Roact.createElement(ServerAction, {
			action = "rejoinServer",
			hint = "<font face='GothamBlack'>Rejoin</font> this server",
			icon = "rbxassetid://8992259894",
			size = px(66, 50),
			position = UDim2.new(1, -66 - 24, 1, -50 - 16),
		}),
	})
end
local default = hooked(Server)
return {
	default = default,
}
 end,Properties={Name="Server"},Reference=131,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useMemo = _roact_hooked.useMemo
local useState = _roact_hooked.useState
local TextService = TS.import(script, TS.getModule(script, "@rbxts", "services")).TextService
local useDelayedUpdate = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useInterval = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-interval").useInterval
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useIsPageOpen = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-current-page").useIsPageOpen
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local px = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2").px
local function StatusLabel(_param)
	local offset = _param.offset
	local index = _param.index
	local units = _param.units
	local getValue = _param.getValue
	local theme = useTheme("home").server
	local _binding = useState(getValue)
	local value = _binding[1]
	local setValue = _binding[2]
	local isOpen = useIsPageOpen(DashboardPage.Home)
	local isVisible = useDelayedUpdate(isOpen, isOpen and 330 + index * 100 or 300)
	local valueLength = useMemo(function()
		return TextService:GetTextSize(value .. " ", 16, "GothamBold", Vector2.new()).X
	end, { value })
	useInterval(function()
		setValue(getValue())
	end, 1000)
	return Roact.createFragment({
		Roact.createElement("TextLabel", {
			Text = value,
			RichText = true,
			Font = "GothamBold",
			TextSize = 16,
			TextColor3 = theme.foreground,
			TextTransparency = useSpring(isVisible and 0 or 1, {
				frequency = 2,
			}),
			TextXAlignment = "Left",
			TextYAlignment = "Top",
			Position = useSpring(isVisible and px(24, offset) or px(0, offset), {}),
			BackgroundTransparency = 1,
		}),
		Roact.createElement("TextLabel", {
			Text = units,
			RichText = true,
			Font = "GothamBold",
			TextSize = 16,
			TextColor3 = theme.foreground,
			TextTransparency = useSpring(isVisible and 0.4 or 1, {}),
			TextXAlignment = "Left",
			TextYAlignment = "Top",
			Position = useSpring(isVisible and px(24 + valueLength, offset) or px(0 + valueLength, offset), {}),
			BackgroundTransparency = 1,
		}),
	})
end
local default = hooked(StatusLabel)
return {
	default = default,
}
 end,Properties={Name="StatusLabel"},Reference=133,ClassName="ModuleScript"}}},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Profile").default
return exports
 end,Properties={Name="Profile"},Reference=123,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Card = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Card").default
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local px = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2").px
local Actions = TS.import(script, script.Parent, "Actions").default
local Avatar = TS.import(script, script.Parent, "Avatar").default
local Info = TS.import(script, script.Parent, "Info").default
local Sliders = TS.import(script, script.Parent, "Sliders").default
local Username = TS.import(script, script.Parent, "Username").default
local function Profile()
	local theme = useTheme("home").profile
	return Roact.createElement(Card, {
		index = 1,
		page = DashboardPage.Home,
		theme = theme,
		size = px(326, 648),
		position = UDim2.new(0, 0, 1, 0),
	}, {
		Roact.createElement(Canvas, {
			padding = {
				left = 24,
				right = 24,
			},
		}, {
			Roact.createElement(Avatar),
			Roact.createElement(Username),
			Roact.createElement(Info),
			Roact.createElement(Sliders),
			Roact.createElement(Actions),
		}),
	})
end
local default = hooked(Profile)
return {
	default = default,
}
 end,Properties={Name="Profile"},Reference=127,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local ActionButton = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "ActionButton").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local px = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2").px
local function Actions()
	local theme = useTheme("home").profile
	return Roact.createElement(Canvas, {
		anchor = Vector2.new(0.5, 0),
		size = px(278, 49),
		position = UDim2.new(0.5, 0, 0, 575),
	}, {
		Roact.createElement(ActionButton, {
			action = "refresh",
			hint = "<font face='GothamBlack'>Refresh</font> your character at this location",
			theme = theme,
			image = "rbxassetid://8992253511",
			position = px(0, 0),
		}),
		Roact.createElement(ActionButton, {
			action = "ghost",
			hint = "<font face='GothamBlack'>Spawn a ghost</font> and go to it when disabled",
			theme = theme,
			image = "rbxassetid://8992253792",
			position = px(72, 0),
			canDeactivate = true,
		}),
		Roact.createElement(ActionButton, {
			action = "godmode",
			hint = "<font face='GothamBlack'>Set godmode</font>, may break respawn",
			theme = theme,
			image = "rbxassetid://8992253678",
			position = px(145, 0),
		}),
		Roact.createElement(ActionButton, {
			action = "freecam",
			hint = "<font face='GothamBlack'>Set freecam</font>, use Q & E to move vertically",
			theme = theme,
			image = "rbxassetid://8992253933",
			position = px(217, 0),
			canDeactivate = true,
		}),
	})
end
local default = hooked(Actions)
return {
	default = default,
}
 end,Properties={Name="Actions"},Reference=124,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local Border = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Border").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local px = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2").px
local AVATAR = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. (tostring(Players.LocalPlayer.UserId) .. "&width=150&height=150&format=png")
local function Avatar()
	local theme = useTheme("home").profile
	return Roact.createElement(Canvas, {
		anchor = Vector2.new(0.5, 0),
		size = px(186, 186),
		position = UDim2.new(0.5, 0, 0, 24),
	}, {
		Roact.createElement("ImageLabel", {
			Image = AVATAR,
			Size = px(150, 150),
			Position = px(18, 18),
			BackgroundColor3 = theme.avatar.background,
			BackgroundTransparency = theme.avatar.transparency,
		}, {
			Roact.createElement("UICorner", {
				CornerRadius = UDim.new(1, 0),
			}),
		}),
		Roact.createElement(Border, {
			size = 4,
			radius = "circular",
		}, {
			Roact.createElement("UIGradient", {
				Color = theme.avatar.gradient.color,
				Transparency = theme.avatar.gradient.transparency,
				Rotation = theme.avatar.gradient.rotation,
			}),
		}),
	})
end
local default = hooked(Avatar)
return {
	default = default,
}
 end,Properties={Name="Avatar"},Reference=125,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local function Username()
	local theme = useTheme("home").profile
	return Roact.createElement(Canvas, {
		anchor = Vector2.new(0.5, 0),
		size = px(278, 49),
		position = UDim2.new(0.5, 0, 0, 231),
	}, {
		Roact.createElement("TextLabel", {
			Font = "GothamBlack",
			Text = Players.LocalPlayer.DisplayName,
			TextSize = 20,
			TextColor3 = theme.foreground,
			TextXAlignment = "Center",
			TextYAlignment = "Top",
			Size = scale(1, 1),
			BackgroundTransparency = 1,
		}),
		Roact.createElement("TextLabel", {
			Font = "GothamBold",
			Text = Players.LocalPlayer.Name,
			TextSize = 16,
			TextColor3 = theme.foreground,
			TextXAlignment = "Center",
			TextYAlignment = "Bottom",
			TextTransparency = 0.7,
			Size = scale(1, 1),
			BackgroundTransparency = 1,
		}),
	})
end
local default = hooked(Username)
return {
	default = default,
}
 end,Properties={Name="Username"},Reference=129,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useBinding = _roact_hooked.useBinding
local useState = _roact_hooked.useState
local BrightButton = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "BrightButton").default
local BrightSlider = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "BrightSlider").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local _rodux_hooks = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "rodux-hooks")
local useAppDispatch = _rodux_hooks.useAppDispatch
local useAppSelector = _rodux_hooks.useAppSelector
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local _dashboard_action = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "dashboard.action")
local clearHint = _dashboard_action.clearHint
local setHint = _dashboard_action.setHint
local _jobs_action = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "actions", "jobs.action")
local setJobActive = _jobs_action.setJobActive
local setJobValue = _jobs_action.setJobValue
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local SPRING_OPTIONS = {
	frequency = 5,
}
local Slider
local function Sliders()
	return Roact.createElement(Canvas, {
		size = px(278, 187),
		position = px(0, 368),
	}, {
		Roact.createElement(Slider, {
			display = "Flight",
			hint = "<font face='GothamBlack'>Configure flight</font> in studs per second",
			jobName = "flight",
			units = "studs/s",
			min = 10,
			max = 100,
			position = 0,
		}),
		Roact.createElement(Slider, {
			display = "Speed",
			hint = "<font face='GothamBlack'>Configure speed</font> in studs per second",
			jobName = "walkSpeed",
			units = "studs/s",
			min = 0,
			max = 100,
			position = 69,
		}),
		Roact.createElement(Slider, {
			display = "Jump",
			hint = "<font face='GothamBlack'>Configure height</font> in studs",
			jobName = "jumpHeight",
			units = "studs",
			min = 0,
			max = 500,
			position = 138,
		}),
	})
end
local default = Sliders
local function SliderComponent(props)
	local theme = useTheme("home").profile
	local dispatch = useAppDispatch()
	local job = useAppSelector(function(state)
		return state.jobs[props.jobName]
	end)
	local _binding = useBinding(job.value)
	local value = _binding[1]
	local setValue = _binding[2]
	local _binding_1 = useState(false)
	local hovered = _binding_1[1]
	local setHovered = _binding_1[2]
	local accent = theme.highlight[props.jobName]
	local _result
	if job.active then
		_result = accent
	else
		local _result_1
		if hovered then
			local _condition = theme.button.backgroundHovered
			if _condition == nil then
				_condition = theme.button.background:Lerp(accent, 0.1)
			end
			_result_1 = _condition
		else
			_result_1 = theme.button.background
		end
		_result = _result_1
	end
	local buttonBackground = useSpring(_result, {})
	local buttonForeground = useSpring(job.active and theme.button.foregroundAccent and theme.button.foregroundAccent or theme.foreground, {})
	return Roact.createElement(Canvas, {
		size = px(278, 49),
		position = px(0, props.position),
	}, {
		Roact.createElement(BrightSlider, {
			onValueChanged = setValue,
			onRelease = function()
				return dispatch(setJobValue(props.jobName, math.round(value:getValue())))
			end,
			min = props.min,
			max = props.max,
			initialValue = job.value,
			size = px(181, 49),
			position = px(0, 0),
			radius = 8,
			color = theme.slider.background,
			accentColor = accent,
			borderEnabled = theme.slider.outlined,
			borderColor = theme.slider.foreground,
			transparency = theme.slider.backgroundTransparency,
			indicatorTransparency = theme.slider.indicatorTransparency,
		}, {
			Roact.createElement("TextLabel", {
				Font = "GothamBold",
				Text = value:map(function(value)
					return tostring(math.round(value)) .. (" " .. props.units)
				end),
				TextSize = 15,
				TextColor3 = theme.slider.foreground,
				TextXAlignment = "Center",
				TextYAlignment = "Center",
				TextTransparency = theme.slider.foregroundTransparency,
				Size = scale(1, 1),
				BackgroundTransparency = 1,
			}),
		}),
		Roact.createElement(BrightButton, {
			onActivate = function()
				return dispatch(setJobActive(props.jobName, not job.active))
			end,
			onHover = function(hovered)
				if hovered then
					setHovered(true)
					dispatch(setHint(props.hint))
				else
					setHovered(false)
					dispatch(clearHint())
				end
			end,
			size = px(85, 49),
			position = px(193, 0),
			radius = 8,
			color = buttonBackground,
			borderEnabled = theme.button.outlined,
			borderColor = buttonForeground,
			transparency = theme.button.backgroundTransparency,
		}, {
			Roact.createElement("TextLabel", {
				Font = "GothamBold",
				Text = props.display,
				TextSize = 15,
				TextColor3 = buttonForeground,
				TextXAlignment = "Center",
				TextYAlignment = "Center",
				TextTransparency = useSpring(job.active and 0 or (hovered and theme.button.foregroundTransparency - 0.25 or theme.button.foregroundTransparency), {}),
				Size = scale(1, 1),
				BackgroundTransparency = 1,
			}),
		}),
	})
end
Slider = hooked(SliderComponent)
return {
	default = default,
}
 end,Properties={Name="Sliders"},Reference=128,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useDelayedUpdate = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useIsPageOpen = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-current-page").useIsPageOpen
local useFriends = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-friends").useFriends
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local px = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2").px
local function Info()
	local theme = useTheme("home").profile
	local isOpen = useIsPageOpen(DashboardPage.Home)
	local _binding = useFriends()
	local friends = _binding[1]
	if friends == nil then
		friends = {}
	end
	local status = _binding[3]
	local friendsOnline = #friends
	local _arg0 = function(friend)
		return friend.PlaceId ~= nil and friend.PlaceId == game.PlaceId
	end
	-- \226\150\188 ReadonlyArray.filter \226\150\188
	local _newValue = {}
	local _length = 0
	for _k, _v in ipairs(friends) do
		if _arg0(_v, _k - 1, friends) == true then
			_length += 1
			_newValue[_length] = _v
		end
	end
	-- \226\150\178 ReadonlyArray.filter \226\150\178
	local friendsJoined = #_newValue
	local showJoinDate = useDelayedUpdate(isOpen, 400, function(open)
		return not open
	end)
	local showFriendsJoined = useDelayedUpdate(isOpen and status ~= "pending", 500, function(open)
		return not open
	end)
	local showFriendsOnline = useDelayedUpdate(isOpen and status ~= "pending", 600, function(open)
		return not open
	end)
	return Roact.createElement(Canvas, {
		anchor = Vector2.new(0.5, 0),
		size = px(278, 48),
		position = UDim2.new(0.5, 0, 0, 300),
	}, {
		Roact.createElement("Frame", {
			Size = px(0, 26),
			Position = px(90, 11),
			BackgroundTransparency = 1,
		}, {
			Roact.createElement("UIStroke", {
				Thickness = 0.5,
				Color = theme.foreground,
				Transparency = 0.7,
			}),
		}),
		Roact.createElement("Frame", {
			Size = px(0, 26),
			Position = px(187, 11),
			BackgroundTransparency = 1,
		}, {
			Roact.createElement("UIStroke", {
				Thickness = 0.5,
				Color = theme.foreground,
				Transparency = 0.7,
			}),
		}),
		Roact.createElement("TextLabel", {
			Font = "GothamBold",
			Text = "Joined\n" .. tostring((os.date("%m/%d/%Y", os.time() - Players.LocalPlayer.AccountAge * 24 * 60 * 60))),
			TextSize = 13,
			TextColor3 = theme.foreground,
			TextXAlignment = "Center",
			TextYAlignment = "Center",
			TextTransparency = useSpring(showJoinDate and 0.2 or 1, {}),
			Size = px(85, 48),
			Position = useSpring(showJoinDate and px(0, 0) or px(-20, 0), {}),
			BackgroundTransparency = 1,
		}),
		Roact.createElement("TextLabel", {
			Font = "GothamBold",
			Text = friendsJoined == 1 and "1 friend\njoined" or tostring(friendsJoined) .. " friends\njoined",
			TextSize = 13,
			TextColor3 = theme.foreground,
			TextXAlignment = "Center",
			TextYAlignment = "Center",
			TextTransparency = useSpring(showFriendsJoined and 0.2 or 1, {}),
			Size = px(85, 48),
			Position = useSpring(showFriendsJoined and px(97, 0) or px(97 - 20, 0), {}),
			BackgroundTransparency = 1,
		}),
		Roact.createElement("TextLabel", {
			Font = "GothamBold",
			Text = friendsOnline == 1 and "1 friend\nonline" or tostring(friendsOnline) .. " friends\nonline",
			TextSize = 13,
			TextColor3 = theme.foreground,
			TextXAlignment = "Center",
			TextYAlignment = "Center",
			TextTransparency = useSpring(showFriendsOnline and 0.2 or 1, {}),
			Size = px(85, 48),
			Position = useSpring(showFriendsOnline and px(193, 0) or px(193 - 20, 0), {}),
			BackgroundTransparency = 1,
		}),
	})
end
local default = hooked(Info)
return {
	default = default,
}
 end,Properties={Name="Info"},Reference=126,ClassName="ModuleScript"}}},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Card = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "Card").default
local ParallaxImage = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "ParallaxImage").default
local VERSION_TAG = TS.import(script, script.Parent.Parent.Parent.Parent, "constants").VERSION_TAG
local useDelayedUpdate = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useIsPageOpen = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "use-current-page").useIsPageOpen
local useParallaxOffset = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "use-parallax-offset").useParallaxOffset
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local Label
local function Title()
	local theme = useTheme("home").title
	local offset = useParallaxOffset()
	return Roact.createElement(Card, {
		index = 0,
		page = DashboardPage.Home,
		theme = theme,
		size = px(326, 184),
		position = UDim2.new(0, 0, 1, -648 - 48),
	}, {
		Roact.createElement(ParallaxImage, {
			image = "rbxassetid://9049308243",
			imageSize = Vector2.new(652, 368),
			padding = Vector2.new(30, 30),
			offset = offset,
		}, {
			Roact.createElement("UICorner", {
				CornerRadius = UDim.new(0, 12),
			}),
		}),
		Roact.createElement("ImageLabel", {
			Image = "rbxassetid://9048947177",
			Size = scale(1, 1),
			ImageTransparency = 0.3,
			BackgroundTransparency = 1,
		}, {
			Roact.createElement("UICorner", {
				CornerRadius = UDim.new(0, 12),
			}),
		}),
		Roact.createElement(Canvas, {
			padding = {
				top = 24,
				left = 24,
			},
		}, {
			Roact.createElement(Label, {
				index = 0,
				text = "Orca",
				font = Enum.Font.GothamBlack,
				size = 20,
				position = px(0, 0),
			}),
			Roact.createElement(Label, {
				index = 1,
				text = VERSION_TAG,
				position = px(0, 40),
			}),
			Roact.createElement(Label, {
				index = 2,
				text = "By 0866",
				position = px(0, 63),
				transparency = 0.15,
			}),
			Roact.createElement(Label, {
				index = 3,
				text = "Pls star repo",
				position = px(0, 86),
				transparency = 0.3,
			}),
			Roact.createElement(Label, {
				index = 4,
				text = "richie0866/orca",
				position = UDim2.new(0, 0, 1, -40),
				transparency = 0.45,
			}),
		}),
	})
end
local default = hooked(Title)
local function LabelComponent(props)
	local _binding = props
	local index = _binding.index
	local text = _binding.text
	local font = _binding.font
	if font == nil then
		font = Enum.Font.GothamBold
	end
	local size = _binding.size
	if size == nil then
		size = 16
	end
	local position = _binding.position
	local transparency = _binding.transparency
	if transparency == nil then
		transparency = 0
	end
	local theme = useTheme("home").title
	local isOpen = useIsPageOpen(DashboardPage.Home)
	local isActive = useDelayedUpdate(isOpen, index * 100 + 300, function(current)
		return not current
	end)
	local _attributes = {
		Text = text,
		Font = font,
		TextColor3 = theme.foreground,
		TextSize = size,
		TextTransparency = useSpring(isActive and transparency or 1, {
			frequency = 2,
		}),
		TextXAlignment = "Left",
		TextYAlignment = "Top",
		Size = px(200, 24),
	}
	local _result
	if isActive then
		_result = position
	else
		local _arg0 = px(24, 0)
		_result = position - _arg0
	end
	_attributes.Position = useSpring(_result, {})
	_attributes.BackgroundTransparency = 1
	return Roact.createElement("TextLabel", _attributes)
end
Label = hooked(LabelComponent)
return {
	default = default,
}
 end,Properties={Name="Title"},Reference=134,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local pure = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).pure
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent, "components", "Canvas").default
local useScale = TS.import(script, script.Parent.Parent.Parent.Parent, "hooks", "use-scale").useScale
local scale = TS.import(script, script.Parent.Parent.Parent.Parent, "utils", "udim2").scale
local FriendActivity = TS.import(script, script.Parent, "FriendActivity").default
local Profile = TS.import(script, script.Parent, "Profile").default
local Server = TS.import(script, script.Parent, "Server").default
local Title = TS.import(script, script.Parent, "Title").default
local function Home()
	local scaleFactor = useScale()
	return Roact.createElement(Canvas, {
		position = scale(0, 1),
		anchor = Vector2.new(0, 1),
	}, {
		Roact.createElement("UIScale", {
			Scale = scaleFactor,
		}),
		Roact.createElement(Title),
		Roact.createElement(Server),
		Roact.createElement(FriendActivity),
		Roact.createElement(Profile),
	})
end
local default = pure(Home)
return {
	default = default,
}
 end,Properties={Name="Home"},Reference=122,ClassName="ModuleScript"},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "FriendActivity").default
return exports
 end,Properties={Name="FriendActivity"},Reference=118,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useState = _roact_hooked.useState
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local TeleportService = _services.TeleportService
local Border = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Border").default
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Fill = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Fill").default
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local FRIEND_SPRING_OPTIONS = {
	frequency = 6,
}
local function FriendItem(_param)
	local friend = _param.friend
	local index = _param.index
	local theme = useTheme("home").friendActivity.friendButton
	local _binding = useState(false)
	local isHovered = _binding[1]
	local setHovered = _binding[2]
	local avatar = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. (tostring(friend.VisitorId) .. "&width=48&height=48&format=png")
	local _attributes = {
		size = useSpring(isHovered and px(96, 48) or px(48, 48), FRIEND_SPRING_OPTIONS),
	}
	local _children = {
		Roact.createElement("ImageLabel", {
			Image = "rbxassetid://8992244272",
			ImageColor3 = useSpring(isHovered and theme.accent or theme.dropshadow, FRIEND_SPRING_OPTIONS),
			ImageTransparency = useSpring(isHovered and theme.glowTransparency or theme.dropshadowTransparency, FRIEND_SPRING_OPTIONS),
			Size = useSpring(isHovered and px(88 + 36, 74) or px(76, 74), FRIEND_SPRING_OPTIONS),
			Position = px(-14, -10),
			ScaleType = "Slice",
			SliceCenter = Rect.new(Vector2.new(42, 42), Vector2.new(42, 42)),
			BackgroundTransparency = 1,
		}),
		Roact.createElement(Fill, {
			radius = 24,
			color = useSpring(isHovered and theme.accent or theme.background, FRIEND_SPRING_OPTIONS),
			transparency = theme.backgroundTransparency,
		}),
	}
	local _length = #_children
	local _child = theme.outlined and (Roact.createFragment({
		border = Roact.createElement(Border, {
			radius = 23,
			color = isHovered and theme.foregroundAccent and theme.foregroundAccent or theme.foreground,
			transparency = 0.7,
		}),
	}))
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children[_length + 1] = Roact.createElement("ImageLabel", {
		Image = avatar,
		ScaleType = "Crop",
		Size = px(48, 48),
		LayoutOrder = index,
		BackgroundTransparency = 1,
	}, {
		Roact.createElement("UICorner", {
			CornerRadius = UDim.new(1, 0),
		}),
	})
	_children[_length + 2] = Roact.createElement(Canvas, {
		clipsDescendants = true,
	}, {
		Roact.createElement("ImageLabel", {
			Image = "rbxassetid://8992244380",
			ImageColor3 = isHovered and theme.foregroundAccent and theme.foregroundAccent or theme.foreground,
			ImageTransparency = theme.foregroundTransparency,
			Size = px(36, 36),
			Position = px(48, 6),
			BackgroundTransparency = 1,
		}),
	})
	_children[_length + 3] = Roact.createElement("TextButton", {
		Text = "",
		AutoButtonColor = false,
		Size = scale(1, 1),
		BackgroundTransparency = 1,
		[Roact.Event.Activated] = function()
			pcall(function()
				TeleportService:TeleportToPlaceInstance(friend.PlaceId, friend.GameId, Players.LocalPlayer)
			end)
		end,
		[Roact.Event.MouseEnter] = function()
			return setHovered(true)
		end,
		[Roact.Event.MouseLeave] = function()
			return setHovered(false)
		end,
	})
	return Roact.createElement(Canvas, _attributes, _children)
end
local default = hooked(FriendItem)
return {
	default = default,
}
 end,Properties={Name="FriendItem"},Reference=120,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useEffect = _roact_hooked.useEffect
local useReducer = _roact_hooked.useReducer
local useState = _roact_hooked.useState
local Canvas = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Canvas").default
local Card = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Card").default
local useInterval = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-interval").useInterval
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useFriendActivity = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-friends").useFriendActivity
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local arrayToMap = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "array-util").arrayToMap
local _udim2 = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local _GameItem = TS.import(script, script.Parent, "GameItem")
local GameItem = _GameItem.default
local GAME_PADDING = _GameItem.GAME_PADDING
local function FriendActivity()
	local theme = useTheme("home").friendActivity
	local _binding = useReducer(function(state)
		return state + 1
	end, 0)
	local update = _binding[1]
	local forceUpdate = _binding[2]
	local _binding_1 = useFriendActivity({ update })
	local currentGames = _binding_1[1]
	local status = _binding_1[3]
	local _binding_2 = useState(currentGames)
	local games = _binding_2[1]
	local setGames = _binding_2[2]
	useEffect(function()
		if #currentGames > 0 then
			local _arg0 = function(a, b)
				return #a.friends > #b.friends
			end
			-- \226\150\188 Array.sort \226\150\188
			table.sort(currentGames, _arg0)
			-- \226\150\178 Array.sort \226\150\178
			setGames(currentGames)
		end
	end, { currentGames })
	useInterval(function()
		return forceUpdate()
	end, #currentGames == 0 and status ~= "pending" and 5000 or 30000)
	local _attributes = {
		index = 3,
		page = DashboardPage.Home,
		theme = theme,
		size = px(326, 416),
		position = UDim2.new(0, 374, 1, 0),
	}
	local _children = {
		Roact.createElement("TextLabel", {
			Text = "Friend Activity",
			Font = "GothamBlack",
			TextSize = 20,
			TextColor3 = theme.foreground,
			TextXAlignment = "Left",
			TextYAlignment = "Top",
			Position = px(24, 24),
			BackgroundTransparency = 1,
		}),
	}
	local _length = #_children
	local _attributes_1 = {
		anchor = Vector2.new(0, 1),
		size = useSpring(#games > 0 and UDim2.new(1, 0, 0, 344) or UDim2.new(1, 0, 0, 0), {}),
		position = scale(0, 1),
	}
	local _children_1 = {}
	local _length_1 = #_children_1
	local _attributes_2 = {
		Size = scale(1, 1),
		ScrollBarThickness = 0,
		ScrollBarImageTransparency = 1,
		ScrollingDirection = "Y",
		CanvasSize = px(0, #games * (GAME_PADDING + 156) + GAME_PADDING),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
	}
	local _children_2 = {}
	local _length_2 = #_children_2
	for _k, _v in pairs(arrayToMap(games, function(gameActivity, index)
		return { tostring(gameActivity.placeId), Roact.createElement(GameItem, {
			gameActivity = gameActivity,
			index = index,
		}) }
	end)) do
		_children_2[_k] = _v
	end
	_children_1[_length_1 + 1] = Roact.createElement("ScrollingFrame", _attributes_2, _children_2)
	_children[_length + 1] = Roact.createElement(Canvas, _attributes_1, _children_1)
	return Roact.createElement(Card, _attributes, _children)
end
local default = hooked(FriendActivity)
return {
	default = default,
}
 end,Properties={Name="FriendActivity"},Reference=119,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local pure = _roact_hooked.pure
local useMemo = _roact_hooked.useMemo
local Border = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "components", "Border").default
local useDelayedUpdate = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useSpring = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useIsPageOpen = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-current-page").useIsPageOpen
local useTheme = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "hooks", "use-theme").useTheme
local DashboardPage = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local arrayToMap = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "array-util").arrayToMap
local px = TS.import(script, script.Parent.Parent.Parent.Parent.Parent, "utils", "udim2").px
local FriendItem = TS.import(script, script.Parent, "FriendItem").default
local GAME_PADDING = 48
local function GameItem(_param)
	local gameActivity = _param.gameActivity
	local index = _param.index
	local theme = useTheme("home").friendActivity
	local isOpen = useIsPageOpen(DashboardPage.Home)
	local isVisible = useDelayedUpdate(isOpen, isOpen and 330 + index * 100 or 300)
	local canvasLength = useMemo(function()
		return #gameActivity.friends * (48 + 10) + 96
	end, { #gameActivity.friends })
	local _attributes = {
		Image = gameActivity.thumbnail,
		ScaleType = "Crop",
		Size = px(278, 156),
		Position = useSpring(isVisible and px(24, index * (GAME_PADDING + 156)) or px(-278, index * (GAME_PADDING + 156)), {}),
		BackgroundTransparency = 1,
	}
	local _children = {
		Roact.createElement(Border, {
			color = theme.foreground,
			radius = 8,
			transparency = 0.8,
		}),
		Roact.createElement("UICorner", {
			CornerRadius = UDim.new(0, 8),
		}),
	}
	local _length = #_children
	local _attributes_1 = {
		Size = UDim2.new(1, 0, 0, 64),
		Position = UDim2.new(0, 0, 1, -24),
		CanvasSize = px(canvasLength, 0),
		ScrollingDirection = "X",
		ScrollBarThickness = 0,
		ScrollBarImageTransparency = 1,
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		ClipsDescendants = false,
	}
	local _children_1 = {
		Roact.createElement("UIListLayout", {
			SortOrder = "LayoutOrder",
			FillDirection = "Horizontal",
			HorizontalAlignment = "Left",
			VerticalAlignment = "Top",
			Padding = UDim.new(0, 10),
		}),
		Roact.createElement("UIPadding", {
			PaddingLeft = UDim.new(0, 10),
		}),
	}
	local _length_1 = #_children_1
	for _k, _v in pairs(arrayToMap(gameActivity.friends, function(friend, index)
		return { tostring(friend.VisitorId), Roact.createElement(FriendItem, {
			friend = friend,
			index = index,
		}) }
	end)) do
		_children_1[_k] = _v
	end
	_children[_length + 1] = Roact.createElement("ScrollingFrame", _attributes_1, _children_1)
	return Roact.createElement("ImageLabel", _attributes, _children)
end
local default = pure(GameItem)
return {
	GAME_PADDING = GAME_PADDING,
	default = default,
}
 end,Properties={Name="GameItem"},Reference=121,ClassName="ModuleScript"}}}}}}}},Properties={Name="views"},Reference=96,ClassName="Folder"},{Children={{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Rodux = TS.import(script, TS.getModule(script, "@rbxts", "rodux").src)
local persistentState = TS.import(script, script.Parent.Parent, "persistent-state").persistentState
local initialState = persistentState("options", function(state)
	return state.options
end, {
	currentTheme = "Sorbet",
	config = {
		acrylicBlur = true,
	},
	shortcuts = {
		toggleDashboard = Enum.KeyCode.K.Value,
	},
})
local optionsReducer = Rodux.createReducer(initialState, {
	["options/setConfig"] = function(state, action)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		local _left = "config"
		local _object_1 = {}
		for _k, _v in pairs(state.config) do
			_object_1[_k] = _v
		end
		_object_1[action.name] = action.active
		_object[_left] = _object_1
		return _object
	end,
	["options/setTheme"] = function(state, action)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		_object.currentTheme = action.theme
		return _object
	end,
	["options/setShortcut"] = function(state, action)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		local _left = "shortcuts"
		local _object_1 = {}
		for _k, _v in pairs(state.shortcuts) do
			_object_1[_k] = _v
		end
		_object_1[action.shortcut] = action.keycode
		_object[_left] = _object_1
		return _object
	end,
	["options/removeShortcut"] = function(state, action)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		local _left = "shortcuts"
		local _object_1 = {}
		for _k, _v in pairs(state.shortcuts) do
			_object_1[_k] = _v
		end
		_object_1[action.shortcut] = nil
		_object[_left] = _object_1
		return _object
	end,
})
return {
	optionsReducer = optionsReducer,
}
 end,Properties={Name="options.reducer"},Reference=77,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Rodux = TS.import(script, TS.getModule(script, "@rbxts", "rodux").src)
local initialState = {
	flight = {
		value = 60,
		active = false,
	},
	walkSpeed = {
		value = 80,
		active = false,
	},
	jumpHeight = {
		value = 200,
		active = false,
	},
	refresh = {
		active = false,
	},
	ghost = {
		active = false,
	},
	godmode = {
		active = false,
	},
	freecam = {
		active = false,
	},
	teleport = {
		active = false,
	},
	hide = {
		active = false,
	},
	kill = {
		active = false,
	},
	spectate = {
		active = false,
	},
	rejoinServer = {
		active = false,
	},
	switchServer = {
		active = false,
	},
}
local jobsReducer = Rodux.createReducer(initialState, {
	["jobs/setJobActive"] = function(state, action)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		local _left = action.jobName
		local _object_1 = {}
		for _k, _v in pairs(state[action.jobName]) do
			_object_1[_k] = _v
		end
		_object_1.active = action.active
		_object[_left] = _object_1
		return _object
	end,
	["jobs/setJobValue"] = function(state, action)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		local _left = action.jobName
		local _object_1 = {}
		for _k, _v in pairs(state[action.jobName]) do
			_object_1[_k] = _v
		end
		_object_1.value = action.value
		_object[_left] = _object_1
		return _object
	end,
})
return {
	jobsReducer = jobsReducer,
}
 end,Properties={Name="jobs.reducer"},Reference=76,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Rodux = TS.import(script, TS.getModule(script, "@rbxts", "rodux").src)
local DashboardPage = TS.import(script, script.Parent.Parent, "models", "dashboard.model").DashboardPage
local initialState = {
	page = DashboardPage.Home,
	isOpen = false,
	hint = nil,
	apps = {
		playerSelected = nil,
	},
}
local dashboardReducer = Rodux.createReducer(initialState, {
	["dashboard/setDashboardPage"] = function(state, action)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		_object.page = action.page
		return _object
	end,
	["dashboard/toggleDashboard"] = function(state)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		_object.isOpen = not state.isOpen
		return _object
	end,
	["dashboard/setHint"] = function(state, action)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		_object.hint = action.hint
		return _object
	end,
	["dashboard/clearHint"] = function(state)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		_object.hint = nil
		return _object
	end,
	["dashboard/playerSelected"] = function(state, action)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		local _left = "apps"
		local _object_1 = {}
		for _k, _v in pairs(state.apps) do
			_object_1[_k] = _v
		end
		_object_1.playerSelected = action.name
		_object[_left] = _object_1
		return _object
	end,
	["dashboard/playerDeselected"] = function(state)
		local _object = {}
		for _k, _v in pairs(state) do
			_object[_k] = _v
		end
		local _left = "apps"
		local _object_1 = {}
		for _k, _v in pairs(state.apps) do
			_object_1[_k] = _v
		end
		_object_1.playerSelected = nil
		_object[_left] = _object_1
		return _object
	end,
})
return {
	dashboardReducer = dashboardReducer,
}
 end,Properties={Name="dashboard.reducer"},Reference=75,ClassName="ModuleScript"}},Properties={Name="reducers"},Reference=74,ClassName="Folder"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local HttpService = _services.HttpService
local Players = _services.Players
local getStore = TS.import(script, script.Parent.Parent, "jobs", "helpers", "job-store").getStore
local setInterval = TS.import(script, script.Parent.Parent, "utils", "timeout").setInterval
if makefolder and not isfolder("_orca") then
	makefolder("_orca")
end
local function read(file)
	if readfile then
		return isfile(file) and readfile(file) or nil
	else
		print("READ   " .. file)
		return nil
	end
end
local function write(file, content)
	if writefile then
		return writefile(file, content)
	else
		print("WRITE  " .. (file .. (" => \n" .. content)))
		return nil
	end
end
local autosave
local function persistentState(name, selector, defaultValue)
	local _exitType, _returns = TS.try(function()
		local serializedState = read("_orca/" .. (name .. ".json"))
		if serializedState == nil then
			write("_orca/" .. (name .. ".json"), HttpService:JSONEncode(defaultValue))
			return TS.TRY_RETURN, { defaultValue }
		end
		local value = HttpService:JSONDecode(serializedState)
		autosave(name, selector):catch(function()
			warn("Autosave failed")
		end)
		return TS.TRY_RETURN, { value }
	end, function(err)
		warn("Failed to load " .. (name .. (".json: " .. tostring(err))))
		return TS.TRY_RETURN, { defaultValue }
	end)
	if _exitType then
		return unpack(_returns)
	end
end
autosave = TS.async(function(name, selector)
	local store = TS.await(getStore())
	local function save()
		local state = selector(store:getState())
		write("_orca/" .. (name .. ".json"), HttpService:JSONEncode(state))
	end
	setInterval(function()
		return save
	end, 60000)
	Players.PlayerRemoving:Connect(function(player)
		if player == Players.LocalPlayer then
			save()
		end
	end)
end)
return {
	persistentState = persistentState,
}
 end,Properties={Name="persistent-state"},Reference=73,ClassName="ModuleScript"},{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Rodux = TS.import(script, TS.getModule(script, "@rbxts", "rodux").src)
local setDashboardPage = Rodux.makeActionCreator("dashboard/setDashboardPage", function(page)
	return {
		page = page,
	}
end)
local toggleDashboard = Rodux.makeActionCreator("dashboard/toggleDashboard", function()
	return {}
end)
local setHint = Rodux.makeActionCreator("dashboard/setHint", function(hint)
	return {
		hint = hint,
	}
end)
local clearHint = Rodux.makeActionCreator("dashboard/clearHint", function()
	return {}
end)
local playerSelected = Rodux.makeActionCreator("dashboard/playerSelected", function(player)
	return {
		name = player.Name,
	}
end)
local playerDeselected = Rodux.makeActionCreator("dashboard/playerDeselected", function()
	return {}
end)
return {
	setDashboardPage = setDashboardPage,
	toggleDashboard = toggleDashboard,
	setHint = setHint,
	clearHint = clearHint,
	playerSelected = playerSelected,
	playerDeselected = playerDeselected,
}
 end,Properties={Name="dashboard.action"},Reference=66,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Rodux = TS.import(script, TS.getModule(script, "@rbxts", "rodux").src)
local setJobActive = Rodux.makeActionCreator("jobs/setJobActive", function(jobName, active)
	return {
		jobName = jobName,
		active = active,
	}
end)
local setJobValue = Rodux.makeActionCreator("jobs/setJobValue", function(jobName, value)
	return {
		jobName = jobName,
		value = value,
	}
end)
return {
	setJobActive = setJobActive,
	setJobValue = setJobValue,
}
 end,Properties={Name="jobs.action"},Reference=67,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Rodux = TS.import(script, TS.getModule(script, "@rbxts", "rodux").src)
local setConfig = Rodux.makeActionCreator("options/setConfig", function(name, active)
	return {
		name = name,
		active = active,
	}
end)
local setShortcut = Rodux.makeActionCreator("options/setShortcut", function(shortcut, keycode)
	return {
		shortcut = shortcut,
		keycode = keycode,
	}
end)
local removeShortcut = Rodux.makeActionCreator("options/removeShortcut", function(shortcut)
	return {
		shortcut = shortcut,
	}
end)
local setTheme = Rodux.makeActionCreator("options/setTheme", function(theme)
	return {
		theme = theme,
	}
end)
return {
	setConfig = setConfig,
	setShortcut = setShortcut,
	removeShortcut = removeShortcut,
	setTheme = setTheme,
}
 end,Properties={Name="options.action"},Reference=68,ClassName="ModuleScript"}},Properties={Name="actions"},Reference=65,ClassName="Folder"},{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
 end,Properties={Name="options.model"},Reference=72,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local DashboardPage
do
	local _inverse = {}
	DashboardPage = setmetatable({}, {
		__index = _inverse,
	})
	DashboardPage.Home = "home"
	_inverse.home = "Home"
	DashboardPage.Apps = "apps"
	_inverse.apps = "Apps"
	DashboardPage.Scripts = "scripts"
	_inverse.scripts = "Scripts"
	DashboardPage.Options = "options"
	_inverse.options = "Options"
end
local PAGE_TO_INDEX = {
	[DashboardPage.Home] = 0,
	[DashboardPage.Apps] = 1,
	[DashboardPage.Scripts] = 2,
	[DashboardPage.Options] = 3,
}
local PAGE_TO_ICON = {
	[DashboardPage.Home] = "rbxassetid://8992031167",
	[DashboardPage.Apps] = "rbxassetid://8992031246",
	[DashboardPage.Scripts] = "rbxassetid://8992030918",
	[DashboardPage.Options] = "rbxassetid://8992031056",
}
return {
	DashboardPage = DashboardPage,
	PAGE_TO_INDEX = PAGE_TO_INDEX,
	PAGE_TO_ICON = PAGE_TO_ICON,
}
 end,Properties={Name="dashboard.model"},Reference=70,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
 end,Properties={Name="jobs.model"},Reference=71,ClassName="ModuleScript"}},Properties={Name="models"},Reference=69,ClassName="Folder"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Rodux = TS.import(script, TS.getModule(script, "@rbxts", "rodux").src)
local dashboardReducer = TS.import(script, script.Parent, "reducers", "dashboard.reducer").dashboardReducer
local jobsReducer = TS.import(script, script.Parent, "reducers", "jobs.reducer").jobsReducer
local optionsReducer = TS.import(script, script.Parent, "reducers", "options.reducer").optionsReducer
local rootReducer = Rodux.combineReducers({
	dashboard = dashboardReducer,
	jobs = jobsReducer,
	options = optionsReducer,
})
local function configureStore(initialState)
	return Rodux.Store.new(rootReducer, initialState)
end
return {
	configureStore = configureStore,
}
 end,Properties={Name="store"},Reference=78,ClassName="ModuleScript"}},Properties={Name="store"},Reference=64,ClassName="Folder"},{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local ScaleContext = Roact.createContext((Roact.createBinding(1)))
return {
	ScaleContext = ScaleContext,
}
 end,Properties={Name="scale-context"},Reference=19,ClassName="ModuleScript"}},Properties={Name="context"},Reference=18,ClassName="Folder"},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.include.RuntimeLib)
local darkTheme = TS.import(script, script, "dark-theme").darkTheme
local frostedGlass = TS.import(script, script, "frosted-glass").frostedGlass
local highContrast = TS.import(script, script, "high-contrast").highContrast
local lightTheme = TS.import(script, script, "light-theme").lightTheme
local obsidian = TS.import(script, script, "obsidian").obsidian
local sorbet = TS.import(script, script, "sorbet").sorbet
local themes = { sorbet, darkTheme, lightTheme, frostedGlass, obsidian, highContrast }
local function getThemes()
	return themes
end
return {
	getThemes = getThemes,
}
 end,Properties={Name="themes"},Reference=79,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local hex = TS.import(script, script.Parent.Parent, "utils", "color3").hex
local darkTheme = {
	name = "Dark theme",
	preview = {
		foreground = {
			color = ColorSequence.new(hex("#ffffff")),
		},
		background = {
			color = ColorSequence.new(hex("#232428")),
		},
		accent = {
			color = ColorSequence.new({ ColorSequenceKeypoint.new(0, hex("#F6BD29")), ColorSequenceKeypoint.new(0.5, hex("#F64229")), ColorSequenceKeypoint.new(1, hex("#9029F6")) }),
			rotation = 25,
		},
	},
	navbar = {
		outlined = true,
		acrylic = false,
		foreground = hex("#ffffff"),
		background = hex("#232428"),
		transparency = 0,
		accentGradient = {
			color = ColorSequence.new({ ColorSequenceKeypoint.new(0, hex("#f629c6")), ColorSequenceKeypoint.new(0.25, hex("#F64229")), ColorSequenceKeypoint.new(0.5, hex("#ffd42a")), ColorSequenceKeypoint.new(0.75, hex("#37CC95")), ColorSequenceKeypoint.new(1, hex("#3789cc")) }),
		},
		dropshadow = hex("#232428"),
		dropshadowTransparency = 0.3,
		glowTransparency = 0,
	},
	clock = {
		outlined = true,
		acrylic = false,
		foreground = hex("#ffffff"),
		background = hex("#232428"),
		transparency = 0,
		dropshadow = hex("#232428"),
		dropshadowTransparency = 0.3,
	},
	home = {
		title = {
			outlined = true,
			acrylic = false,
			foreground = hex("#ffffff"),
			background = hex("#ffffff"),
			backgroundGradient = {
				color = ColorSequence.new({ ColorSequenceKeypoint.new(0, hex("#F6BD29")), ColorSequenceKeypoint.new(0.5, hex("#F64229")), ColorSequenceKeypoint.new(1, hex("#9029F6")) }),
				rotation = 25,
			},
			transparency = 0,
			dropshadow = hex("#ffffff"),
			dropshadowGradient = {
				color = ColorSequence.new({ ColorSequenceKeypoint.new(0, hex("#F6BD29")), ColorSequenceKeypoint.new(0.5, hex("#F64229")), ColorSequenceKeypoint.new(1, hex("#9029F6")) }),
				rotation = 25,
			},
			dropshadowTransparency = 0.3,
		},
		profile = {
			outlined = true,
			acrylic = false,
			foreground = hex("#ffffff"),
			background = hex("#232428"),
			transparency = 0,
			dropshadow = hex("#232428"),
			dropshadowTransparency = 0.3,
			avatar = {
				background = hex("#1B1C20"),
				gradient = {
					color = ColorSequence.new({ ColorSequenceKeypoint.new(0, hex("#F6BD29")), ColorSequenceKeypoint.new(0.5, hex("#F64229")), ColorSequenceKeypoint.new(1, hex("#9029F6")) }),
					rotation = 25,
				},
				transparency = 0,
			},
			button = {
				outlined = true,
				foreground = hex("#ffffff"),
				foregroundTransparency = 0.5,
				background = hex("#1B1C20"),
				backgroundTransparency = 0,
			},
			slider = {
				outlined = true,
				foreground = hex("#ffffff"),
				foregroundTransparency = 0,
				background = hex("#1B1C20"),
				backgroundTransparency = 0,
			},
			highlight = {
				flight = hex("#a22df0"),
				walkSpeed = hex("#EC423D"),
				jumpHeight = hex("#37CC95"),
				refresh = hex("#a22df0"),
				ghost = hex("#FF4040"),
				godmode = hex("#f09c2d"),
				freecam = hex("#37CC95"),
			},
		},
		server = {
			outlined = true,
			acrylic = false,
			foreground = hex("#ffffff"),
			background = hex("#37CC95"),
			transparency = 0,
			dropshadow = hex("#37CC95"),
			dropshadowTransparency = 0.3,
			rejoinButton = {
				outlined = true,
				foreground = hex("#ffffff"),
				background = hex("#37CC95"),
				accent = hex("#232428"),
				foregroundTransparency = 0,
				backgroundTransparency = 0,
			},
			switchButton = {
				outlined = true,
				foreground = hex("#ffffff"),
				background = hex("#37CC95"),
				accent = hex("#232428"),
				foregroundTransparency = 0,
				backgroundTransparency = 0,
			},
		},
		friendActivity = {
			outlined = true,
			acrylic = false,
			foreground = hex("#ffffff"),
			background = hex("#232428"),
			transparency = 0,
			dropshadow = hex("#232428"),
			dropshadowTransparency = 0.3,
			friendButton = {
				outlined = true,
				accent = hex("#37CC95"),
				foreground = hex("#ffffff"),
				foregroundTransparency = 0,
				background = hex("#1B1C20"),
				backgroundTransparency = 0,
				dropshadow = hex("#000000"),
				dropshadowTransparency = 0.4,
				glowTransparency = 0.6,
			},
		},
	},
	apps = {
		players = {
			outlined = true,
			acrylic = false,
			foreground = hex("#ffffff"),
			background = hex("#232428"),
			transparency = 0,
			dropshadow = hex("#232428"),
			dropshadowTransparency = 0.3,
			avatar = {
				background = hex("#1B1C20"),
				gradient = {
					color = ColorSequence.new({ ColorSequenceKeypoint.new(0, hex("#37CC95")), ColorSequenceKeypoint.new(1, hex("#37CC95")) }),
					rotation = 25,
				},
				transparency = 0,
			},
			button = {
				outlined = true,
				foreground = hex("#ffffff"),
				foregroundTransparency = 0.5,
				background = hex("#1B1C20"),
				backgroundTransparency = 0,
			},
			highlight = {
				teleport = hex("#37CC95"),
				hide = hex("#f09c2d"),
				kill = hex("#EC423D"),
				spectate = hex("#a22df0"),
			},
			playerButton = {
				outlined = true,
				accent = hex("#37CC95"),
				foreground = hex("#ffffff"),
				foregroundTransparency = 0.5,
				background = hex("#1B1C20"),
				backgroundTransparency = 0,
				dropshadow = hex("#000000"),
				dropshadowTransparency = 0.5,
				glowTransparency = 0.2,
			},
		},
	},
	options = {
		themes = {
			outlined = true,
			acrylic = false,
			foreground = hex("#ffffff"),
			background = hex("#232428"),
			transparency = 0,
			dropshadow = hex("#232428"),
			dropshadowTransparency = 0.3,
			themeButton = {
				outlined = true,
				accent = hex("#37a4cc"),
				foreground = hex("#ffffff"),
				foregroundTransparency = 0.5,
				background = hex("#1B1C20"),
				backgroundTransparency = 0,
				dropshadow = hex("#000000"),
				dropshadowTransparency = 0.5,
				glowTransparency = 0.2,
			},
		},
		shortcuts = {
			outlined = true,
			acrylic = false,
			foreground = hex("#ffffff"),
			background = hex("#232428"),
			transparency = 0,
			dropshadow = hex("#232428"),
			dropshadowTransparency = 0.3,
			shortcutButton = {
				outlined = true,
				accent = hex("#37CC95"),
				foreground = hex("#ffffff"),
				foregroundTransparency = 0.5,
				background = hex("#1B1C20"),
				backgroundTransparency = 0,
				dropshadow = hex("#000000"),
				dropshadowTransparency = 0.5,
				glowTransparency = 0.2,
			},
		},
		config = {
			outlined = true,
			acrylic = false,
			foreground = hex("#ffffff"),
			background = hex("#232428"),
			transparency = 0,
			dropshadow = hex("#232428"),
			dropshadowTransparency = 0.3,
			configButton = {
				outlined = true,
				accent = hex("#37CC95"),
				foreground = hex("#ffffff"),
				foregroundTransparency = 0.5,
				background = hex("#1B1C20"),
				backgroundTransparency = 0,
				dropshadow = hex("#000000"),
				dropshadowTransparency = 0.5,
				glowTransparency = 0.2,
			},
		},
	},
}
return {
	darkTheme = darkTheme,
}
 end,Properties={Name="dark-theme"},Reference=80,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local darkTheme = TS.import(script, script.Parent, "dark-theme").darkTheme
local hex = TS.import(script, script.Parent.Parent, "utils", "color3").hex
local accent = hex("#000000")
local accentSequence = ColorSequence.new(hex("#000000"))
local view = {
	acrylic = true,
	outlined = true,
	foreground = hex("#ffffff"),
	background = hex("#ffffff"),
	backgroundGradient = nil,
	transparency = 0.9,
	dropshadow = hex("#ffffff"),
	dropshadowTransparency = 0,
	dropshadowGradient = {
		color = ColorSequence.new(hex("#000000")),
		transparency = NumberSequence.new(1, 0.8),
		rotation = 90,
	},
}
local _object = {}
for _k, _v in pairs(darkTheme) do
	_object[_k] = _v
end
_object.name = "Frosted glass"
_object.preview = {
	foreground = {
		color = ColorSequence.new(hex("#ffffff")),
	},
	background = {
		color = ColorSequence.new(hex("#ffffff")),
	},
	accent = {
		color = accentSequence,
	},
}
local _left = "navbar"
local _object_1 = {}
for _k, _v in pairs(darkTheme.navbar) do
	_object_1[_k] = _v
end
_object_1.outlined = true
_object_1.acrylic = true
_object_1.foreground = hex("#ffffff")
_object_1.background = hex("#ffffff")
_object_1.backgroundGradient = nil
_object_1.transparency = 0.9
_object_1.dropshadow = hex("#000000")
_object_1.dropshadowTransparency = 0.2
_object_1.accentGradient = {
	color = ColorSequence.new(hex("#ffffff")),
	transparency = NumberSequence.new(0.8),
	rotation = 90,
}
_object_1.glowTransparency = 0.5
_object[_left] = _object_1
_object.clock = {
	outlined = true,
	acrylic = true,
	foreground = hex("#ffffff"),
	background = hex("#ffffff"),
	backgroundGradient = nil,
	transparency = 0.9,
	dropshadow = hex("#000000"),
	dropshadowTransparency = 0.2,
}
local _left_1 = "home"
local _object_2 = {}
local _left_2 = "title"
local _object_3 = {}
for _k, _v in pairs(view) do
	_object_3[_k] = _v
end
_object_2[_left_2] = _object_3
local _left_3 = "profile"
local _object_4 = {}
for _k, _v in pairs(view) do
	_object_4[_k] = _v
end
local _left_4 = "avatar"
local _object_5 = {}
for _k, _v in pairs(darkTheme.home.profile.avatar) do
	_object_5[_k] = _v
end
_object_5.background = hex("#ffffff")
_object_5.transparency = 0.7
_object_5.gradient = {
	color = ColorSequence.new(hex("#ffffff"), hex("#ffffff")),
	transparency = NumberSequence.new(0.5, 1),
	rotation = 45,
}
_object_4[_left_4] = _object_5
_object_4.highlight = {
	flight = accent,
	walkSpeed = accent,
	jumpHeight = accent,
	refresh = accent,
	ghost = accent,
	godmode = accent,
	freecam = accent,
}
local _left_5 = "slider"
local _object_6 = {}
for _k, _v in pairs(darkTheme.home.profile.slider) do
	_object_6[_k] = _v
end
_object_6.outlined = false
_object_6.foreground = hex("#ffffff")
_object_6.background = hex("#ffffff")
_object_6.backgroundTransparency = 0.8
_object_6.indicatorTransparency = 0.3
_object_4[_left_5] = _object_6
local _left_6 = "button"
local _object_7 = {}
for _k, _v in pairs(darkTheme.home.profile.button) do
	_object_7[_k] = _v
end
_object_7.outlined = false
_object_7.foreground = hex("#ffffff")
_object_7.background = hex("#ffffff")
_object_7.backgroundTransparency = 0.8
_object_4[_left_6] = _object_7
_object_2[_left_3] = _object_4
local _left_7 = "server"
local _object_8 = {}
for _k, _v in pairs(view) do
	_object_8[_k] = _v
end
local _left_8 = "rejoinButton"
local _object_9 = {}
for _k, _v in pairs(darkTheme.home.server.rejoinButton) do
	_object_9[_k] = _v
end
_object_9.outlined = false
_object_9.foreground = hex("#ffffff")
_object_9.background = hex("#ffffff")
_object_9.foregroundTransparency = 0.5
_object_9.backgroundTransparency = 0.8
_object_9.accent = accent
_object_8[_left_8] = _object_9
local _left_9 = "switchButton"
local _object_10 = {}
for _k, _v in pairs(darkTheme.home.server.switchButton) do
	_object_10[_k] = _v
end
_object_10.outlined = false
_object_10.foreground = hex("#ffffff")
_object_10.background = hex("#ffffff")
_object_10.foregroundTransparency = 0.5
_object_10.backgroundTransparency = 0.8
_object_10.accent = accent
_object_8[_left_9] = _object_10
_object_2[_left_7] = _object_8
local _left_10 = "friendActivity"
local _object_11 = {}
for _k, _v in pairs(view) do
	_object_11[_k] = _v
end
local _left_11 = "friendButton"
local _object_12 = {}
for _k, _v in pairs(darkTheme.home.friendActivity.friendButton) do
	_object_12[_k] = _v
end
_object_12.outlined = false
_object_12.foreground = hex("#ffffff")
_object_12.background = hex("#ffffff")
_object_12.dropshadow = hex("#ffffff")
_object_12.backgroundTransparency = 0.7
_object_11[_left_11] = _object_12
_object_2[_left_10] = _object_11
_object[_left_1] = _object_2
local _left_12 = "apps"
local _object_13 = {}
local _left_13 = "players"
local _object_14 = {}
for _k, _v in pairs(view) do
	_object_14[_k] = _v
end
_object_14.highlight = {
	teleport = accent,
	hide = accent,
	kill = accent,
	spectate = accent,
}
local _left_14 = "avatar"
local _object_15 = {}
for _k, _v in pairs(darkTheme.apps.players.avatar) do
	_object_15[_k] = _v
end
_object_15.background = hex("#ffffff")
_object_15.transparency = 0.7
_object_15.gradient = {
	color = ColorSequence.new(hex("#ffffff"), hex("#ffffff")),
	transparency = NumberSequence.new(0.5, 1),
	rotation = 45,
}
_object_14[_left_14] = _object_15
local _left_15 = "button"
local _object_16 = {}
for _k, _v in pairs(darkTheme.apps.players.button) do
	_object_16[_k] = _v
end
_object_16.outlined = false
_object_16.foreground = hex("#ffffff")
_object_16.background = hex("#ffffff")
_object_16.backgroundTransparency = 0.8
_object_14[_left_15] = _object_16
local _left_16 = "playerButton"
local _object_17 = {}
for _k, _v in pairs(darkTheme.apps.players.playerButton) do
	_object_17[_k] = _v
end
_object_17.outlined = false
_object_17.foreground = hex("#ffffff")
_object_17.background = hex("#ffffff")
_object_17.dropshadow = hex("#ffffff")
_object_17.accent = accent
_object_17.backgroundTransparency = 0.8
_object_17.dropshadowTransparency = 0.7
_object_14[_left_16] = _object_17
_object_13[_left_13] = _object_14
_object[_left_12] = _object_13
local _left_17 = "options"
local _object_18 = {}
local _left_18 = "config"
local _object_19 = {}
for _k, _v in pairs(view) do
	_object_19[_k] = _v
end
local _left_19 = "configButton"
local _object_20 = {}
for _k, _v in pairs(darkTheme.options.config.configButton) do
	_object_20[_k] = _v
end
_object_20.outlined = false
_object_20.foreground = hex("#ffffff")
_object_20.background = hex("#ffffff")
_object_20.dropshadow = hex("#ffffff")
_object_20.accent = accent
_object_20.backgroundTransparency = 0.8
_object_20.dropshadowTransparency = 0.7
_object_19[_left_19] = _object_20
_object_18[_left_18] = _object_19
local _left_20 = "shortcuts"
local _object_21 = {}
for _k, _v in pairs(view) do
	_object_21[_k] = _v
end
local _left_21 = "shortcutButton"
local _object_22 = {}
for _k, _v in pairs(darkTheme.options.shortcuts.shortcutButton) do
	_object_22[_k] = _v
end
_object_22.outlined = false
_object_22.foreground = hex("#ffffff")
_object_22.background = hex("#ffffff")
_object_22.dropshadow = hex("#ffffff")
_object_22.accent = accent
_object_22.backgroundTransparency = 0.8
_object_22.dropshadowTransparency = 0.7
_object_21[_left_21] = _object_22
_object_18[_left_20] = _object_21
local _left_22 = "themes"
local _object_23 = {}
for _k, _v in pairs(view) do
	_object_23[_k] = _v
end
local _left_23 = "themeButton"
local _object_24 = {}
for _k, _v in pairs(darkTheme.options.themes.themeButton) do
	_object_24[_k] = _v
end
_object_24.outlined = false
_object_24.foreground = hex("#ffffff")
_object_24.background = hex("#ffffff")
_object_24.dropshadow = hex("#ffffff")
_object_24.accent = accent
_object_24.backgroundTransparency = 0.8
_object_24.dropshadowTransparency = 0.7
_object_23[_left_23] = _object_24
_object_18[_left_22] = _object_23
_object[_left_17] = _object_18
local frostedGlass = _object
return {
	frostedGlass = frostedGlass,
}
 end,Properties={Name="frosted-glass"},Reference=81,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
 end,Properties={Name="theme.interface"},Reference=86,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local darkTheme = TS.import(script, script.Parent, "dark-theme").darkTheme
local hex = TS.import(script, script.Parent.Parent, "utils", "color3").hex
local redAccent = hex("#C6428E")
local blueAccent = hex("#484fd7")
local mixedAccent = hex("#9a3fe5")
local accentSequence = ColorSequence.new({ ColorSequenceKeypoint.new(0, redAccent), ColorSequenceKeypoint.new(0.5, mixedAccent), ColorSequenceKeypoint.new(1, blueAccent) })
local background = hex("#181818")
local backgroundDark = hex("#242424")
local view = {
	acrylic = false,
	outlined = false,
	foreground = hex("#ffffff"),
	background = background,
	backgroundGradient = nil,
	transparency = 0,
	dropshadow = background,
	dropshadowTransparency = 0.3,
}
local _object = {}
for _k, _v in pairs(darkTheme) do
	_object[_k] = _v
end
_object.name = "Sorbet"
_object.preview = {
	foreground = {
		color = ColorSequence.new(hex("#ffffff")),
	},
	background = {
		color = ColorSequence.new(background),
	},
	accent = {
		color = accentSequence,
	},
}
local _left = "navbar"
local _object_1 = {}
for _k, _v in pairs(darkTheme.navbar) do
	_object_1[_k] = _v
end
_object_1.outlined = false
_object_1.background = background
_object_1.dropshadow = background
_object_1.accentGradient = {
	color = accentSequence,
}
_object[_left] = _object_1
local _left_1 = "clock"
local _object_2 = {}
for _k, _v in pairs(darkTheme.clock) do
	_object_2[_k] = _v
end
_object_2.outlined = false
_object_2.background = background
_object_2.dropshadow = background
_object[_left_1] = _object_2
local _left_2 = "home"
local _object_3 = {}
local _left_3 = "title"
local _object_4 = {}
for _k, _v in pairs(view) do
	_object_4[_k] = _v
end
_object_4.background = hex("#ffffff")
_object_4.backgroundGradient = {
	color = accentSequence,
	rotation = 30,
}
_object_4.dropshadow = hex("#ffffff")
_object_4.dropshadowGradient = {
	color = accentSequence,
	rotation = 30,
}
_object_3[_left_3] = _object_4
local _left_4 = "profile"
local _object_5 = {}
for _k, _v in pairs(view) do
	_object_5[_k] = _v
end
local _left_5 = "avatar"
local _object_6 = {}
for _k, _v in pairs(darkTheme.home.profile.avatar) do
	_object_6[_k] = _v
end
_object_6.background = backgroundDark
_object_6.transparency = 0
_object_6.gradient = {
	color = accentSequence,
	rotation = 45,
}
_object_5[_left_5] = _object_6
_object_5.highlight = {
	flight = redAccent,
	walkSpeed = mixedAccent,
	jumpHeight = blueAccent,
	refresh = redAccent,
	ghost = blueAccent,
	godmode = redAccent,
	freecam = blueAccent,
}
local _left_6 = "slider"
local _object_7 = {}
for _k, _v in pairs(darkTheme.home.profile.slider) do
	_object_7[_k] = _v
end
_object_7.outlined = false
_object_7.foreground = hex("#ffffff")
_object_7.background = backgroundDark
_object_5[_left_6] = _object_7
local _left_7 = "button"
local _object_8 = {}
for _k, _v in pairs(darkTheme.home.profile.button) do
	_object_8[_k] = _v
end
_object_8.outlined = false
_object_8.foreground = hex("#ffffff")
_object_8.background = backgroundDark
_object_5[_left_7] = _object_8
_object_3[_left_4] = _object_5
local _left_8 = "server"
local _object_9 = {}
for _k, _v in pairs(view) do
	_object_9[_k] = _v
end
local _left_9 = "rejoinButton"
local _object_10 = {}
for _k, _v in pairs(darkTheme.home.server.rejoinButton) do
	_object_10[_k] = _v
end
_object_10.outlined = false
_object_10.foreground = hex("#ffffff")
_object_10.background = backgroundDark
_object_10.foregroundTransparency = 0.5
_object_10.accent = redAccent
_object_9[_left_9] = _object_10
local _left_10 = "switchButton"
local _object_11 = {}
for _k, _v in pairs(darkTheme.home.server.switchButton) do
	_object_11[_k] = _v
end
_object_11.outlined = false
_object_11.foreground = hex("#ffffff")
_object_11.background = backgroundDark
_object_11.foregroundTransparency = 0.5
_object_11.accent = blueAccent
_object_9[_left_10] = _object_11
_object_3[_left_8] = _object_9
local _left_11 = "friendActivity"
local _object_12 = {}
for _k, _v in pairs(view) do
	_object_12[_k] = _v
end
local _left_12 = "friendButton"
local _object_13 = {}
for _k, _v in pairs(darkTheme.home.friendActivity.friendButton) do
	_object_13[_k] = _v
end
_object_13.outlined = false
_object_13.foreground = hex("#ffffff")
_object_13.background = backgroundDark
_object_12[_left_12] = _object_13
_object_3[_left_11] = _object_12
_object[_left_2] = _object_3
local _left_13 = "apps"
local _object_14 = {}
local _left_14 = "players"
local _object_15 = {}
for _k, _v in pairs(view) do
	_object_15[_k] = _v
end
_object_15.highlight = {
	teleport = redAccent,
	hide = blueAccent,
	kill = redAccent,
	spectate = blueAccent,
}
local _left_15 = "avatar"
local _object_16 = {}
for _k, _v in pairs(darkTheme.apps.players.avatar) do
	_object_16[_k] = _v
end
_object_16.background = backgroundDark
_object_16.transparency = 0
_object_16.gradient = {
	color = accentSequence,
	rotation = 45,
}
_object_15[_left_15] = _object_16
local _left_16 = "button"
local _object_17 = {}
for _k, _v in pairs(darkTheme.apps.players.button) do
	_object_17[_k] = _v
end
_object_17.outlined = false
_object_17.foreground = hex("#ffffff")
_object_17.background = backgroundDark
_object_15[_left_16] = _object_17
local _left_17 = "playerButton"
local _object_18 = {}
for _k, _v in pairs(darkTheme.apps.players.playerButton) do
	_object_18[_k] = _v
end
_object_18.outlined = false
_object_18.foreground = hex("#ffffff")
_object_18.background = backgroundDark
_object_18.dropshadow = backgroundDark
_object_18.accent = blueAccent
_object_15[_left_17] = _object_18
_object_14[_left_14] = _object_15
_object[_left_13] = _object_14
local _left_18 = "options"
local _object_19 = {}
local _left_19 = "config"
local _object_20 = {}
for _k, _v in pairs(view) do
	_object_20[_k] = _v
end
local _left_20 = "configButton"
local _object_21 = {}
for _k, _v in pairs(darkTheme.options.config.configButton) do
	_object_21[_k] = _v
end
_object_21.outlined = false
_object_21.foreground = hex("#ffffff")
_object_21.background = backgroundDark
_object_21.dropshadow = backgroundDark
_object_21.accent = redAccent
_object_20[_left_20] = _object_21
_object_19[_left_19] = _object_20
local _left_21 = "shortcuts"
local _object_22 = {}
for _k, _v in pairs(view) do
	_object_22[_k] = _v
end
local _left_22 = "shortcutButton"
local _object_23 = {}
for _k, _v in pairs(darkTheme.options.shortcuts.shortcutButton) do
	_object_23[_k] = _v
end
_object_23.outlined = false
_object_23.foreground = hex("#ffffff")
_object_23.background = backgroundDark
_object_23.dropshadow = backgroundDark
_object_23.accent = mixedAccent
_object_22[_left_22] = _object_23
_object_19[_left_21] = _object_22
local _left_23 = "themes"
local _object_24 = {}
for _k, _v in pairs(view) do
	_object_24[_k] = _v
end
local _left_24 = "themeButton"
local _object_25 = {}
for _k, _v in pairs(darkTheme.options.themes.themeButton) do
	_object_25[_k] = _v
end
_object_25.outlined = false
_object_25.foreground = hex("#ffffff")
_object_25.background = backgroundDark
_object_25.dropshadow = backgroundDark
_object_25.accent = blueAccent
_object_24[_left_24] = _object_25
_object_19[_left_23] = _object_24
_object[_left_18] = _object_19
local sorbet = _object
return {
	sorbet = sorbet,
}
 end,Properties={Name="sorbet"},Reference=85,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local darkTheme = TS.import(script, script.Parent, "dark-theme").darkTheme
local hex = TS.import(script, script.Parent.Parent, "utils", "color3").hex
local _object = {}
for _k, _v in pairs(darkTheme) do
	_object[_k] = _v
end
_object.name = "High contrast"
_object.preview = {
	foreground = {
		color = ColorSequence.new(hex("#ffffff")),
	},
	background = {
		color = ColorSequence.new(hex("#000000")),
	},
	accent = {
		color = ColorSequence.new({ ColorSequenceKeypoint.new(0, hex("#F6BD29")), ColorSequenceKeypoint.new(0.5, hex("#F64229")), ColorSequenceKeypoint.new(1, hex("#9029F6")) }),
		rotation = 25,
	},
}
local _left = "navbar"
local _object_1 = {}
for _k, _v in pairs(darkTheme.navbar) do
	_object_1[_k] = _v
end
_object_1.foreground = hex("#ffffff")
_object_1.background = hex("#000000")
_object_1.dropshadow = hex("#000000")
_object[_left] = _object_1
local _left_1 = "clock"
local _object_2 = {}
for _k, _v in pairs(darkTheme.clock) do
	_object_2[_k] = _v
end
_object_2.foreground = hex("#ffffff")
_object_2.background = hex("#000000")
_object_2.dropshadow = hex("#000000")
_object[_left_1] = _object_2
local _left_2 = "home"
local _object_3 = {}
local _left_3 = "title"
local _object_4 = {}
for _k, _v in pairs(darkTheme.home.title) do
	_object_4[_k] = _v
end
_object_4.foreground = hex("#ffffff")
_object_4.background = hex("#000000")
_object_4.dropshadow = hex("#000000")
_object_3[_left_3] = _object_4
local _left_4 = "profile"
local _object_5 = {}
for _k, _v in pairs(darkTheme.home.profile) do
	_object_5[_k] = _v
end
_object_5.foreground = hex("#ffffff")
_object_5.background = hex("#000000")
_object_5.dropshadow = hex("#000000")
local _left_5 = "avatar"
local _object_6 = {}
for _k, _v in pairs(darkTheme.home.profile.avatar) do
	_object_6[_k] = _v
end
_object_6.background = hex("#ffffff")
_object_6.transparency = 0.9
_object_6.gradient = {
	color = ColorSequence.new({ ColorSequenceKeypoint.new(0, hex("#F6BD29")), ColorSequenceKeypoint.new(0.5, hex("#F64229")), ColorSequenceKeypoint.new(1, hex("#9029F6")) }),
}
_object_5[_left_5] = _object_6
local _left_6 = "slider"
local _object_7 = {}
for _k, _v in pairs(darkTheme.home.profile.slider) do
	_object_7[_k] = _v
end
_object_7.foreground = hex("#ffffff")
_object_7.background = hex("#000000")
_object_5[_left_6] = _object_7
local _left_7 = "button"
local _object_8 = {}
for _k, _v in pairs(darkTheme.home.profile.button) do
	_object_8[_k] = _v
end
_object_8.foreground = hex("#ffffff")
_object_8.background = hex("#000000")
_object_5[_left_7] = _object_8
_object_3[_left_4] = _object_5
local _left_8 = "server"
local _object_9 = {}
for _k, _v in pairs(darkTheme.home.server) do
	_object_9[_k] = _v
end
_object_9.foreground = hex("#ffffff")
_object_9.background = hex("#000000")
_object_9.dropshadow = hex("#000000")
local _left_9 = "rejoinButton"
local _object_10 = {}
for _k, _v in pairs(darkTheme.home.server.rejoinButton) do
	_object_10[_k] = _v
end
_object_10.foreground = hex("#ffffff")
_object_10.background = hex("#000000")
_object_10.foregroundTransparency = 0.5
_object_10.accent = hex("#ff3f6c")
_object_9[_left_9] = _object_10
local _left_10 = "switchButton"
local _object_11 = {}
for _k, _v in pairs(darkTheme.home.server.switchButton) do
	_object_11[_k] = _v
end
_object_11.foreground = hex("#ffffff")
_object_11.background = hex("#000000")
_object_11.foregroundTransparency = 0.5
_object_11.accent = hex("#ff3f6c")
_object_9[_left_10] = _object_11
_object_3[_left_8] = _object_9
local _left_11 = "friendActivity"
local _object_12 = {}
for _k, _v in pairs(darkTheme.home.friendActivity) do
	_object_12[_k] = _v
end
_object_12.foreground = hex("#ffffff")
_object_12.background = hex("#000000")
_object_12.dropshadow = hex("#000000")
local _left_12 = "friendButton"
local _object_13 = {}
for _k, _v in pairs(darkTheme.home.friendActivity.friendButton) do
	_object_13[_k] = _v
end
_object_13.foreground = hex("#ffffff")
_object_13.background = hex("#000000")
_object_12[_left_12] = _object_13
_object_3[_left_11] = _object_12
_object[_left_2] = _object_3
local _left_13 = "apps"
local _object_14 = {}
local _left_14 = "players"
local _object_15 = {}
for _k, _v in pairs(darkTheme.apps.players) do
	_object_15[_k] = _v
end
_object_15.foreground = hex("#ffffff")
_object_15.background = hex("#000000")
_object_15.dropshadow = hex("#000000")
local _left_15 = "avatar"
local _object_16 = {}
for _k, _v in pairs(darkTheme.apps.players.avatar) do
	_object_16[_k] = _v
end
_object_16.background = hex("#ffffff")
_object_16.transparency = 0.9
_object_16.gradient = {
	color = ColorSequence.new({ ColorSequenceKeypoint.new(0, hex("#F6BD29")), ColorSequenceKeypoint.new(0.5, hex("#F64229")), ColorSequenceKeypoint.new(1, hex("#9029F6")) }),
}
_object_15[_left_15] = _object_16
local _left_16 = "button"
local _object_17 = {}
for _k, _v in pairs(darkTheme.apps.players.button) do
	_object_17[_k] = _v
end
_object_17.foreground = hex("#ffffff")
_object_17.background = hex("#000000")
_object_15[_left_16] = _object_17
local _left_17 = "playerButton"
local _object_18 = {}
for _k, _v in pairs(darkTheme.apps.players.playerButton) do
	_object_18[_k] = _v
end
_object_18.foreground = hex("#ffffff")
_object_18.background = hex("#000000")
_object_18.accent = hex("#ff3f6c")
_object_18.dropshadowTransparency = 0.7
_object_15[_left_17] = _object_18
_object_14[_left_14] = _object_15
_object[_left_13] = _object_14
local _left_18 = "options"
local _object_19 = {}
local _left_19 = "config"
local _object_20 = {}
for _k, _v in pairs(darkTheme.options.config) do
	_object_20[_k] = _v
end
_object_20.foreground = hex("#ffffff")
_object_20.background = hex("#000000")
_object_20.dropshadow = hex("#000000")
local _left_20 = "configButton"
local _object_21 = {}
for _k, _v in pairs(darkTheme.options.config.configButton) do
	_object_21[_k] = _v
end
_object_21.foreground = hex("#ffffff")
_object_21.background = hex("#000000")
_object_21.accent = hex("#ff3f6c")
_object_21.dropshadowTransparency = 0.7
_object_20[_left_20] = _object_21
_object_19[_left_19] = _object_20
local _left_21 = "shortcuts"
local _object_22 = {}
for _k, _v in pairs(darkTheme.options.shortcuts) do
	_object_22[_k] = _v
end
_object_22.foreground = hex("#ffffff")
_object_22.background = hex("#000000")
_object_22.dropshadow = hex("#000000")
local _left_22 = "shortcutButton"
local _object_23 = {}
for _k, _v in pairs(darkTheme.options.shortcuts.shortcutButton) do
	_object_23[_k] = _v
end
_object_23.foreground = hex("#ffffff")
_object_23.background = hex("#000000")
_object_23.accent = hex("#ff3f6c")
_object_23.dropshadowTransparency = 0.7
_object_22[_left_22] = _object_23
_object_19[_left_21] = _object_22
local _left_23 = "themes"
local _object_24 = {}
for _k, _v in pairs(darkTheme.options.themes) do
	_object_24[_k] = _v
end
_object_24.foreground = hex("#ffffff")
_object_24.background = hex("#000000")
_object_24.dropshadow = hex("#000000")
local _left_24 = "themeButton"
local _object_25 = {}
for _k, _v in pairs(darkTheme.options.themes.themeButton) do
	_object_25[_k] = _v
end
_object_25.foreground = hex("#ffffff")
_object_25.background = hex("#000000")
_object_25.accent = hex("#ff3f6c")
_object_25.dropshadowTransparency = 0.7
_object_24[_left_24] = _object_25
_object_19[_left_23] = _object_24
_object[_left_18] = _object_19
local highContrast = _object
return {
	highContrast = highContrast,
}
 end,Properties={Name="high-contrast"},Reference=82,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local darkTheme = TS.import(script, script.Parent, "dark-theme").darkTheme
local hex = TS.import(script, script.Parent.Parent, "utils", "color3").hex
local accent = hex("#9029F6")
local accentSequence = ColorSequence.new(hex("#9029F6"))
local _object = {}
for _k, _v in pairs(darkTheme) do
	_object[_k] = _v
end
_object.name = "Obsidian"
_object.preview = {
	foreground = {
		color = ColorSequence.new(hex("#ffffff")),
	},
	background = {
		color = ColorSequence.new(hex("#000000")),
	},
	accent = {
		color = accentSequence,
	},
}
local _left = "navbar"
local _object_1 = {}
for _k, _v in pairs(darkTheme.navbar) do
	_object_1[_k] = _v
end
_object_1.acrylic = true
_object_1.outlined = false
_object_1.foreground = hex("#ffffff")
_object_1.background = hex("#000000")
_object_1.dropshadow = hex("#000000")
_object_1.transparency = 0.7
_object_1.accentGradient = {
	color = accentSequence,
	transparency = NumberSequence.new(0.5),
}
_object[_left] = _object_1
local _left_1 = "clock"
local _object_2 = {}
for _k, _v in pairs(darkTheme.clock) do
	_object_2[_k] = _v
end
_object_2.acrylic = true
_object_2.outlined = false
_object_2.foreground = hex("#ffffff")
_object_2.background = hex("#000000")
_object_2.dropshadow = hex("#000000")
_object_2.transparency = 0.7
_object[_left_1] = _object_2
local _left_2 = "home"
local _object_3 = {}
local _left_3 = "title"
local _object_4 = {}
for _k, _v in pairs(darkTheme.home.title) do
	_object_4[_k] = _v
end
_object_4.acrylic = true
_object_4.outlined = false
_object_4.foreground = hex("#ffffff")
_object_4.background = hex("#000000")
_object_4.dropshadow = hex("#000000")
_object_4.transparency = 0.7
_object_4.dropshadowTransparency = 0.65
_object_3[_left_3] = _object_4
local _left_4 = "profile"
local _object_5 = {}
for _k, _v in pairs(darkTheme.home.profile) do
	_object_5[_k] = _v
end
_object_5.acrylic = true
_object_5.outlined = false
_object_5.foreground = hex("#ffffff")
_object_5.background = hex("#000000")
_object_5.dropshadow = hex("#000000")
_object_5.transparency = 0.7
_object_5.dropshadowTransparency = 0.65
local _left_5 = "avatar"
local _object_6 = {}
for _k, _v in pairs(darkTheme.home.profile.avatar) do
	_object_6[_k] = _v
end
_object_6.background = hex("#000000")
_object_6.transparency = 0.7
_object_6.gradient = {
	color = accentSequence,
}
_object_5[_left_5] = _object_6
_object_5.highlight = {
	flight = accent,
	walkSpeed = accent,
	jumpHeight = accent,
	refresh = accent,
	ghost = accent,
	godmode = accent,
	freecam = accent,
}
local _left_6 = "slider"
local _object_7 = {}
for _k, _v in pairs(darkTheme.home.profile.slider) do
	_object_7[_k] = _v
end
_object_7.outlined = false
_object_7.foreground = hex("#ffffff")
_object_7.background = hex("#000000")
_object_7.backgroundTransparency = 0.5
_object_7.indicatorTransparency = 0.5
_object_5[_left_6] = _object_7
local _left_7 = "button"
local _object_8 = {}
for _k, _v in pairs(darkTheme.home.profile.button) do
	_object_8[_k] = _v
end
_object_8.outlined = false
_object_8.foreground = hex("#ffffff")
_object_8.background = hex("#000000")
_object_8.backgroundTransparency = 0.5
_object_5[_left_7] = _object_8
_object_3[_left_4] = _object_5
local _left_8 = "server"
local _object_9 = {}
for _k, _v in pairs(darkTheme.home.server) do
	_object_9[_k] = _v
end
_object_9.acrylic = true
_object_9.outlined = false
_object_9.foreground = hex("#ffffff")
_object_9.background = hex("#000000")
_object_9.dropshadow = hex("#000000")
_object_9.transparency = 0.7
_object_9.dropshadowTransparency = 0.65
local _left_9 = "rejoinButton"
local _object_10 = {}
for _k, _v in pairs(darkTheme.home.server.rejoinButton) do
	_object_10[_k] = _v
end
_object_10.outlined = false
_object_10.foreground = hex("#ffffff")
_object_10.background = hex("#000000")
_object_10.backgroundTransparency = 0.5
_object_10.foregroundTransparency = 0.5
_object_10.accent = accent
_object_9[_left_9] = _object_10
local _left_10 = "switchButton"
local _object_11 = {}
for _k, _v in pairs(darkTheme.home.server.switchButton) do
	_object_11[_k] = _v
end
_object_11.outlined = false
_object_11.foreground = hex("#ffffff")
_object_11.background = hex("#000000")
_object_11.backgroundTransparency = 0.5
_object_11.foregroundTransparency = 0.5
_object_11.accent = accent
_object_9[_left_10] = _object_11
_object_3[_left_8] = _object_9
local _left_11 = "friendActivity"
local _object_12 = {}
for _k, _v in pairs(darkTheme.home.friendActivity) do
	_object_12[_k] = _v
end
_object_12.acrylic = true
_object_12.outlined = false
_object_12.foreground = hex("#ffffff")
_object_12.background = hex("#000000")
_object_12.dropshadow = hex("#000000")
_object_12.transparency = 0.7
_object_12.dropshadowTransparency = 0.65
local _left_12 = "friendButton"
local _object_13 = {}
for _k, _v in pairs(darkTheme.home.friendActivity.friendButton) do
	_object_13[_k] = _v
end
_object_13.outlined = false
_object_13.foreground = hex("#ffffff")
_object_13.background = hex("#000000")
_object_13.dropshadow = hex("#000000")
_object_13.backgroundTransparency = 0.7
_object_12[_left_12] = _object_13
_object_3[_left_11] = _object_12
_object[_left_2] = _object_3
local _left_13 = "apps"
local _object_14 = {}
local _left_14 = "players"
local _object_15 = {}
for _k, _v in pairs(darkTheme.apps.players) do
	_object_15[_k] = _v
end
_object_15.acrylic = true
_object_15.outlined = false
_object_15.foreground = hex("#ffffff")
_object_15.background = hex("#000000")
_object_15.dropshadow = hex("#000000")
_object_15.transparency = 0.7
_object_15.dropshadowTransparency = 0.65
_object_15.highlight = {
	teleport = accent,
	hide = accent,
	kill = accent,
	spectate = accent,
}
local _left_15 = "avatar"
local _object_16 = {}
for _k, _v in pairs(darkTheme.apps.players.avatar) do
	_object_16[_k] = _v
end
_object_16.background = hex("#000000")
_object_16.transparency = 0.7
_object_16.gradient = {
	color = accentSequence,
}
_object_15[_left_15] = _object_16
local _left_16 = "button"
local _object_17 = {}
for _k, _v in pairs(darkTheme.apps.players.button) do
	_object_17[_k] = _v
end
_object_17.outlined = false
_object_17.foreground = hex("#ffffff")
_object_17.background = hex("#000000")
_object_17.backgroundTransparency = 0.5
_object_15[_left_16] = _object_17
local _left_17 = "playerButton"
local _object_18 = {}
for _k, _v in pairs(darkTheme.apps.players.playerButton) do
	_object_18[_k] = _v
end
_object_18.outlined = false
_object_18.foreground = hex("#ffffff")
_object_18.background = hex("#000000")
_object_18.accent = accent
_object_18.backgroundTransparency = 0.5
_object_18.dropshadowTransparency = 0.7
_object_15[_left_17] = _object_18
_object_14[_left_14] = _object_15
_object[_left_13] = _object_14
local _left_18 = "options"
local _object_19 = {}
local _left_19 = "config"
local _object_20 = {}
for _k, _v in pairs(darkTheme.options.config) do
	_object_20[_k] = _v
end
_object_20.acrylic = true
_object_20.outlined = false
_object_20.foreground = hex("#ffffff")
_object_20.background = hex("#000000")
_object_20.dropshadow = hex("#000000")
_object_20.transparency = 0.7
_object_20.dropshadowTransparency = 0.65
local _left_20 = "configButton"
local _object_21 = {}
for _k, _v in pairs(darkTheme.options.config.configButton) do
	_object_21[_k] = _v
end
_object_21.outlined = false
_object_21.foreground = hex("#ffffff")
_object_21.background = hex("#000000")
_object_21.accent = accent
_object_21.backgroundTransparency = 0.5
_object_21.dropshadowTransparency = 0.7
_object_20[_left_20] = _object_21
_object_19[_left_19] = _object_20
local _left_21 = "shortcuts"
local _object_22 = {}
for _k, _v in pairs(darkTheme.options.shortcuts) do
	_object_22[_k] = _v
end
_object_22.acrylic = true
_object_22.outlined = false
_object_22.foreground = hex("#ffffff")
_object_22.background = hex("#000000")
_object_22.dropshadow = hex("#000000")
_object_22.transparency = 0.7
_object_22.dropshadowTransparency = 0.65
local _left_22 = "shortcutButton"
local _object_23 = {}
for _k, _v in pairs(darkTheme.options.shortcuts.shortcutButton) do
	_object_23[_k] = _v
end
_object_23.outlined = false
_object_23.foreground = hex("#ffffff")
_object_23.background = hex("#000000")
_object_23.accent = accent
_object_23.backgroundTransparency = 0.5
_object_23.dropshadowTransparency = 0.7
_object_22[_left_22] = _object_23
_object_19[_left_21] = _object_22
local _left_23 = "themes"
local _object_24 = {}
for _k, _v in pairs(darkTheme.options.themes) do
	_object_24[_k] = _v
end
_object_24.acrylic = true
_object_24.outlined = false
_object_24.foreground = hex("#ffffff")
_object_24.background = hex("#000000")
_object_24.dropshadow = hex("#000000")
_object_24.transparency = 0.7
_object_24.dropshadowTransparency = 0.65
local _left_24 = "themeButton"
local _object_25 = {}
for _k, _v in pairs(darkTheme.options.themes.themeButton) do
	_object_25[_k] = _v
end
_object_25.outlined = false
_object_25.foreground = hex("#ffffff")
_object_25.background = hex("#000000")
_object_25.accent = accent
_object_25.backgroundTransparency = 0.5
_object_25.dropshadowTransparency = 0.7
_object_24[_left_24] = _object_25
_object_19[_left_23] = _object_24
_object[_left_18] = _object_19
local obsidian = _object
return {
	obsidian = obsidian,
}
 end,Properties={Name="obsidian"},Reference=84,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local darkTheme = TS.import(script, script.Parent, "dark-theme").darkTheme
local hex = TS.import(script, script.Parent.Parent, "utils", "color3").hex
local _object = {}
for _k, _v in pairs(darkTheme) do
	_object[_k] = _v
end
_object.name = "Light theme"
_object.preview = {
	foreground = {
		color = ColorSequence.new(hex("#000000")),
	},
	background = {
		color = ColorSequence.new(hex("#ffffff")),
	},
	accent = {
		color = ColorSequence.new({ ColorSequenceKeypoint.new(0, hex("#F6BD29")), ColorSequenceKeypoint.new(0.5, hex("#F64229")), ColorSequenceKeypoint.new(1, hex("#9029F6")) }),
		rotation = 25,
	},
}
local _left = "navbar"
local _object_1 = {}
for _k, _v in pairs(darkTheme.navbar) do
	_object_1[_k] = _v
end
_object_1.foreground = hex("#000000")
_object_1.background = hex("#ffffff")
_object[_left] = _object_1
local _left_1 = "clock"
local _object_2 = {}
for _k, _v in pairs(darkTheme.clock) do
	_object_2[_k] = _v
end
_object_2.foreground = hex("#000000")
_object_2.background = hex("#ffffff")
_object[_left_1] = _object_2
local _left_2 = "home"
local _object_3 = {}
local _left_3 = "title"
local _object_4 = {}
for _k, _v in pairs(darkTheme.home.title) do
	_object_4[_k] = _v
end
_object_4.foreground = hex("#000000")
_object_4.background = hex("#ffffff")
_object_3[_left_3] = _object_4
local _left_4 = "profile"
local _object_5 = {}
for _k, _v in pairs(darkTheme.home.profile) do
	_object_5[_k] = _v
end
_object_5.foreground = hex("#000000")
_object_5.background = hex("#ffffff")
local _left_5 = "avatar"
local _object_6 = {}
for _k, _v in pairs(darkTheme.home.profile.avatar) do
	_object_6[_k] = _v
end
_object_6.background = hex("#000000")
_object_6.transparency = 0.9
_object_6.gradient = {
	color = ColorSequence.new(hex("#3ce09b")),
}
_object_5[_left_5] = _object_6
local _left_6 = "slider"
local _object_7 = {}
for _k, _v in pairs(darkTheme.home.profile.slider) do
	_object_7[_k] = _v
end
_object_7.foreground = hex("#000000")
_object_7.background = hex("#ffffff")
_object_5[_left_6] = _object_7
local _left_7 = "button"
local _object_8 = {}
for _k, _v in pairs(darkTheme.home.profile.button) do
	_object_8[_k] = _v
end
_object_8.foreground = hex("#000000")
_object_8.background = hex("#ffffff")
_object_5[_left_7] = _object_8
_object_3[_left_4] = _object_5
local _left_8 = "server"
local _object_9 = {}
for _k, _v in pairs(darkTheme.home.server) do
	_object_9[_k] = _v
end
_object_9.foreground = hex("#000000")
_object_9.background = hex("#ff3f6c")
_object_9.dropshadow = hex("#ff3f6c")
local _left_9 = "rejoinButton"
local _object_10 = {}
for _k, _v in pairs(darkTheme.home.server.rejoinButton) do
	_object_10[_k] = _v
end
_object_10.foreground = hex("#000000")
_object_10.background = hex("#ff3f6c")
_object_10.accent = hex("#ffffff")
_object_9[_left_9] = _object_10
local _left_10 = "switchButton"
local _object_11 = {}
for _k, _v in pairs(darkTheme.home.server.switchButton) do
	_object_11[_k] = _v
end
_object_11.foreground = hex("#000000")
_object_11.background = hex("#ff3f6c")
_object_11.accent = hex("#ffffff")
_object_9[_left_10] = _object_11
_object_3[_left_8] = _object_9
local _left_11 = "friendActivity"
local _object_12 = {}
for _k, _v in pairs(darkTheme.home.friendActivity) do
	_object_12[_k] = _v
end
_object_12.foreground = hex("#000000")
_object_12.background = hex("#ffffff")
local _left_12 = "friendButton"
local _object_13 = {}
for _k, _v in pairs(darkTheme.home.friendActivity.friendButton) do
	_object_13[_k] = _v
end
_object_13.foreground = hex("#ffffff")
_object_13.background = hex("#ffffff")
_object_12[_left_12] = _object_13
_object_3[_left_11] = _object_12
_object[_left_2] = _object_3
local _left_13 = "apps"
local _object_14 = {}
local _left_14 = "players"
local _object_15 = {}
for _k, _v in pairs(darkTheme.apps.players) do
	_object_15[_k] = _v
end
_object_15.foreground = hex("#000000")
_object_15.background = hex("#ffffff")
local _left_15 = "avatar"
local _object_16 = {}
for _k, _v in pairs(darkTheme.apps.players.avatar) do
	_object_16[_k] = _v
end
_object_16.background = hex("#000000")
_object_16.transparency = 0.9
_object_16.gradient = {
	color = ColorSequence.new(hex("#3ce09b")),
}
_object_15[_left_15] = _object_16
local _left_16 = "button"
local _object_17 = {}
for _k, _v in pairs(darkTheme.apps.players.button) do
	_object_17[_k] = _v
end
_object_17.foreground = hex("#000000")
_object_17.background = hex("#ffffff")
_object_15[_left_16] = _object_17
local _left_17 = "playerButton"
local _object_18 = {}
for _k, _v in pairs(darkTheme.apps.players.playerButton) do
	_object_18[_k] = _v
end
_object_18.foreground = hex("#000000")
_object_18.background = hex("#ffffff")
_object_18.backgroundHovered = hex("#eeeeee")
_object_18.accent = hex("#3ce09b")
_object_18.dropshadowTransparency = 0.7
_object_15[_left_17] = _object_18
_object_14[_left_14] = _object_15
_object[_left_13] = _object_14
local _left_18 = "options"
local _object_19 = {}
local _left_19 = "config"
local _object_20 = {}
for _k, _v in pairs(darkTheme.options.config) do
	_object_20[_k] = _v
end
_object_20.foreground = hex("#000000")
_object_20.background = hex("#ffffff")
local _left_20 = "configButton"
local _object_21 = {}
for _k, _v in pairs(darkTheme.options.config.configButton) do
	_object_21[_k] = _v
end
_object_21.foreground = hex("#000000")
_object_21.background = hex("#ffffff")
_object_21.backgroundHovered = hex("#eeeeee")
_object_21.accent = hex("#3ce09b")
_object_21.dropshadowTransparency = 0.7
_object_20[_left_20] = _object_21
_object_19[_left_19] = _object_20
local _left_21 = "shortcuts"
local _object_22 = {}
for _k, _v in pairs(darkTheme.options.shortcuts) do
	_object_22[_k] = _v
end
_object_22.foreground = hex("#000000")
_object_22.background = hex("#ffffff")
local _left_22 = "shortcutButton"
local _object_23 = {}
for _k, _v in pairs(darkTheme.options.shortcuts.shortcutButton) do
	_object_23[_k] = _v
end
_object_23.foreground = hex("#000000")
_object_23.background = hex("#ffffff")
_object_23.backgroundHovered = hex("#eeeeee")
_object_23.accent = hex("#3ce09b")
_object_23.dropshadowTransparency = 0.7
_object_22[_left_22] = _object_23
_object_19[_left_21] = _object_22
local _left_23 = "themes"
local _object_24 = {}
for _k, _v in pairs(darkTheme.options.themes) do
	_object_24[_k] = _v
end
_object_24.foreground = hex("#000000")
_object_24.background = hex("#ffffff")
local _left_24 = "themeButton"
local _object_25 = {}
for _k, _v in pairs(darkTheme.options.themes.themeButton) do
	_object_25[_k] = _v
end
_object_25.foreground = hex("#000000")
_object_25.background = hex("#ffffff")
_object_25.backgroundHovered = hex("#eeeeee")
_object_25.accent = hex("#3ce09b")
_object_25.dropshadowTransparency = 0.7
_object_24[_left_24] = _object_25
_object_19[_left_23] = _object_24
_object[_left_18] = _object_19
local lightTheme = _object
return {
	lightTheme = lightTheme,
}
 end,Properties={Name="light-theme"},Reference=83,ClassName="ModuleScript"}}},{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local HttpService = TS.import(script, TS.getModule(script, "@rbxts", "services")).HttpService
local IS_DEV = TS.import(script, script.Parent.Parent, "constants").IS_DEV
local request
request = TS.async(function(requestOptions)
	if IS_DEV then
		return HttpService:RequestAsync(requestOptions)
	else
		local fn = syn and syn.request or request
		if not fn then
			error("request/syn.request is not available")
		end
		return fn(requestOptions)
	end
end)
local get = TS.async(function(url, requestType)
	return game:HttpGetAsync(url, requestType)
end)
local post = TS.async(function(url, data, contentType, requestType)
	return game:HttpPostAsync(url, data, contentType, requestType)
end)
return {
	request = request,
	get = get,
	post = post,
}
 end,Properties={Name="http"},Reference=92,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local Timeout
do
	Timeout = setmetatable({}, {
		__tostring = function()
			return "Timeout"
		end,
	})
	Timeout.__index = Timeout
	function Timeout.new(...)
		local self = setmetatable({}, Timeout)
		return self:constructor(...) or self
	end
	function Timeout:constructor(callback, milliseconds, ...)
		local args = { ... }
		self.running = true
		task.delay(milliseconds / 1000, function()
			if self.running then
				callback(unpack(args))
			end
		end)
	end
	function Timeout:clear()
		self.running = false
	end
end
local function setTimeout(callback, milliseconds, ...)
	local args = { ... }
	return Timeout.new(callback, milliseconds, unpack(args))
end
local function clearTimeout(timeout)
	timeout:clear()
end
local Interval
do
	Interval = setmetatable({}, {
		__tostring = function()
			return "Interval"
		end,
	})
	Interval.__index = Interval
	function Interval.new(...)
		local self = setmetatable({}, Interval)
		return self:constructor(...) or self
	end
	function Interval:constructor(callback, milliseconds, ...)
		local args = { ... }
		self.running = true
		task.defer(function()
			local clock = 0
			local hb
			hb = RunService.Heartbeat:Connect(function(step)
				clock += step
				if not self.running then
					hb:Disconnect()
				elseif clock >= milliseconds / 1000 then
					clock -= milliseconds / 1000
					callback(unpack(args))
				end
			end)
		end)
	end
	function Interval:clear()
		self.running = false
	end
end
local function setInterval(callback, milliseconds, ...)
	local args = { ... }
	return Interval.new(callback, milliseconds, unpack(args))
end
local function clearInterval(interval)
	interval:clear()
end
return {
	setTimeout = setTimeout,
	clearTimeout = clearTimeout,
	setInterval = setInterval,
	clearInterval = clearInterval,
	Timeout = Timeout,
	Interval = Interval,
}
 end,Properties={Name="timeout"},Reference=94,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local function map(n, min0, max0, min1, max1)
	return min1 + ((n - min0) * (max1 - min1)) / (max0 - min0)
end
local function lerp(a, b, t)
	return a + (b - a) * t
end
return {
	map = map,
	lerp = lerp,
}
 end,Properties={Name="number-util"},Reference=93,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local function px(x, y)
	return UDim2.new(0, x, 0, y)
end
local function scale(x, y)
	return UDim2.new(x, 0, y, 0)
end
local function applyUDim2(size, udim2, scaleFactor)
	if scaleFactor == nil then
		scaleFactor = 1
	end
	return Vector2.new(udim2.X.Offset + (udim2.X.Scale / scaleFactor) * size.X, udim2.Y.Offset + (udim2.Y.Scale / scaleFactor) * size.Y)
end
return {
	px = px,
	scale = scale,
	applyUDim2 = applyUDim2,
}
 end,Properties={Name="udim2"},Reference=95,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local clock = os.clock()
local clockName = "clock"
local debugCounter = {}
local function startTimer(name)
	local _condition = debugCounter[name]
	if _condition == nil then
		_condition = 0
	end
	debugCounter[name] = _condition + 1
	clockName = name
	clock = os.clock()
end
local function endTimer()
	local diff = os.clock() - clock
	local _condition = debugCounter[clockName]
	if _condition == nil then
		_condition = 0
	end
	local count = _condition
	print("\n[" .. (clockName .. (" " .. (tostring(count) .. ("]\n" .. (tostring(diff * 1000) .. " ms\n\n"))))))
end
return {
	startTimer = startTimer,
	endTimer = endTimer,
}
 end,Properties={Name="debug"},Reference=91,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local function getLuminance(color)
	if typeof(color) == "ColorSequence" then
		color = color.Keypoints[1].Value
	end
	return color.R * 0.2126 + color.G * 0.7152 + color.B * 0.0722
end
local function getColorInSequence(sequence, alpha)
	local index = math.floor(alpha * (#sequence.Keypoints - 1))
	local nextIndex = math.min(index + 1, #sequence.Keypoints - 1)
	local _condition = sequence.Keypoints[index + 1]
	if _condition == nil then
		_condition = sequence.Keypoints[1]
	end
	local keypoint = _condition
	local _condition_1 = sequence.Keypoints[nextIndex + 1]
	if _condition_1 == nil then
		_condition_1 = keypoint
	end
	local nextKeypoint = _condition_1
	return keypoint.Value:Lerp(nextKeypoint.Value, alpha * (#sequence.Keypoints - 1) - index)
end
local hexStringToInt = function(hex)
	local newHex = string.gsub(hex, "#", "0x", 1)
	local _condition = tonumber(newHex)
	if _condition == nil then
		_condition = 0
	end
	return _condition
end
local intToColor3 = function(i)
	return Color3.fromRGB(math.floor(i / 65536) % 256, math.floor(i / 256) % 256, i % 256)
end
local hex = function(hex)
	return intToColor3(hexStringToInt(hex))
end
local rgb = function(r, g, b)
	return Color3.fromRGB(r, g, b)
end
local hsv = function(h, s, v)
	return Color3.fromHSV(h / 360, s / 100, v / 100)
end
local hsl = function(h, s, l)
	local hsv1 = (s * (l < 50 and l or 100 - l)) / 100
	local hsvS = hsv1 == 0 and 0 or ((2 * hsv1) / (l + hsv1)) * 100
	local hsvV = l + hsv1
	return Color3.fromHSV(h / 255, hsvS / 100, hsvV / 100)
end
return {
	getLuminance = getLuminance,
	getColorInSequence = getColorInSequence,
	hex = hex,
	rgb = rgb,
	hsv = hsv,
	hsl = hsl,
}
 end,Properties={Name="color3"},Reference=90,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local function arrayToMap(arr, mapper)
	-- \226\150\188 ReadonlyArray.map \226\150\188
	local _newValue = table.create(#arr)
	for _k, _v in ipairs(arr) do
		_newValue[_k] = mapper(_v, _k - 1, arr)
	end
	-- \226\150\178 ReadonlyArray.map \226\150\178
	local _map = {}
	for _, _v in ipairs(_newValue) do
		_map[_v[1]] = _v[2]
	end
	return _map
end
return {
	arrayToMap = arrayToMap,
}
 end,Properties={Name="array-util"},Reference=88,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local function isBinding(binding)
	return type(binding) == "table" and binding.getValue ~= nil
end
local function mapBinding(value, transform)
	return isBinding(value) and value:map(transform) or (Roact.createBinding(transform(value)))
end
local function asBinding(value)
	return isBinding(value) and value or (Roact.createBinding(value))
end
return {
	isBinding = isBinding,
	mapBinding = mapBinding,
	asBinding = asBinding,
}
 end,Properties={Name="binding-util"},Reference=89,ClassName="ModuleScript"}},Properties={Name="utils"},Reference=87,ClassName="Folder"},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.include.RuntimeLib)
local exports = {}
exports.setStore = TS.import(script, script, "helpers", "job-store").setStore
return exports
 end,Properties={Name="jobs"},Reference=44,Children={{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local Workspace = _services.Workspace
local getSelectedPlayer = TS.import(script, script.Parent.Parent, "helpers", "get-selected-player").getSelectedPlayer
local _job_store = TS.import(script, script.Parent.Parent, "helpers", "job-store")
local getStore = _job_store.getStore
local onJobChange = _job_store.onJobChange
local setJobActive = TS.import(script, script.Parent.Parent.Parent, "store", "actions", "jobs.action").setJobActive
local player = Players.LocalPlayer
local attachToVictim = TS.async(function(victim)
	local backpack = player:FindFirstChildWhichIsA("Backpack")
	if not backpack then
		error("No inventory found")
	end
	local playerCharacter = player.Character
	local victimCharacter = victim.Character
	if not playerCharacter or not victimCharacter then
		error("Victim or local player has no character")
	end
	local playerHumanoid = playerCharacter:FindFirstChildWhichIsA("Humanoid")
	local playerRootPart = playerCharacter:FindFirstChild("HumanoidRootPart")
	local victimRootPart = victimCharacter:FindFirstChild("HumanoidRootPart")
	if not playerHumanoid or (not playerRootPart or not victimRootPart) then
		error("Victim or local player has no Humanoid or root part")
	end
	local _array = {}
	local _length = #_array
	local _array_1 = playerCharacter:GetChildren()
	local _Length = #_array_1
	table.move(_array_1, 1, _Length, _length + 1, _array)
	_length += _Length
	local _array_2 = backpack:GetChildren()
	table.move(_array_2, 1, #_array_2, _length + 1, _array)
	local _arg0 = function(obj)
		return obj:IsA("Tool") and obj:FindFirstChild("Handle") ~= nil
	end
	-- \226\150\188 ReadonlyArray.find \226\150\188
	local _result = nil
	for _i, _v in ipairs(_array) do
		if _arg0(_v, _i - 1, _array) == true then
			_result = _v
			break
		end
	end
	-- \226\150\178 ReadonlyArray.find \226\150\178
	local tool = _result
	if not tool then
		error("A tool with a handle is required to kill this victim")
	end
	playerHumanoid.Name = ""
	local mockHumanoid = playerHumanoid:Clone()
	mockHumanoid.DisplayName = utf8.char(128298)
	mockHumanoid.Parent = playerCharacter
	mockHumanoid.Name = "Humanoid"
	task.wait()
	playerHumanoid:Destroy()
	Workspace.CurrentCamera.CameraSubject = mockHumanoid
	tool.Parent = playerCharacter
	do
		local count = 0
		local _shouldIncrement = false
		while true do
			if _shouldIncrement then
				count += 1
			else
				_shouldIncrement = true
			end
			if not (count < 250) then
				break
			end
			if victimRootPart.Parent ~= victimCharacter or playerRootPart.Parent ~= playerCharacter then
				error("Victim or local player has no root part; did a player respawn?")
			end
			if tool.Parent ~= playerCharacter then
				return playerRootPart
			end
			playerRootPart.CFrame = victimRootPart.CFrame
			task.wait(0.1)
		end
	end
	error("Failed to attach to victim")
end)
local bringVictimToVoid = TS.async(function(victim)
	local store = TS.await(getStore())
	local _oldRootPart = player.Character
	if _oldRootPart ~= nil then
		_oldRootPart = _oldRootPart:FindFirstChild("HumanoidRootPart")
	end
	local oldRootPart = _oldRootPart
	local _result = oldRootPart
	if _result ~= nil then
		_result = _result:IsA("BasePart")
	end
	local location = _result and oldRootPart.CFrame or nil
	store:dispatch(setJobActive("refresh", true))
	TS.await(TS.Promise.fromEvent(player.CharacterAdded, function(character)
		return character:WaitForChild("HumanoidRootPart", 5) ~= nil
	end))
	task.wait(0.3)
	local rootPart = TS.await(attachToVictim(victim))
	local _binding = { victim.Character, player.Character }
	local victimCharacter = _binding[1]
	local playerCharacter = _binding[2]
	repeat
		do
			task.wait(0.1)
			rootPart.CFrame = CFrame.new(1000000, Workspace.FallenPartsDestroyHeight + 5, 1000000)
		end
		local _result_1 = victimCharacter
		if _result_1 ~= nil then
			_result_1 = _result_1:FindFirstChild("HumanoidRootPart")
		end
		local _condition = _result_1 ~= nil
		if _condition then
			local _result_2 = playerCharacter
			if _result_2 ~= nil then
				_result_2 = _result_2:FindFirstChild("HumanoidRootPart")
			end
			_condition = _result_2 ~= nil
		end
	until not _condition
	local newCharacter = TS.await(TS.Promise.fromEvent(player.CharacterAdded, function(character)
		return character:WaitForChild("HumanoidRootPart", 5) ~= nil
	end))
	if location then
		newCharacter.HumanoidRootPart.CFrame = location
	end
end)
local main = TS.async(function()
	local store = TS.await(getStore())
	local playerSelected = TS.await(getSelectedPlayer())
	TS.await(onJobChange("kill", function(job)
		if job.active then
			if not playerSelected.current then
				store:dispatch(setJobActive("kill", false))
				return nil
			end
			bringVictimToVoid(playerSelected.current):catch(function(err)
				return warn("[kill-worker] " .. tostring(err))
			end):finally(function()
				return store:dispatch(setJobActive("kill", false))
			end)
		end
	end))
end)
main():catch(function(err)
	warn("[kill-worker] " .. tostring(err))
end)
 end,Properties={Name="kill"},Reference=59,ClassName="LocalScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local getSelectedPlayer = TS.import(script, script.Parent.Parent, "helpers", "get-selected-player").getSelectedPlayer
local _job_store = TS.import(script, script.Parent.Parent, "helpers", "job-store")
local getStore = _job_store.getStore
local onJobChange = _job_store.onJobChange
local setJobActive = TS.import(script, script.Parent.Parent.Parent, "store", "actions", "jobs.action").setJobActive
local current = {}
local function hide(player)
	if current[player] ~= nil then
		return nil
	end
	local character = player.Character
	local data
	data = {
		character = character,
		parent = character.Parent,
		handle = player.CharacterAdded:Connect(function(newCharacter)
			newCharacter.Parent = nil
			data.character = character
		end),
	}
	-- \226\150\188 Map.set \226\150\188
	current[player] = data
	-- \226\150\178 Map.set \226\150\178
	character.Parent = nil
end
local function unhide(player, setParent)
	if not (current[player] ~= nil) then
		return nil
	end
	local data = current[player]
	if setParent then
		data.character.Parent = data.parent
	end
	data.handle:Disconnect()
	-- \226\150\188 Map.delete \226\150\188
	current[player] = nil
	-- \226\150\178 Map.delete \226\150\178
end
local main = TS.async(function()
	local store = TS.await(getStore())
	local playerSelected = TS.await(getSelectedPlayer(function(player)
		local _fn = store
		local _result
		if player then
			_result = current[player] ~= nil
		else
			_result = false
		end
		_fn:dispatch(setJobActive("hide", _result))
	end))
	Players.PlayerRemoving:Connect(function(player)
		if player == playerSelected.current then
			store:dispatch(setJobActive("hide", false))
		else
			unhide(player, false)
		end
	end)
	TS.await(onJobChange("hide", function(job)
		local player = playerSelected.current
		if not player then
			store:dispatch(setJobActive("hide", false))
			return nil
		end
		if job.active and player.Character then
			hide(player)
		elseif not job.active then
			unhide(player, true)
		end
	end))
end)
main():catch(function(err)
	warn("[hide-worker] " .. tostring(err))
end)
 end,Properties={Name="hide"},Reference=58,ClassName="LocalScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local getSelectedPlayer = TS.import(script, script.Parent.Parent, "helpers", "get-selected-player").getSelectedPlayer
local _job_store = TS.import(script, script.Parent.Parent, "helpers", "job-store")
local getStore = _job_store.getStore
local onJobChange = _job_store.onJobChange
local setJobActive = TS.import(script, script.Parent.Parent.Parent, "store", "actions", "jobs.action").setJobActive
local setTimeout = TS.import(script, script.Parent.Parent.Parent, "utils", "timeout").setTimeout
local main = TS.async(function()
	local store = TS.await(getStore())
	local playerSelected = TS.await(getSelectedPlayer(function()
		store:dispatch(setJobActive("teleport", false))
	end))
	local timeout
	TS.await(onJobChange("teleport", function(job)
		local _result = timeout
		if _result ~= nil then
			_result:clear()
		end
		timeout = nil
		if job.active then
			local _rootPart = Players.LocalPlayer.Character
			if _rootPart ~= nil then
				_rootPart = _rootPart:FindFirstChild("HumanoidRootPart")
			end
			local rootPart = _rootPart
			local _targetRootPart = playerSelected.current
			if _targetRootPart ~= nil then
				_targetRootPart = _targetRootPart.Character
				if _targetRootPart ~= nil then
					_targetRootPart = _targetRootPart:FindFirstChild("HumanoidRootPart")
				end
			end
			local targetRootPart = _targetRootPart
			if not targetRootPart or (not rootPart or (not rootPart:IsA("BasePart") or not targetRootPart:IsA("BasePart"))) then
				store:dispatch(setJobActive("teleport", false))
				warn("[teleport-worker] Failed to find root parts (" .. (tostring(rootPart) .. (" -> " .. (tostring(targetRootPart) .. ")"))))
				return nil
			end
			timeout = setTimeout(function()
				store:dispatch(setJobActive("teleport", false))
				local _cFrame = targetRootPart.CFrame
				local _cFrame_1 = CFrame.new(0, 0, 1)
				rootPart.CFrame = _cFrame * _cFrame_1
			end, 1000)
		end
	end))
end)
main():catch(function(err)
	warn("[teleport-worker] " .. tostring(err))
end)
 end,Properties={Name="teleport"},Reference=61,ClassName="LocalScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Workspace = TS.import(script, TS.getModule(script, "@rbxts", "services")).Workspace
local getSelectedPlayer = TS.import(script, script.Parent.Parent, "helpers", "get-selected-player").getSelectedPlayer
local _job_store = TS.import(script, script.Parent.Parent, "helpers", "job-store")
local getStore = _job_store.getStore
local onJobChange = _job_store.onJobChange
local setJobActive = TS.import(script, script.Parent.Parent.Parent, "store", "actions", "jobs.action").setJobActive
local main = TS.async(function()
	local store = TS.await(getStore())
	local playerSelected = TS.await(getSelectedPlayer(function()
		store:dispatch(setJobActive("spectate", false))
	end))
	local shouldResetCameraSubject = false
	local currentSubject
	local defaultSubject
	local function connectCameraSubject(camera)
		camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			if currentSubject ~= camera.CameraSubject and store:getState().jobs.spectate.active then
				shouldResetCameraSubject = false
				store:dispatch(setJobActive("spectate", false))
			end
		end)
	end
	Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		connectCameraSubject(Workspace.CurrentCamera)
	end)
	connectCameraSubject(Workspace.CurrentCamera)
	TS.await(onJobChange("spectate", function(job)
		local camera = Workspace.CurrentCamera
		if job.active then
			local _cameraSubject = playerSelected.current
			if _cameraSubject ~= nil then
				_cameraSubject = _cameraSubject.Character
				if _cameraSubject ~= nil then
					_cameraSubject = _cameraSubject:FindFirstChildWhichIsA("Humanoid")
				end
			end
			local cameraSubject = _cameraSubject
			if not cameraSubject then
				store:dispatch(setJobActive("spectate", false))
			else
				shouldResetCameraSubject = true
				defaultSubject = camera.CameraSubject
				currentSubject = cameraSubject
				camera.CameraSubject = cameraSubject
			end
		elseif shouldResetCameraSubject then
			shouldResetCameraSubject = false
			camera.CameraSubject = defaultSubject
			defaultSubject = nil
			currentSubject = nil
		end
	end))
end)
main():catch(function(err)
	warn("[spectate-worker] " .. tostring(err))
end)
 end,Properties={Name="spectate"},Reference=60,ClassName="LocalScript"}},Properties={Name="players"},Reference=57,ClassName="Folder"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local HttpService = _services.HttpService
local Players = _services.Players
local TeleportService = _services.TeleportService
local _job_store = TS.import(script, script.Parent, "helpers", "job-store")
local getStore = _job_store.getStore
local onJobChange = _job_store.onJobChange
local setJobActive = TS.import(script, script.Parent.Parent, "store", "actions", "jobs.action").setJobActive
local http = TS.import(script, script.Parent.Parent, "utils", "http")
local setTimeout = TS.import(script, script.Parent.Parent, "utils", "timeout").setTimeout
local queueExecution
local onServerHop = TS.async(function()
	queueExecution()
	local servers = HttpService:JSONDecode(TS.await(http.get("https://games.roblox.com/v1/games/" .. (tostring(game.PlaceId) .. "/servers/Public?sortOrder=Asc&limit=100"))))
	local _data = servers.data
	local _arg0 = function(server)
		return server.playing < server.maxPlayers and server.id ~= game.JobId
	end
	-- \226\150\188 ReadonlyArray.filter \226\150\188
	local _newValue = {}
	local _length = 0
	for _k, _v in ipairs(_data) do
		if _arg0(_v, _k - 1, _data) == true then
			_length += 1
			_newValue[_length] = _v
		end
	end
	-- \226\150\178 ReadonlyArray.filter \226\150\178
	local serversAvailable = _newValue
	if #serversAvailable == 0 then
		error("[server-worker-switch] No servers available.")
	else
		local server = serversAvailable[math.random(#serversAvailable - 1) + 1]
		TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id)
	end
end)
local onRejoin = TS.async(function()
	queueExecution()
	if #Players:GetPlayers() == 1 then
		TeleportService:Teleport(game.PlaceId, Players.LocalPlayer)
	else
		TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
	end
end)
function queueExecution()
	local isRelease = { string.match(VERSION, "^.+%..+%..+$") } ~= nil
	local code = isRelease and 'loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/richie0866/orca/master/public/latest.lua"))()' or 'loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/richie0866/orca/master/public/snapshot.lua"))()'
	local _result = syn
	if _result ~= nil then
		_result = _result.queue_on_teleport
	end
	local _condition = _result
	if _condition == nil then
		_condition = queue_on_teleport
	end
	local _result_1 = _condition
	if _result_1 ~= nil then
		_result_1(code)
	end
end
local main = TS.async(function()
	local store = TS.await(getStore())
	local timeout
	local function clearTimeout()
		local _result = timeout
		if _result ~= nil then
			_result:clear()
		end
		timeout = nil
	end
	TS.await(onJobChange("rejoinServer", function(job, state)
		clearTimeout()
		if state.jobs.switchServer.active then
			setJobActive("switchServer", false)
		end
		if job.active then
			timeout = setTimeout(function()
				onRejoin():catch(function(err)
					warn("[server-worker-rejoin] " .. tostring(err))
					store:dispatch(setJobActive("rejoinServer", false))
				end)
			end, 1000)
		end
	end))
	TS.await(onJobChange("switchServer", function(job, state)
		clearTimeout()
		if state.jobs.rejoinServer.active then
			setJobActive("rejoinServer", false)
		end
		if job.active then
			timeout = setTimeout(function()
				onServerHop():catch(function(err)
					warn("[server-worker-switch] " .. tostring(err))
					store:dispatch(setJobActive("switchServer", false))
				end)
			end, 1000)
		end
	end))
end)
main():catch(function(err)
	warn("[server-worker] " .. tostring(err))
end)
 end,Properties={Name="server"},Reference=62,ClassName="LocalScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local _freecam = TS.import(script, script.Parent, "helpers", "freecam")
local DisableFreecam = _freecam.DisableFreecam
local EnableFreecam = _freecam.EnableFreecam
local onJobChange = TS.import(script, script.Parent, "helpers", "job-store").onJobChange
local main = TS.async(function()
	TS.await(onJobChange("freecam", function(job)
		if job.active then
			EnableFreecam()
		else
			DisableFreecam()
		end
	end))
end)
main():catch(function(err)
	warn("[freecam-worker] " .. tostring(err))
end)
 end,Properties={Name="freecam"},Reference=52,ClassName="LocalScript"},{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local getStore = TS.import(script, script.Parent, "job-store").getStore
local getSelectedPlayer = TS.async(function(onChange)
	local store = TS.await(getStore())
	local playerSelected = {
		current = nil,
	}
	store.changed:connect(function(newState)
		local name = newState.dashboard.apps.playerSelected
		local _result = playerSelected.current
		if _result ~= nil then
			_result = _result.Name
		end
		if _result ~= name then
			playerSelected.current = name ~= nil and (Players:FindFirstChild(name)) or nil
			if onChange then
				task.defer(onChange, playerSelected.current)
			end
		end
	end)
	return playerSelected
end)
return {
	getSelectedPlayer = getSelectedPlayer,
}
 end,Properties={Name="get-selected-player"},Reference=55,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local setInterval = TS.import(script, script.Parent.Parent.Parent, "utils", "timeout").setInterval
local store = {}
local function setStore(newStore)
	if store.current then
		error("Store has already been set")
	end
	store.current = newStore
end
local getStore = TS.async(function()
	if store.current then
		return store.current
	end
	return TS.Promise.new(function(resolve, _, onCancel)
		local interval
		interval = setInterval(function()
			if store.current then
				resolve(store.current)
				interval:clear()
			end
		end, 100)
		onCancel(function()
			interval:clear()
		end)
	end)
end)
local shallowEqual
local onJobChange = TS.async(function(jobName, callback)
	local store = TS.await(getStore())
	local lastJob = store:getState().jobs[jobName]
	return store.changed:connect(function(newState)
		local job = newState.jobs[jobName]
		if not shallowEqual(job, lastJob) then
			lastJob = job
			task.defer(callback, job, newState)
		end
	end)
end)
function shallowEqual(a, b)
	for key in pairs(a) do
		if a[key] ~= b[key] then
			return false
		end
	end
	return true
end
return {
	setStore = setStore,
	getStore = getStore,
	onJobChange = onJobChange,
}
 end,Properties={Name="job-store"},Reference=56,ClassName="ModuleScript"},{Closure=function() ------------------------------------------------------------------------
-- Freecam
-- Cinematic free camera for spectating and video production.
------------------------------------------------------------------------

local pi    = math.pi
local abs   = math.abs
local clamp = math.clamp
local exp   = math.exp
local rad   = math.rad
local sign  = math.sign
local sqrt  = math.sqrt
local tan   = math.tan

local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
	Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
	LocalPlayer = Players.LocalPlayer
end

local Camera = Workspace.CurrentCamera
Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	local newCamera = Workspace.CurrentCamera
	if newCamera then
		Camera = newCamera
	end
end)

------------------------------------------------------------------------

local TOGGLE_INPUT_PRIORITY = Enum.ContextActionPriority.Low.Value
local INPUT_PRIORITY = Enum.ContextActionPriority.High.Value
local FREECAM_MACRO_KB = {Enum.KeyCode.LeftShift, Enum.KeyCode.P}

local FREECAM_RENDER_ID = game:GetService("HttpService"):GenerateGUID(false)

local NAV_GAIN = Vector3.new(1, 1, 1)*64
local PAN_GAIN = Vector2.new(0.75, 1)*8
local FOV_GAIN = 300

local PITCH_LIMIT = rad(90)

local VEL_STIFFNESS = 2.0
local PAN_STIFFNESS = 3.0
local FOV_STIFFNESS = 4.0

------------------------------------------------------------------------

local Spring = {} do
	Spring.__index = Spring

	function Spring.new(freq, pos)
		local self = setmetatable({}, Spring)
		self.f = freq
		self.p = pos
		self.v = pos*0
		return self
	end

	function Spring:Update(dt, goal)
		local f = self.f*2*pi
		local p0 = self.p
		local v0 = self.v

		local offset = goal - p0
		local decay = exp(-f*dt)

		local p1 = goal + (v0*dt - offset*(f*dt + 1))*decay
		local v1 = (f*dt*(offset*f - v0) + v0)*decay

		self.p = p1
		self.v = v1

		return p1
	end

	function Spring:Reset(pos)
		self.p = pos
		self.v = pos*0
	end
end

------------------------------------------------------------------------

local cameraPos = Vector3.new()
local cameraRot = Vector2.new()
local cameraFov = 0

local velSpring = Spring.new(VEL_STIFFNESS, Vector3.new())
local panSpring = Spring.new(PAN_STIFFNESS, Vector2.new())
local fovSpring = Spring.new(FOV_STIFFNESS, 0)

------------------------------------------------------------------------

local Input = {} do
	local thumbstickCurve do
		local K_CURVATURE = 2.0
		local K_DEADZONE = 0.15

		local function fCurve(x)
			return (exp(K_CURVATURE*x) - 1)/(exp(K_CURVATURE) - 1)
		end

		local function fDeadzone(x)
			return fCurve((x - K_DEADZONE)/(1 - K_DEADZONE))
		end

		function thumbstickCurve(x)
			return sign(x)*clamp(fDeadzone(abs(x)), 0, 1)
		end
	end

	local gamepad = {
		ButtonX = 0,
		ButtonY = 0,
		DPadDown = 0,
		DPadUp = 0,
		ButtonL2 = 0,
		ButtonR2 = 0,
		Thumbstick1 = Vector2.new(),
		Thumbstick2 = Vector2.new(),
	}

	local keyboard = {
		W = 0,
		A = 0,
		S = 0,
		D = 0,
		E = 0,
		Q = 0,
		U = 0,
		H = 0,
		J = 0,
		K = 0,
		I = 0,
		Y = 0,
		Up = 0,
		Down = 0,
		LeftShift = 0,
		RightShift = 0,
	}

	local mouse = {
		Delta = Vector2.new(),
		MouseWheel = 0,
	}

	local NAV_GAMEPAD_SPEED  = Vector3.new(1, 1, 1)
	local NAV_KEYBOARD_SPEED = Vector3.new(1, 1, 1)
	local PAN_MOUSE_SPEED    = Vector2.new(1, 1)*(pi/64)
	local PAN_GAMEPAD_SPEED  = Vector2.new(1, 1)*(pi/8)
	local FOV_WHEEL_SPEED    = 1.0
	local FOV_GAMEPAD_SPEED  = 0.25
	local NAV_ADJ_SPEED      = 0.75
	local NAV_SHIFT_MUL      = 0.25

	local navSpeed = 1

	function Input.Vel(dt)
		navSpeed = clamp(navSpeed + dt*(keyboard.Up - keyboard.Down)*NAV_ADJ_SPEED, 0.01, 4)

		local kGamepad = Vector3.new(
			thumbstickCurve(gamepad.Thumbstick1.X),
			thumbstickCurve(gamepad.ButtonR2) - thumbstickCurve(gamepad.ButtonL2),
			thumbstickCurve(-gamepad.Thumbstick1.Y)
		)*NAV_GAMEPAD_SPEED

		local kKeyboard = Vector3.new(
			keyboard.D - keyboard.A + keyboard.K - keyboard.H,
			keyboard.E - keyboard.Q + keyboard.I - keyboard.Y,
			keyboard.S - keyboard.W + keyboard.J - keyboard.U
		)*NAV_KEYBOARD_SPEED

		local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift)

		return (kGamepad + kKeyboard)*(navSpeed*(shift and NAV_SHIFT_MUL or 1))
	end

	function Input.Pan(dt)
		local kGamepad = Vector2.new(
			thumbstickCurve(gamepad.Thumbstick2.Y),
			thumbstickCurve(-gamepad.Thumbstick2.X)
		)*PAN_GAMEPAD_SPEED
		local kMouse = mouse.Delta*PAN_MOUSE_SPEED/(dt*60)
		mouse.Delta = Vector2.new()
		return kGamepad + kMouse
	end

	function Input.Fov(dt)
		local kGamepad = (gamepad.ButtonX - gamepad.ButtonY)*FOV_GAMEPAD_SPEED
		local kMouse = mouse.MouseWheel*FOV_WHEEL_SPEED
		mouse.MouseWheel = 0
		return kGamepad + kMouse
	end

	do
		local function Keypress(action, state, input)
			keyboard[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
			return Enum.ContextActionResult.Sink
		end

		local function GpButton(action, state, input)
			gamepad[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
			return Enum.ContextActionResult.Sink
		end

		local function MousePan(action, state, input)
			local delta = input.Delta
			mouse.Delta = Vector2.new(-delta.y, -delta.x)
			return Enum.ContextActionResult.Sink
		end

		local function Thumb(action, state, input)
			gamepad[input.KeyCode.Name] = input.Position
			return Enum.ContextActionResult.Sink
		end

		local function Trigger(action, state, input)
			gamepad[input.KeyCode.Name] = input.Position.z
			return Enum.ContextActionResult.Sink
		end

		local function MouseWheel(action, state, input)
			mouse[input.UserInputType.Name] = -input.Position.z
			return Enum.ContextActionResult.Sink
		end

		local function Zero(t)
			for k, v in pairs(t) do
				t[k] = v*0
			end
		end

		function Input.StartCapture()
			ContextActionService:BindActionAtPriority(FREECAM_RENDER_ID .. "FreecamKeyboard", Keypress, false, INPUT_PRIORITY,
				Enum.KeyCode.W, -- Enum.KeyCode.U,
				Enum.KeyCode.A, -- Enum.KeyCode.H,
				Enum.KeyCode.S, -- Enum.KeyCode.J,
				Enum.KeyCode.D, -- Enum.KeyCode.K,
				Enum.KeyCode.E, -- Enum.KeyCode.I,
				Enum.KeyCode.Q, -- Enum.KeyCode.Y,
				Enum.KeyCode.Up, Enum.KeyCode.Down
			)
			ContextActionService:BindActionAtPriority(FREECAM_RENDER_ID .. "FreecamMousePan",          MousePan,   false, INPUT_PRIORITY, Enum.UserInputType.MouseMovement)
			ContextActionService:BindActionAtPriority(FREECAM_RENDER_ID .. "FreecamMouseWheel",        MouseWheel, false, INPUT_PRIORITY, Enum.UserInputType.MouseWheel)
			ContextActionService:BindActionAtPriority(FREECAM_RENDER_ID .. "FreecamGamepadButton",     GpButton,   false, INPUT_PRIORITY, Enum.KeyCode.ButtonX, Enum.KeyCode.ButtonY)
			ContextActionService:BindActionAtPriority(FREECAM_RENDER_ID .. "FreecamGamepadTrigger",    Trigger,    false, INPUT_PRIORITY, Enum.KeyCode.ButtonR2, Enum.KeyCode.ButtonL2)
			ContextActionService:BindActionAtPriority(FREECAM_RENDER_ID .. "FreecamGamepadThumbstick", Thumb,      false, INPUT_PRIORITY, Enum.KeyCode.Thumbstick1, Enum.KeyCode.Thumbstick2)
		end

		function Input.StopCapture()
			navSpeed = 1
			Zero(gamepad)
			Zero(keyboard)
			Zero(mouse)
			ContextActionService:UnbindAction(FREECAM_RENDER_ID .. "FreecamKeyboard")
			ContextActionService:UnbindAction(FREECAM_RENDER_ID .. "FreecamMousePan")
			ContextActionService:UnbindAction(FREECAM_RENDER_ID .. "FreecamMouseWheel")
			ContextActionService:UnbindAction(FREECAM_RENDER_ID .. "FreecamGamepadButton")
			ContextActionService:UnbindAction(FREECAM_RENDER_ID .. "FreecamGamepadTrigger")
			ContextActionService:UnbindAction(FREECAM_RENDER_ID .. "FreecamGamepadThumbstick")
		end
	end
end

local function GetFocusDistance(cameraFrame)
	local znear = 0.1
	local viewport = Camera.ViewportSize
	local projy = 2*tan(cameraFov/2)
	local projx = viewport.x/viewport.y*projy
	local fx = cameraFrame.rightVector
	local fy = cameraFrame.upVector
	local fz = cameraFrame.lookVector

	local minVect = Vector3.new()
	local minDist = 512

	for x = 0, 1, 0.5 do
		for y = 0, 1, 0.5 do
			local cx = (x - 0.5)*projx
			local cy = (y - 0.5)*projy
			local offset = fx*cx - fy*cy + fz
			local origin = cameraFrame.p + offset*znear
			local _, hit = Workspace:FindPartOnRay(Ray.new(origin, offset.unit*minDist))
			local dist = (hit - origin).magnitude
			if minDist > dist then
				minDist = dist
				minVect = offset.unit
			end
		end
	end

	return fz:Dot(minVect)*minDist
end

------------------------------------------------------------------------

local function StepFreecam(dt)
	local vel = velSpring:Update(dt, Input.Vel(dt))
	local pan = panSpring:Update(dt, Input.Pan(dt))
	local fov = fovSpring:Update(dt, Input.Fov(dt))

	local zoomFactor = sqrt(tan(rad(70/2))/tan(rad(cameraFov/2)))

	cameraFov = clamp(cameraFov + fov*FOV_GAIN*(dt/zoomFactor), 1, 120)
	cameraRot = cameraRot + pan*PAN_GAIN*(dt/zoomFactor)
	cameraRot = Vector2.new(clamp(cameraRot.x, -PITCH_LIMIT, PITCH_LIMIT), cameraRot.y%(2*pi))

	local cameraCFrame = CFrame.new(cameraPos)*CFrame.fromOrientation(cameraRot.x, cameraRot.y, 0)*CFrame.new(vel*NAV_GAIN*dt)
	cameraPos = cameraCFrame.p

	Camera.CFrame = cameraCFrame
	Camera.Focus = cameraCFrame*CFrame.new(0, 0, -GetFocusDistance(cameraCFrame))
	Camera.FieldOfView = cameraFov
end

------------------------------------------------------------------------

local PlayerState = {} do
	local mouseBehavior
	local mouseIconEnabled
	local cameraType
	local cameraFocus
	local cameraCFrame
	local cameraFieldOfView
	local screenGuis = {}
	local coreGuis = {
		Backpack = true,
		Chat = true,
		Health = true,
		PlayerList = true,
	}
	local setCores = {
		BadgesNotificationsActive = true,
		PointsNotificationsActive = true,
	}

	-- Save state and set up for freecam
	function PlayerState.Push()
		-- for name in pairs(coreGuis) do
		-- 	coreGuis[name] = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType[name])
		-- 	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], false)
		-- end
		-- for name in pairs(setCores) do
		-- 	setCores[name] = StarterGui:GetCore(name)
		-- 	StarterGui:SetCore(name, false)
		-- end
		-- local playergui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		-- if playergui then
		-- 	for _, gui in pairs(playergui:GetChildren()) do
		-- 		if gui:IsA("ScreenGui") and gui.Enabled then
		-- 			screenGuis[#screenGuis + 1] = gui
		-- 			gui.Enabled = false
		-- 		end
		-- 	end
		-- end

		cameraFieldOfView = Camera.FieldOfView
		Camera.FieldOfView = 70

		-- cameraType = Camera.CameraType
		-- Camera.CameraType = Enum.CameraType.Custom

		cameraCFrame = Camera.CFrame
		cameraFocus = Camera.Focus

		-- mouseIconEnabled = UserInputService.MouseIconEnabled
		-- UserInputService.MouseIconEnabled = false

		mouseBehavior = UserInputService.MouseBehavior
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end

	-- Restore state
	function PlayerState.Pop()
		-- for name, isEnabled in pairs(coreGuis) do
		-- 	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], isEnabled)
		-- end
		-- for name, isEnabled in pairs(setCores) do
		-- 	StarterGui:SetCore(name, isEnabled)
		-- end
		-- for _, gui in pairs(screenGuis) do
		-- 	if gui.Parent then
		-- 		gui.Enabled = true
		-- 	end
		-- end

		Camera.FieldOfView = cameraFieldOfView
		cameraFieldOfView = nil

		-- Camera.CameraType = cameraType
		-- cameraType = nil

		Camera.CFrame = cameraCFrame
		cameraCFrame = nil

		Camera.Focus = cameraFocus
		cameraFocus = nil

		-- UserInputService.MouseIconEnabled = mouseIconEnabled
		-- mouseIconEnabled = nil

		UserInputService.MouseBehavior = mouseBehavior
		mouseBehavior = nil
	end
end

local function StartFreecam()
	local cameraCFrame = Camera.CFrame
	cameraRot = Vector2.new(cameraCFrame:toEulerAnglesYXZ())
	cameraPos = cameraCFrame.p
	cameraFov = Camera.FieldOfView

	velSpring:Reset(Vector3.new())
	panSpring:Reset(Vector2.new())
	fovSpring:Reset(0)

	PlayerState.Push()
	RunService:BindToRenderStep(FREECAM_RENDER_ID, Enum.RenderPriority.Camera.Value + 1, StepFreecam)
	Input.StartCapture()
end

local function StopFreecam()
	Input.StopCapture()
	RunService:UnbindFromRenderStep(FREECAM_RENDER_ID)
	PlayerState.Pop()
end

------------------------------------------------------------------------

local enabled = false

local function EnableFreecam()
	if not enabled then
		StartFreecam()
		enabled = true
	end
end

local function DisableFreecam()
	if enabled then
		StopFreecam()
		enabled = false
	end
end

return {
	EnableFreecam = EnableFreecam,
	DisableFreecam = DisableFreecam,
}
 end,Properties={Name="freecam"},Reference=54,ClassName="ModuleScript"}},Properties={Name="helpers"},Reference=53,ClassName="Folder"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Make = TS.import(script, TS.getModule(script, "@rbxts", "make"))
local Lighting = TS.import(script, TS.getModule(script, "@rbxts", "services")).Lighting
local getStore = TS.import(script, script.Parent, "helpers", "job-store").getStore
local setTimeout = TS.import(script, script.Parent.Parent, "utils", "timeout").setTimeout
local baseEffect = Make("DepthOfFieldEffect", {
	FarIntensity = 0,
	InFocusRadius = 0.1,
	NearIntensity = 1,
})
local depthOfFieldDefaults = {}
local function enableAcrylic()
	for effect in pairs(depthOfFieldDefaults) do
		effect.Enabled = false
	end
	baseEffect.Parent = Lighting
end
local function disableAcrylic()
	for effect, defaults in pairs(depthOfFieldDefaults) do
		effect.Enabled = defaults.enabled
	end
	baseEffect.Parent = nil
end
local main = TS.async(function()
	local store = TS.await(getStore())
	for _, effect in ipairs(Lighting:GetChildren()) do
		if effect:IsA("DepthOfFieldEffect") then
			local _arg1 = {
				enabled = effect.Enabled,
			}
			-- \226\150\188 Map.set \226\150\188
			depthOfFieldDefaults[effect] = _arg1
			-- \226\150\178 Map.set \226\150\178
		end
	end
	local timeout
	store.changed:connect(function(newState)
		local _result = timeout
		if _result ~= nil then
			_result:clear()
		end
		timeout = nil
		if not newState.dashboard.isOpen then
			timeout = setTimeout(disableAcrylic, 500)
			return nil
		end
		if newState.options.config.acrylicBlur then
			enableAcrylic()
		else
			disableAcrylic()
		end
	end)
end)
main():catch(function(err)
	warn("[acrylic-worker] " .. tostring(err))
end)
 end,Properties={Name="acrylic"},Reference=45,ClassName="LocalScript"},{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local Workspace = _services.Workspace
local _job_store = TS.import(script, script.Parent.Parent, "helpers", "job-store")
local getStore = _job_store.getStore
local onJobChange = _job_store.onJobChange
local player = Players.LocalPlayer
local currentCharacter
local deactivate, activateGodmode, deactivateOnCharacterAdded
local main = TS.async(function()
	local function errorHandler(err)
		warn("[godmode-worker] " .. tostring(err))
		deactivate()
	end
	TS.await(onJobChange("godmode", function(job, state)
		if state.jobs.ghost.active and job.active then
			deactivate()
		elseif job.active then
			activateGodmode():andThen(deactivateOnCharacterAdded):catch(errorHandler)
		end
	end))
end)
deactivate = TS.async(function()
	local store = TS.await(getStore())
	store:dispatch({
		type = "jobs/setJobActive",
		jobName = "godmode",
		active = false,
	})
end)
deactivateOnCharacterAdded = TS.async(function()
	local store = TS.await(getStore())
	TS.await(TS.Promise.fromEvent(player.CharacterAdded, function(character)
		local jobs = store:getState().jobs
		return not jobs.ghost.active and character ~= currentCharacter
	end))
	TS.await(deactivate())
end)
activateGodmode = TS.async(function()
	local cameraCFrame = Workspace.CurrentCamera.CFrame
	local character = player.Character
	if not character then
		error("Character is null")
	end
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if not humanoid then
		error("No humanoid found")
	end
	local mockHumanoid = humanoid:Clone()
	mockHumanoid.Parent = character
	currentCharacter = character
	player.Character = nil
	mockHumanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
	mockHumanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
	mockHumanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	mockHumanoid.BreakJointsOnDeath = true
	mockHumanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
	humanoid:Destroy()
	player.Character = character
	Workspace.CurrentCamera.CameraSubject = mockHumanoid
	task.defer(function()
		Workspace.CurrentCamera.CFrame = cameraCFrame
	end)
	local animation = character:FindFirstChild("Animate")
	if animation then
		animation.Disabled = true
		animation.Disabled = false
	end
	mockHumanoid.MaxHealth = math.huge
	mockHumanoid.Health = mockHumanoid.MaxHealth
end)
main():catch(function(err)
	warn("[godmode-worker] " .. tostring(err))
end)
 end,Properties={Name="godmode"},Reference=49,ClassName="LocalScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local Workspace = _services.Workspace
local _job_store = TS.import(script, script.Parent.Parent, "helpers", "job-store")
local getStore = _job_store.getStore
local onJobChange = _job_store.onJobChange
local player = Players.LocalPlayer
local screenGuisWithResetOnSpawn = {}
local originalCharacter
local ghostCharacter
local lastPosition
local function disableResetOnSpawn()
	local playerGui = player:FindFirstChildWhichIsA("PlayerGui")
	if playerGui then
		for _, object in ipairs(playerGui:GetChildren()) do
			if object:IsA("ScreenGui") and object.ResetOnSpawn then
				-- \226\150\188 Array.push \226\150\188
				screenGuisWithResetOnSpawn[#screenGuisWithResetOnSpawn + 1] = object
				-- \226\150\178 Array.push \226\150\178
				object.ResetOnSpawn = false
			end
		end
	end
end
local function enableResetOnSpawn()
	for _, screenGui in ipairs(screenGuisWithResetOnSpawn) do
		screenGui.ResetOnSpawn = true
	end
	-- \226\150\188 Array.clear \226\150\188
	table.clear(screenGuisWithResetOnSpawn)
	-- \226\150\178 Array.clear \226\150\178
end
local deactivate, activateGhost, deactivateOnCharacterAdded, deactivateGhost
local main = TS.async(function()
	TS.await(onJobChange("ghost", function(job, state)
		if state.jobs.refresh.active and job.active then
			deactivate()
		elseif job.active then
			activateGhost():andThen(deactivateOnCharacterAdded):catch(function(err)
				warn("[ghost-worker-active] " .. tostring(err))
				deactivate()
			end)
		elseif not state.jobs.refresh.active then
			deactivateGhost():catch(function(err)
				warn("[ghost-worker-inactive] " .. tostring(err))
			end)
		end
	end))
end)
deactivate = TS.async(function()
	local store = TS.await(getStore())
	store:dispatch({
		type = "jobs/setJobActive",
		jobName = "ghost",
		active = false,
	})
end)
deactivateOnCharacterAdded = TS.async(function()
	TS.await(TS.Promise.fromEvent(player.CharacterAdded, function(character)
		return character ~= originalCharacter and character ~= ghostCharacter
	end))
	TS.await(deactivate())
end)
activateGhost = TS.async(function()
	local character = player.Character
	local _humanoid = character
	if _humanoid ~= nil then
		_humanoid = _humanoid:FindFirstChildWhichIsA("Humanoid")
	end
	local humanoid = _humanoid
	if not character or not humanoid then
		error("Character or Humanoid is null")
	end
	character.Archivable = true
	ghostCharacter = character:Clone()
	character.Archivable = false
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	local _result = rootPart
	if _result ~= nil then
		_result = _result:IsA("BasePart")
	end
	lastPosition = _result and rootPart.CFrame or nil
	originalCharacter = character
	local ghostHumanoid = ghostCharacter:FindFirstChildWhichIsA("Humanoid")
	for _, child in ipairs(ghostCharacter:GetDescendants()) do
		if child:IsA("BasePart") then
			child.Transparency = 1 - (1 - child.Transparency) * 0.5
		end
	end
	if ghostHumanoid then
		ghostHumanoid.DisplayName = utf8.char(128123)
	end
	local _result_1 = ghostCharacter:FindFirstChild("Animate")
	if _result_1 ~= nil then
		_result_1:Destroy()
	end
	local animation = originalCharacter:FindFirstChild("Animate")
	if animation then
		animation.Disabled = true
		animation.Parent = ghostCharacter
	end
	disableResetOnSpawn()
	ghostCharacter.Parent = character.Parent
	player.Character = ghostCharacter
	Workspace.CurrentCamera.CameraSubject = ghostHumanoid
	enableResetOnSpawn()
	if animation then
		animation.Disabled = false
	end
	local handle
	handle = humanoid.Died:Connect(function()
		handle:Disconnect()
		deactivate()
	end)
end)
deactivateGhost = TS.async(function()
	if not originalCharacter or not ghostCharacter then
		return nil
	end
	local rootPart = originalCharacter:FindFirstChild("HumanoidRootPart")
	local ghostRootPart = ghostCharacter:FindFirstChild("HumanoidRootPart")
	local _result = ghostRootPart
	if _result ~= nil then
		_result = _result:IsA("BasePart")
	end
	local currentPosition = _result and ghostRootPart.CFrame or nil
	local animation = ghostCharacter:FindFirstChild("Animate")
	if animation then
		animation.Disabled = true
		animation.Parent = nil
	end
	ghostCharacter:Destroy()
	local humanoid = originalCharacter:FindFirstChildWhichIsA("Humanoid")
	local _result_1 = humanoid
	if _result_1 ~= nil then
		local _exp = _result_1:GetPlayingAnimationTracks()
		local _arg0 = function(track)
			return track:Stop()
		end
		-- \226\150\188 ReadonlyArray.forEach \226\150\188
		for _k, _v in ipairs(_exp) do
			_arg0(_v, _k - 1, _exp)
		end
		-- \226\150\178 ReadonlyArray.forEach \226\150\178
	end
	local position = currentPosition or lastPosition
	local _result_2 = rootPart
	if _result_2 ~= nil then
		_result_2 = _result_2:IsA("BasePart")
	end
	local _condition = _result_2
	if _condition then
		_condition = position
	end
	if _condition then
		rootPart.CFrame = position
	end
	disableResetOnSpawn()
	player.Character = originalCharacter
	Workspace.CurrentCamera.CameraSubject = humanoid
	enableResetOnSpawn()
	if animation then
		animation.Parent = originalCharacter
		animation.Disabled = false
	end
	originalCharacter = nil
	ghostCharacter = nil
	lastPosition = nil
end)
main():catch(function(err)
	warn("[ghost-worker] " .. tostring(err))
end)
 end,Properties={Name="ghost"},Reference=48,ClassName="LocalScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _flipper = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src)
local GroupMotor = _flipper.GroupMotor
local Spring = _flipper.Spring
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local RunService = _services.RunService
local UserInputService = _services.UserInputService
local Workspace = _services.Workspace
local onJobChange = TS.import(script, script.Parent.Parent, "helpers", "job-store").onJobChange
local player = Players.LocalPlayer
local moveDirection = {
	forward = Vector3.new(),
	backward = Vector3.new(),
	left = Vector3.new(),
	right = Vector3.new(),
	up = Vector3.new(),
	down = Vector3.new(),
}
local enabled = false
local speed = 16
local humanoidRoot
local coordinate
local coordinateSpring = GroupMotor.new({ 0, 0, 0 }, false)
local resetCoordinate, resetSpring, updateDirection, updateCoordinate
local main = TS.async(function()
	TS.await(onJobChange("flight", function(job)
		enabled = job.active
		speed = job.value
		if enabled then
			resetCoordinate()
			resetSpring()
		end
	end))
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then
			return nil
		end
		updateDirection(input.KeyCode, true)
	end)
	UserInputService.InputEnded:Connect(function(input)
		updateDirection(input.KeyCode, false)
	end)
	RunService.Heartbeat:Connect(function(deltaTime)
		if enabled and (humanoidRoot and coordinate) then
			updateCoordinate(deltaTime)
			coordinateSpring:setGoal({ Spring.new(coordinate.X), Spring.new(coordinate.Y), Spring.new(coordinate.Z) })
			coordinateSpring:step(deltaTime)
			local _binding = coordinateSpring:getValue()
			local x = _binding[1]
			local y = _binding[2]
			local z = _binding[3]
			humanoidRoot.AssemblyLinearVelocity = Vector3.new()
			local _rotation = Workspace.CurrentCamera.CFrame.Rotation
			local _vector3 = Vector3.new(x, y, z)
			humanoidRoot.CFrame = _rotation + _vector3
		end
	end)
	RunService.RenderStepped:Connect(function()
		if enabled and (humanoidRoot and coordinate) then
			local _rotation = Workspace.CurrentCamera.CFrame.Rotation
			local _position = humanoidRoot.CFrame.Position
			humanoidRoot.CFrame = _rotation + _position
		end
	end)
	player.CharacterAdded:Connect(function(character)
		local newHumanoidRoot = character:WaitForChild("HumanoidRootPart", 5)
		if newHumanoidRoot and newHumanoidRoot:IsA("BasePart") then
			humanoidRoot = newHumanoidRoot
		end
		resetCoordinate()
		resetSpring()
	end)
	local _currentHumanoidRoot = player.Character
	if _currentHumanoidRoot ~= nil then
		_currentHumanoidRoot = _currentHumanoidRoot:FindFirstChild("HumanoidRootPart")
	end
	local currentHumanoidRoot = _currentHumanoidRoot
	if currentHumanoidRoot and currentHumanoidRoot:IsA("BasePart") then
		humanoidRoot = currentHumanoidRoot
		resetCoordinate()
	end
end)
local function getUnitDirection()
	local sum = Vector3.new()
	for _, v3 in pairs(moveDirection) do
		sum = sum + v3
	end
	return sum.Magnitude > 0 and sum.Unit or sum
end
function resetCoordinate()
	if not humanoidRoot then
		return nil
	end
	local _binding = Workspace.CurrentCamera.CFrame
	local XVector = _binding.XVector
	local YVector = _binding.YVector
	local ZVector = _binding.ZVector
	coordinate = CFrame.fromMatrix(humanoidRoot.Position, XVector, YVector, ZVector)
end
function resetSpring()
	if not coordinate then
		return nil
	end
	coordinateSpring = GroupMotor.new({ coordinate.X, coordinate.Y, coordinate.Z }, false)
end
function updateCoordinate(deltaTime)
	if not coordinate then
		return nil
	end
	local _binding = Workspace.CurrentCamera.CFrame
	local XVector = _binding.XVector
	local YVector = _binding.YVector
	local ZVector = _binding.ZVector
	local direction = getUnitDirection()
	if direction.Magnitude > 0 then
		local _arg0 = speed * deltaTime
		local _binding_1 = direction * _arg0
		local X = _binding_1.X
		local Y = _binding_1.Y
		local Z = _binding_1.Z
		local _exp = CFrame.fromMatrix(coordinate.Position, XVector, YVector, ZVector)
		local _cFrame = CFrame.new(X, Y, Z)
		coordinate = _exp * _cFrame
	else
		coordinate = CFrame.fromMatrix(coordinate.Position, XVector, YVector, ZVector)
	end
end
function updateDirection(code, begin)
	repeat
		if code == (Enum.KeyCode.W) then
			moveDirection.forward = begin and Vector3.new(0, 0, -1) or Vector3.new()
			break
		end
		if code == (Enum.KeyCode.S) then
			moveDirection.backward = begin and Vector3.new(0, 0, 1) or Vector3.new()
			break
		end
		if code == (Enum.KeyCode.A) then
			moveDirection.left = begin and Vector3.new(-1, 0, 0) or Vector3.new()
			break
		end
		if code == (Enum.KeyCode.D) then
			moveDirection.right = begin and Vector3.new(1, 0, 0) or Vector3.new()
			break
		end
		if code == (Enum.KeyCode.Q) then
			moveDirection.up = begin and Vector3.new(0, -1, 0) or Vector3.new()
			break
		end
		if code == (Enum.KeyCode.E) then
			moveDirection.down = begin and Vector3.new(0, 1, 0) or Vector3.new()
			break
		end
	until true
end
main():catch(function(err)
	warn("[flight-worker] " .. tostring(err))
end)
 end,Properties={Name="flight"},Reference=47,ClassName="LocalScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local _job_store = TS.import(script, script.Parent.Parent, "helpers", "job-store")
local getStore = _job_store.getStore
local onJobChange = _job_store.onJobChange
local JUMP_POWER_CONSTANT = 349.24
local player = Players.LocalPlayer
local defaults = {
	walkSpeed = 16,
	jumpHeight = 7.2,
}
local setDefaultWalkSpeed, updateWalkSpeed, setDefaultJumpHeight, updateJumpHeight
local main = TS.async(function()
	local store = TS.await(getStore())
	local _humanoid = player.Character
	if _humanoid ~= nil then
		_humanoid = _humanoid:FindFirstChildWhichIsA("Humanoid")
	end
	local humanoid = _humanoid
	local state = store:getState()
	local walkSpeedJob = state.jobs.walkSpeed
	local jumpHeightJob = state.jobs.jumpHeight
	TS.await(onJobChange("walkSpeed", function(job)
		if job.active and not walkSpeedJob.active then
			setDefaultWalkSpeed(humanoid)
		end
		walkSpeedJob = job
		updateWalkSpeed(humanoid, walkSpeedJob)
	end))
	TS.await(onJobChange("jumpHeight", function(job)
		if job.active and not jumpHeightJob.active then
			setDefaultJumpHeight(humanoid)
		end
		jumpHeightJob = job
		updateJumpHeight(humanoid, jumpHeightJob)
	end))
	player.CharacterAdded:Connect(function(character)
		local newHumanoid = character:WaitForChild("Humanoid", 5)
		if newHumanoid and newHumanoid:IsA("Humanoid") then
			humanoid = newHumanoid
			setDefaultWalkSpeed(newHumanoid)
			setDefaultJumpHeight(newHumanoid)
			if walkSpeedJob.active then
				updateWalkSpeed(newHumanoid, walkSpeedJob)
			end
			if jumpHeightJob.active then
				updateJumpHeight(newHumanoid, jumpHeightJob)
			end
		end
	end)
	setDefaultWalkSpeed(humanoid)
	setDefaultJumpHeight(humanoid)
end)
function setDefaultWalkSpeed(humanoid)
	if humanoid then
		defaults.walkSpeed = humanoid.WalkSpeed
	end
end
function setDefaultJumpHeight(humanoid)
	if humanoid then
		defaults.jumpHeight = humanoid.JumpHeight
	end
end
function updateWalkSpeed(humanoid, walkSpeedJob)
	if not humanoid then
		return nil
	end
	if walkSpeedJob.active then
		humanoid.WalkSpeed = walkSpeedJob.value
	else
		humanoid.WalkSpeed = defaults.walkSpeed
	end
end
function updateJumpHeight(humanoid, jumpHeightJob)
	if not humanoid then
		return nil
	end
	if jumpHeightJob.active then
		humanoid.JumpHeight = jumpHeightJob.value
		if humanoid.UseJumpPower then
			humanoid.JumpPower = math.sqrt(JUMP_POWER_CONSTANT * jumpHeightJob.value)
		end
	else
		humanoid.JumpHeight = defaults.jumpHeight
		if humanoid.UseJumpPower then
			humanoid.JumpPower = math.sqrt(JUMP_POWER_CONSTANT * defaults.jumpHeight)
		end
	end
end
main():catch(function(err)
	warn("[humanoid-worker] " .. tostring(err))
end)
 end,Properties={Name="humanoid"},Reference=50,ClassName="LocalScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local Workspace = _services.Workspace
local _job_store = TS.import(script, script.Parent.Parent, "helpers", "job-store")
local getStore = _job_store.getStore
local onJobChange = _job_store.onJobChange
local MAX_RESPAWN_TIME = 10
local player = Players.LocalPlayer
local respawn
local main = TS.async(function()
	local store = TS.await(getStore())
	local function deactivate()
		store:dispatch({
			type = "jobs/setJobActive",
			jobName = "refresh",
			active = false,
		})
	end
	TS.await(onJobChange("refresh", function(job, state)
		if state.jobs.ghost.active and job.active then
			deactivate()
		elseif job.active then
			respawn():catch(function(err)
				return warn("[refresh-worker-respawn] " .. tostring(err))
			end):finally(function()
				return deactivate()
			end)
		end
	end))
end)
respawn = TS.async(function()
	local character = player.Character
	if not character then
		error("Character is null")
	end
	local _respawnLocation = (character:FindFirstChild("HumanoidRootPart"))
	if _respawnLocation ~= nil then
		_respawnLocation = _respawnLocation.CFrame
	end
	local respawnLocation = _respawnLocation
	local humanoid = character:FindFirstAncestorWhichIsA("Humanoid")
	local _result = humanoid
	if _result ~= nil then
		_result:ChangeState(Enum.HumanoidStateType.Dead)
	end
	character:ClearAllChildren()
	local mockCharacter = Instance.new("Model", Workspace)
	player.Character = mockCharacter
	player.Character = character
	mockCharacter:Destroy()
	if not respawnLocation then
		return nil
	end
	local newCharacter = TS.await(TS.Promise.fromEvent(player.CharacterAdded):timeout(MAX_RESPAWN_TIME, "CharacterAdded event timed out"))
	local humanoidRoot = newCharacter:WaitForChild("HumanoidRootPart", 5)
	if humanoidRoot and (humanoidRoot:IsA("BasePart") and respawnLocation) then
		task.delay(0.1, function()
			humanoidRoot.CFrame = respawnLocation
		end)
	end
end)
main():catch(function(err)
	warn("[refresh-worker] " .. tostring(err))
end)
 end,Properties={Name="refresh"},Reference=51,ClassName="LocalScript"}},Properties={Name="character"},Reference=46,ClassName="Folder"}}},{Children={{Closure=function() local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")
local ReplicatedFirst = game:GetService("ReplicatedFirst")

local TS = {}

TS.Promise = Promise

local function isPlugin(object)
	return RunService:IsStudio() and object:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(object, scope, moduleName)
	if moduleName == nil then
		moduleName = scope
		scope = "@rbxts"
	end

	if RunService:IsRunning() and object:IsDescendantOf(ReplicatedFirst) then
		warn("roblox-ts packages should not be used from ReplicatedFirst!")
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(object) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local globalModules = script.Parent:FindFirstChild("node_modules")
	if not globalModules then
		error("Could not find any modules!", 2)
	end

	repeat
		local modules = object:FindFirstChild("node_modules")
		if modules and modules ~= globalModules then
			modules = modules:FindFirstChild("@rbxts")
		end
		if modules then
			local module = modules:FindFirstChild(moduleName)
			if module then
				return module
			end
		end
		object = object.Parent
	until object == nil or object == globalModules

	local scopedModules = globalModules:FindFirstChild(scope or "@rbxts");
	return (scopedModules or globalModules):FindFirstChild(moduleName) or error("Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(caller, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error("Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[caller] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  \226\135\146 " .. currentModule.Name
			end

			error("Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				"Invalid module access! Do you have two TS runtimes trying to import this? " .. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[caller] == module then -- Thread-safe cleanup!
		currentlyLoading[caller] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

function TS.bit_lrsh(a, b)
	local absA = math.abs(a)
	local result = bit32.rshift(absA, b)
	if a == absA then
		return result
	else
		return -result - 1
	end
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
 end,Properties={Name="RuntimeLib"},Reference=154,ClassName="ModuleScript"},{Children={{Children={{Properties={Name="types"},Reference=159,ClassName="Folder"}},Properties={Name="exploit-types"},Reference=158,ClassName="Folder"},{Children={{Properties={Name="types"},Reference=157,ClassName="Folder"}},Properties={Name="compiler-types"},Reference=156,ClassName="Folder"},{Closure=function() return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
 end,Properties={Name="services"},Reference=258,ClassName="ModuleScript"},{Children={{Children={{Properties={Name="generated"},Reference=261,ClassName="Folder"}},Properties={Name="include"},Reference=260,ClassName="Folder"}},Properties={Name="types"},Reference=259,ClassName="Folder"},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.3
--[[
	*
	* Returns a table wherein an object's writable properties can be specified,
	* while also allowing functions to be passed in which can be bound to a RBXScriptSignal.
]]
--[[
	*
	* Instantiates a new Instance of `className` with given `settings`,
	* where `settings` is an object of the form { [K: propertyName]: value }.
	*
	* `settings.Children` is an array of child objects to be parented to the generated Instance.
	*
	* Events can be set to a callback function, which will be connected.
	*
	* `settings.Parent` is always set last.
]]
local function Make(className, settings)
	local _binding = settings
	local children = _binding.Children
	local parent = _binding.Parent
	local instance = Instance.new(className)
	for setting, value in pairs(settings) do
		if setting ~= "Children" and setting ~= "Parent" then
			local _binding_1 = instance
			local prop = _binding_1[setting]
			if typeof(prop) == "RBXScriptSignal" then
				prop:Connect(value)
			else
				instance[setting] = value
			end
		end
	end
	if children then
		for _, child in ipairs(children) do
			child.Parent = instance
		end
	end
	instance.Parent = parent
	return instance
end
return Make
 end,Properties={Name="make"},Reference=171,Children={{Children={{Children={{Children={{Properties={Name="types"},Reference=175,ClassName="Folder"}},Properties={Name="compiler-types"},Reference=174,ClassName="Folder"}},Properties={Name="@rbxts"},Reference=173,ClassName="Folder"}},Properties={Name="node_modules"},Reference=172,ClassName="Folder"}}},{Children={{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local exports = {}
local _with_hooks = TS.import(script, script, "with-hooks")
local withHooks = _with_hooks.withHooks
local withHooksPure = _with_hooks.withHooksPure
for _k, _v in pairs(TS.import(script, script, "hooks")) do
	exports[_k] = _v
end
--[[
	*
	* `hooked` is a [higher-order component](https://reactjs.org/docs/higher-order-components.html) that turns your
	* Function Component into a [class component](https://roblox.github.io/roact/guide/components/).
	*
	* `hooked` allows you to hook into the Component's lifecycle through Hooks.
	*
	* @example
	* const MyComponent = hooked<Props>(
	*   (props) => {
	*     // render using props
	*   },
	* );
	*
	* @see https://reactjs.org/docs/hooks-intro.html
]]
local function hooked(functionComponent)
	return withHooks(functionComponent)
end
--[[
	*
	* `pure` is a [higher-order component](https://reactjs.org/docs/higher-order-components.html) that turns your
	* Function Component into a [PureComponent](https://roblox.github.io/roact/performance/reduce-reconciliation/#purecomponent).
	*
	* If your function component wrapped in `pure` has a {@link useState}, {@link useReducer} or {@link useContext} Hook
	* in its implementation, it will still rerender when state or context changes.
	*
	* @example
	* const MyComponent = pure<Props>(
	*   (props) => {
	*     // render using props
	*   },
	* );
	*
	* @see https://reactjs.org/docs/react-api.html
	* @see https://roblox.github.io/roact/performance/reduce-reconciliation/
]]
local function pure(functionComponent)
	return withHooksPure(functionComponent)
end
exports.hooked = hooked
exports.pure = pure
return exports
 end,Properties={Name="out"},Reference=217,Children={{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local function areDepsEqual(nextDeps, prevDeps)
	if prevDeps == nil then
		return false
	end
	if #nextDeps ~= #prevDeps then
		return false
	end
	do
		local i = 0
		local _shouldIncrement = false
		while true do
			if _shouldIncrement then
				i += 1
			else
				_shouldIncrement = true
			end
			if not (i < #nextDeps) then
				break
			end
			if nextDeps[i + 1] == prevDeps[i + 1] then
				continue
			end
			return false
		end
	end
	return true
end
return {
	areDepsEqual = areDepsEqual,
}
 end,Properties={Name="are-deps-equal"},Reference=230,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local EXCEPTION_INVALID_HOOK_CALL = table.concat({ "Invalid hook call. Hooks can only be called inside of the body of a function component.", "This is usually the result of conflicting versions of roact-hooked.", "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." }, "\n")
local EXCEPTION_RENDER_NOT_DONE = "Failed to render hook! (Another hooked component is rendering)"
local EXCEPTION_RENDER_OVERLAP = "Failed to render hook! (Another hooked component rendered during this one)"
local currentHook
local currentlyRenderingComponent
--[[
	*
	* Prepares for an upcoming render.
]]
local function renderReady(component)
	local _arg0 = currentlyRenderingComponent == nil
	assert(_arg0, EXCEPTION_RENDER_NOT_DONE)
	currentlyRenderingComponent = component
end
--[[
	*
	* Cleans up hooks. Must be called after finishing a render!
]]
local function renderDone(component)
	local _arg0 = currentlyRenderingComponent == component
	assert(_arg0, EXCEPTION_RENDER_OVERLAP)
	currentlyRenderingComponent = nil
	currentHook = nil
end
--[[
	*
	* Returns the currently-rendering component. Throws an error if a component is not mid-render.
]]
local function resolveCurrentComponent()
	return currentlyRenderingComponent or error(EXCEPTION_INVALID_HOOK_CALL, 3)
end
--[[
	*
	* Gets or creates a new hook. Hooks are memoized for every component. See the original source
	* {@link https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L619 here}.
	*
	* @param initialValue - Initial value for `Hook.state` and `Hook.baseState`.
]]
local function memoizedHook(initialValue)
	local currentlyRenderingComponent = resolveCurrentComponent()
	local _result
	if currentHook then
		_result = currentHook.next
	else
		_result = currentlyRenderingComponent.firstHook
	end
	local nextHook = _result
	if nextHook then
		-- The hook has already been created
		currentHook = nextHook
	else
		-- This is a new hook, should be from an initial render
		local _result_1
		if type(initialValue) == "function" then
			_result_1 = initialValue()
		else
			_result_1 = initialValue
		end
		local state = _result_1
		local newHook = {
			id = currentHook and currentHook.id + 1 or 0,
			state = state,
			baseState = state,
		}
		if not currentHook then
			-- This is the first hook in the list
			currentHook = newHook
			currentlyRenderingComponent.firstHook = currentHook
		else
			-- Append to the end of the list
			currentHook.next = newHook
			currentHook = currentHook.next
		end
	end
	return currentHook
end
return {
	renderReady = renderReady,
	renderDone = renderDone,
	resolveCurrentComponent = resolveCurrentComponent,
	memoizedHook = memoizedHook,
}
 end,Properties={Name="memoized-hook"},Reference=231,ClassName="ModuleScript"}},Properties={Name="utils"},Reference=229,ClassName="Folder"},{Closure=function() -- Compiled with roblox-ts v1.2.7
-- Roact
-- Reducers
-- Utility types
-- Hooks
return nil
 end,Properties={Name="types"},Reference=228,ClassName="ModuleScript"},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local exports = {}
local _with_hooks = TS.import(script, script, "with-hooks")
exports.withHooks = _with_hooks.withHooks
exports.withHooksPure = _with_hooks.withHooksPure
return exports
 end,Properties={Name="with-hooks"},Reference=232,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local _memoized_hook = TS.import(script, script.Parent.Parent, "utils", "memoized-hook")
local renderDone = _memoized_hook.renderDone
local renderReady = _memoized_hook.renderReady
local ComponentWithHooks
do
	ComponentWithHooks = {}
	function ComponentWithHooks:constructor()
	end
	function ComponentWithHooks:init()
		self.effects = {}
		self.effectHandles = {}
	end
	function ComponentWithHooks:setHookState(id, reducer)
		self:setState(function(state)
			return {
				[id] = reducer(state[id]),
			}
		end)
	end
	function ComponentWithHooks:render()
		renderReady(self)
		local _functionComponent = self.functionComponent
		local _props = self.props
		local _success, _valueOrError = pcall(_functionComponent, _props)
		local result = _success and {
			success = true,
			value = _valueOrError,
		} or {
			success = false,
			error = _valueOrError,
		}
		renderDone(self)
		if not result.success then
			error("(ComponentWithHooks) " .. result.error)
		end
		return result.value
	end
	function ComponentWithHooks:didMount()
		self:flushEffects()
	end
	function ComponentWithHooks:didUpdate()
		self:flushEffects()
	end
	function ComponentWithHooks:willUnmount()
		self:unmountEffects()
		self.effects.head = nil
	end
	function ComponentWithHooks:flushEffectsHelper(effect)
		if not effect then
			return nil
		end
		local _effectHandles = self.effectHandles
		local _id = effect.id
		local _result = _effectHandles[_id]
		if _result ~= nil then
			_result()
		end
		local handle = effect.callback()
		if handle then
			local _effectHandles_1 = self.effectHandles
			local _id_1 = effect.id
			-- \226\150\188 Map.set \226\150\188
			_effectHandles_1[_id_1] = handle
			-- \226\150\178 Map.set \226\150\178
		end
		self:flushEffectsHelper(effect.next)
	end
	function ComponentWithHooks:flushEffects()
		self:flushEffectsHelper(self.effects.head)
		self.effects.head = nil
		self.effects.tail = nil
	end
	function ComponentWithHooks:unmountEffects()
		-- This does not clean up effects by order of id, but it should not matter
		-- because this is on unmount
		local _effectHandles = self.effectHandles
		local _arg0 = function(handle)
			return handle()
		end
		-- \226\150\188 ReadonlyMap.forEach \226\150\188
		for _k, _v in pairs(_effectHandles) do
			_arg0(_v, _k, _effectHandles)
		end
		-- \226\150\178 ReadonlyMap.forEach \226\150\178
		-- \226\150\188 Map.clear \226\150\188
		table.clear(self.effectHandles)
		-- \226\150\178 Map.clear \226\150\178
	end
end
return {
	ComponentWithHooks = ComponentWithHooks,
}
 end,Properties={Name="component-with-hooks"},Reference=233,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local ComponentWithHooks = TS.import(script, script.Parent, "component-with-hooks").ComponentWithHooks
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local function componentWithHooksMixin(ctor)
	for k, v in pairs(ComponentWithHooks) do
		ctor[k] = v
	end
end
local function withHooks(functionComponent)
	local ComponentClass
	do
		ComponentClass = Roact.Component:extend("ComponentClass")
		function ComponentClass:init()
		end
		ComponentClass.functionComponent = functionComponent
	end
	componentWithHooksMixin(ComponentClass)
	return ComponentClass
end
local function withHooksPure(functionComponent)
	local ComponentClass
	do
		ComponentClass = Roact.PureComponent:extend("ComponentClass")
		function ComponentClass:init()
		end
		ComponentClass.functionComponent = functionComponent
	end
	componentWithHooksMixin(ComponentClass)
	return ComponentClass
end
return {
	withHooks = withHooks,
	withHooksPure = withHooksPure,
}
 end,Properties={Name="with-hooks"},Reference=234,ClassName="ModuleScript"}}},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local exports = {}
exports.useBinding = TS.import(script, script, "use-binding").useBinding
exports.useCallback = TS.import(script, script, "use-callback").useCallback
exports.useContext = TS.import(script, script, "use-context").useContext
exports.useEffect = TS.import(script, script, "use-effect").useEffect
exports.useMemo = TS.import(script, script, "use-memo").useMemo
exports.useReducer = TS.import(script, script, "use-reducer").useReducer
exports.useState = TS.import(script, script, "use-state").useState
exports.useMutable = TS.import(script, script, "use-mutable").useMutable
exports.useRef = TS.import(script, script, "use-ref").useRef
return exports
 end,Properties={Name="hooks"},Reference=218,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local useMemo = TS.import(script, script.Parent, "use-memo").useMemo
--[[
	*
	* Returns a memoized version of the callback that only changes if one of the dependencies has changed.
	*
	* This is useful when passing callbacks to optimized child components that rely on reference equality to prevent
	* unnecessary renders.
	*
	* `useCallback(fn, deps)` is equivalent to `useMemo(() => fn, deps)`.
	*
	* @example
	* const memoizedCallback = useCallback(
	*   () => {
	*     doSomething(a, b);
	*   },
	*   [a, b],
	* );
	*
	* @param callback - An inline callback
	* @param deps - An array of dependencies
	* @returns A memoized version of the callback
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usecallback
]]
local function useCallback(callback, deps)
	return useMemo(function()
		return callback
	end, deps)
end
return {
	useCallback = useCallback,
}
 end,Properties={Name="use-callback"},Reference=220,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local memoizedHook = TS.import(script, script.Parent.Parent, "utils", "memoized-hook").memoizedHook
-- Function overloads from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts#L1061
--[[
	*
	* `useMutable` returns a mutable object whose `.current` property is initialized to the argument `initialValue`.
	* The returned object will persist for the full lifetime of the component.
	*
	* `useMutable()` is handy for keeping any mutable value around similar to how you\226\128\153d use instance fields in classes.
	*
	* This cannot be used as a [Roact Ref](https://roblox.github.io/roact/advanced/bindings-and-refs/#refs). If you want
	* to reference a Roblox Instance, refer to {@link useRef}.
	*
	* @example
	* const container = useMutable(initialValue);
	* useEffect(() => {
	*   container.current = value;
	* });
	*
	* @param initialValue - Initialized as the `.current` property
	* @returns A memoized, mutable object
	*
	* @see https://reactjs.org/docs/hooks-reference.html#useref
]]
--[[
	*
	* `useMutable` returns a mutable object whose `.current` property is initialized to the argument `initialValue`.
	* The returned object will persist for the full lifetime of the component.
	*
	* `useMutable()` is handy for keeping any mutable value around similar to how you\226\128\153d use instance fields in classes.
	*
	* This cannot be used as a [Roact Ref](https://roblox.github.io/roact/advanced/bindings-and-refs/#refs). If you want
	* to reference a Roblox Instance, refer to {@link useRef}.
	*
	* @example
	* const container = useMutable(initialValue);
	* useEffect(() => {
	*   container.current = value;
	* });
	*
	* @param initialValue - Initialized as the `.current` property
	* @returns A memoized, mutable object
	*
	* @see https://reactjs.org/docs/hooks-reference.html#useref
]]
-- convenience overload for refs given as a ref prop as they typically start with a null value
--[[
	*
	* `useMutable` returns a mutable object whose `.current` property is initialized to the argument `initialValue`.
	* The returned object will persist for the full lifetime of the component.
	*
	* `useMutable()` is handy for keeping any mutable value around similar to how you\226\128\153d use instance fields in classes.
	*
	* This cannot be used as a [Roact Ref](https://roblox.github.io/roact/advanced/bindings-and-refs/#refs). If you want
	* to reference a Roblox Instance, refer to {@link useRef}.
	*
	* @example
	* const container = useMutable(initialValue);
	* useEffect(() => {
	*   container.current = value;
	* });
	*
	* @returns A memoized, mutable object
	*
	* @see https://reactjs.org/docs/hooks-reference.html#useref
]]
-- convenience overload for potentially undefined initialValue / call with 0 arguments
-- has a default to stop it from defaulting to {} instead
--[[
	*
	* `useMutable` returns a mutable object whose `.current` property is initialized to the argument `initialValue`.
	* The returned object will persist for the full lifetime of the component.
	*
	* `useMutable()` is handy for keeping any mutable value around similar to how you\226\128\153d use instance fields in classes.
	*
	* This cannot be used as a [Roact Ref](https://roblox.github.io/roact/advanced/bindings-and-refs/#refs). If you want
	* to reference a Roblox Instance, refer to {@link useRef}.
	*
	* @example
	* const container = useMutable(initialValue);
	* useEffect(() => {
	*   container.current = value;
	* });
	*
	* @param initialValue - Initialized as the `.current` property
	* @returns A memoized, mutable object
	*
	* @see https://reactjs.org/docs/hooks-reference.html#useref
]]
local function useMutable(initialValue)
	return memoizedHook(function()
		return {
			current = initialValue,
		}
	end).state
end
return {
	useMutable = useMutable,
}
 end,Properties={Name="use-mutable"},Reference=224,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local createRef = TS.import(script, TS.getModule(script, "@rbxts", "roact").src).createRef
local memoizedHook = TS.import(script, script.Parent.Parent, "utils", "memoized-hook").memoizedHook
--[[
	*
	* `useRef` returns a memoized *`Ref`*, a special type of binding that points to Roblox Instance objects that are
	* created by Roact. The returned object will persist for the full lifetime of the component.
	*
	* `useMutable()` is handy for keeping any mutable value around similar to how you\226\128\153d use instance fields in classes.
	*
	* This is not mutable like React's `useRef` hook. If you want to use a mutable object, refer to {@link useMutable}.
	*
	* @example
	* const ref = useRef<TextBox>();
	*
	* useEffect(() => {
	* 	const textBox = ref.getValue();
	* 	if (textBox) {
	* 		textBox.CaptureFocus();
	* 	}
	* }, []);
	*
	* return <textbox Ref={ref} />;
	*
	* @returns A memoized `Ref` object
	*
	* @see https://roblox.github.io/roact/advanced/bindings-and-refs/#refs
]]
local function useRef()
	return memoizedHook(function()
		return createRef()
	end).state
end
return {
	useRef = useRef,
}
 end,Properties={Name="use-ref"},Reference=226,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local areDepsEqual = TS.import(script, script.Parent.Parent, "utils", "are-deps-equal").areDepsEqual
local _memoized_hook = TS.import(script, script.Parent.Parent, "utils", "memoized-hook")
local memoizedHook = _memoized_hook.memoizedHook
local resolveCurrentComponent = _memoized_hook.resolveCurrentComponent
local function scheduleEffect(effect)
	local _binding = resolveCurrentComponent()
	local effects = _binding.effects
	if effects.tail == nil then
		-- This is the first effect in the list
		effects.tail = effect
		effects.head = effects.tail
	else
		-- Append to the end of the list
		local _exp = effects.tail
		_exp.next = effect
		effects.tail = _exp.next
	end
	return effect
end
--[[
	*
	* Accepts a function that contains imperative, possibly effectful code. The function passed to `useEffect` will run
	* synchronously (thread-blocking) after the Roblox Instance is created and rendered.
	*
	* The clean-up function (returned by the effect) runs before the component is removed from the UI to prevent memory
	* leaks. Additionally, if a component renders multiple times, the **previous effect is cleaned up before executing
	* the next effect**.
	*
	*`useEffect` runs in the same phase as `didMount` and `didUpdate`. All cleanup functions are called on `willUnmount`.
	*
	* @example
	* useEffect(() => {
	*   // use value
	*   return () => {
	*     // cleanup
	*   }
	* }, [value]);
	*
	* useEffect(() => {
	*   // did update
	* });
	*
	* useEffect(() => {
	*   // did mount
	*   return () => {
	*     // will unmount
	*   }
	* }, []);
	*
	* @param callback - Imperative function that can return a cleanup function
	* @param deps - If present, effect will only activate if the values in the list change
	*
	* @see https://reactjs.org/docs/hooks-reference.html#useeffect
]]
local function useEffect(callback, deps)
	local hook = memoizedHook(nil)
	local _prevDeps = hook.state
	if _prevDeps ~= nil then
		_prevDeps = _prevDeps.deps
	end
	local prevDeps = _prevDeps
	if deps and areDepsEqual(deps, prevDeps) then
		return nil
	end
	hook.state = scheduleEffect({
		id = hook.id,
		callback = callback,
		deps = deps,
	})
end
return {
	useEffect = useEffect,
}
 end,Properties={Name="use-effect"},Reference=222,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local _memoized_hook = TS.import(script, script.Parent.Parent, "utils", "memoized-hook")
local memoizedHook = _memoized_hook.memoizedHook
local resolveCurrentComponent = _memoized_hook.resolveCurrentComponent
--[[
	*
	* Accepts a reducer of type `(state, action) => newState`, and returns the current state paired with a `dispatch`
	* method.
	*
	* If a new state is the same value as the current state, this will bail out without rerendering the component.
	*
	* `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values.
	* It also lets you optimize performance for components that trigger deep updates because [you can pass `dispatch` down
	* instead of callbacks](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down).
	*
	* There are two different ways to initialize `useReducer` state. You can use the initial state as a second argument,
	* or [create the initial state lazily](https://reactjs.org/docs/hooks-reference.html#lazy-initialization). To do this,
	* you can pass an init function as the third argument. The initial state will be set to `initializer(initialArg)`.
	*
	* @param reducer - Function that returns a state given the current state and an action
	* @param initializerArg - State used during the initial render, or passed to `initializer` if provided
	* @param initializer - Optional function that returns an initial state given `initializerArg`
	* @returns The current state, and an action dispatcher
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usereducer
]]
-- overload where dispatch could accept 0 arguments.
--[[
	*
	* Accepts a reducer of type `(state, action) => newState`, and returns the current state paired with a `dispatch`
	* method.
	*
	* If a new state is the same value as the current state, this will bail out without rerendering the component.
	*
	* `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values.
	* It also lets you optimize performance for components that trigger deep updates because [you can pass `dispatch` down
	* instead of callbacks](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down).
	*
	* There are two different ways to initialize `useReducer` state. You can use the initial state as a second argument,
	* or [create the initial state lazily](https://reactjs.org/docs/hooks-reference.html#lazy-initialization). To do this,
	* you can pass an init function as the third argument. The initial state will be set to `initializer(initialArg)`.
	*
	* @param reducer - Function that returns a state given the current state and an action
	* @param initializerArg - State used during the initial render, or passed to `initializer` if provided
	* @param initializer - Optional function that returns an initial state given `initializerArg`
	* @returns The current state, and an action dispatcher
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usereducer
]]
-- overload where dispatch could accept 0 arguments.
--[[
	*
	* Accepts a reducer of type `(state, action) => newState`, and returns the current state paired with a `dispatch`
	* method.
	*
	* If a new state is the same value as the current state, this will bail out without rerendering the component.
	*
	* `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values.
	* It also lets you optimize performance for components that trigger deep updates because [you can pass `dispatch` down
	* instead of callbacks](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down).
	*
	* There are two different ways to initialize `useReducer` state. You can use the initial state as a second argument,
	* or [create the initial state lazily](https://reactjs.org/docs/hooks-reference.html#lazy-initialization). To do this,
	* you can pass an init function as the third argument. The initial state will be set to `initializer(initialArg)`.
	*
	* @param reducer - Function that returns a state given the current state and an action
	* @param initializerArg - State used during the initial render, or passed to `initializer` if provided
	* @param initializer - Optional function that returns an initial state given `initializerArg`
	* @returns The current state, and an action dispatcher
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usereducer
]]
-- overload for free "I"; all goes as long as initializer converts it into "ReducerState<R>".
--[[
	*
	* Accepts a reducer of type `(state, action) => newState`, and returns the current state paired with a `dispatch`
	* method.
	*
	* If a new state is the same value as the current state, this will bail out without rerendering the component.
	*
	* `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values.
	* It also lets you optimize performance for components that trigger deep updates because [you can pass `dispatch` down
	* instead of callbacks](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down).
	*
	* There are two different ways to initialize `useReducer` state. You can use the initial state as a second argument,
	* or [create the initial state lazily](https://reactjs.org/docs/hooks-reference.html#lazy-initialization). To do this,
	* you can pass an init function as the third argument. The initial state will be set to `initializer(initialArg)`.
	*
	* @param reducer - Function that returns a state given the current state and an action
	* @param initializerArg - State used during the initial render, or passed to `initializer` if provided
	* @param initializer - Optional function that returns an initial state given `initializerArg`
	* @returns The current state, and an action dispatcher
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usereducer
]]
-- overload where "I" may be a subset of ReducerState<R>; used to provide autocompletion.
-- If "I" matches ReducerState<R> exactly then the last overload will allow initializer to be omitted.
--[[
	*
	* Accepts a reducer of type `(state, action) => newState`, and returns the current state paired with a `dispatch`
	* method.
	*
	* If a new state is the same value as the current state, this will bail out without rerendering the component.
	*
	* `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values.
	* It also lets you optimize performance for components that trigger deep updates because [you can pass `dispatch` down
	* instead of callbacks](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down).
	*
	* There are two different ways to initialize `useReducer` state. You can use the initial state as a second argument,
	* or [create the initial state lazily](https://reactjs.org/docs/hooks-reference.html#lazy-initialization). To do this,
	* you can pass an init function as the third argument. The initial state will be set to `initializer(initialArg)`.
	*
	* @param reducer - Function that returns a state given the current state and an action
	* @param initializerArg - State used during the initial render, or passed to `initializer` if provided
	* @param initializer - Optional function that returns an initial state given `initializerArg`
	* @returns The current state, and an action dispatcher
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usereducer
]]
-- Implementation matches a previous overload, is this required?
local function useReducer(reducer, initializerArg, initializer)
	local currentComponent = resolveCurrentComponent()
	local hook = memoizedHook(function()
		local _result
		if initializer then
			_result = initializer(initializerArg)
		else
			_result = initializerArg
		end
		return _result
	end)
	local function dispatch(action)
		local nextState = reducer(hook.state, action)
		if hook.state ~= nextState then
			currentComponent:setHookState(hook.id, function()
				hook.state = nextState
				return hook.state
			end)
		end
	end
	return { hook.state, dispatch }
end
return {
	useReducer = useReducer,
}
 end,Properties={Name="use-reducer"},Reference=225,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local useReducer = TS.import(script, script.Parent, "use-reducer").useReducer
--[[
	*
	* Returns a stateful value, and a function to update it.
	*
	* During the initial render, the returned state (`state`) is the same as the value passed as the first argument
	* (`initialState`).
	*
	* The `setState` function is used to update the state. It always knows the current state, so it's safe to omit from
	* the `useEffect` or `useCallback` dependency lists.
	*
	* If you update a State Hook to the same value as the current state, this will bail out without rerendering the
	* component.
	*
	* @example
	* const [state, setState] = useState(initialState);
	* const [state, setState] = useState(() => someExpensiveComputation());
	* setState(newState);
	* setState((prevState) => prevState + 1)
	*
	* @param initialState - State used during the initial render. Can be a function, which will be executed on initial render
	* @returns A stateful value, and an updater function
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usestate
]]
--[[
	*
	* Returns a stateful value, and a function to update it.
	*
	* During the initial render, the returned state (`state`) is the same as the value passed as the first argument
	* (`initialState`).
	*
	* The `setState` function is used to update the state. It always knows the current state, so it's safe to omit from
	* the `useEffect` or `useCallback` dependency lists.
	*
	* If you update a State Hook to the same value as the current state, this will bail out without rerendering the
	* component.
	*
	* @example
	* const [state, setState] = useState(initialState);
	* const [state, setState] = useState(() => someExpensiveComputation());
	* setState(newState);
	* setState((prevState) => prevState + 1)
	*
	* @param initialState - State used during the initial render. Can be a function, which will be executed on initial render
	* @returns A stateful value, and an updater function
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usestate
]]
--[[
	*
	* Returns a stateful value, and a function to update it.
	*
	* During the initial render, the returned state (`state`) is the same as the value passed as the first argument
	* (`initialState`).
	*
	* The `setState` function is used to update the state. It always knows the current state, so it's safe to omit from
	* the `useEffect` or `useCallback` dependency lists.
	*
	* If you update a State Hook to the same value as the current state, this will bail out without rerendering the
	* component.
	*
	* @example
	* const [state, setState] = useState(initialState);
	* const [state, setState] = useState(() => someExpensiveComputation());
	* setState(newState);
	* setState((prevState) => prevState + 1)
	*
	* @param initialState - State used during the initial render. Can be a function, which will be executed on initial render
	* @returns A stateful value, and an updater function
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usestate
]]
local function useState(initialState)
	local _binding = useReducer(function(state, action)
		local _result
		if type(action) == "function" then
			_result = action(state)
		else
			_result = action
		end
		return _result
	end, nil, function()
		local _result
		if type(initialState) == "function" then
			_result = initialState()
		else
			_result = initialState
		end
		return _result
	end)
	local state = _binding[1]
	local dispatch = _binding[2]
	return { state, dispatch }
end
return {
	useState = useState,
}
 end,Properties={Name="use-state"},Reference=227,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local areDepsEqual = TS.import(script, script.Parent.Parent, "utils", "are-deps-equal").areDepsEqual
local memoizedHook = TS.import(script, script.Parent.Parent, "utils", "memoized-hook").memoizedHook
--[[
	*
	* `useMemo` will only recompute the memoized value when one of the `deps` has changed. This optimization helps to
	* avoid expensive calculations on every render.
	*
	* Remember that the function passed to `useMemo` runs during rendering. Don\226\128\153t do anything there that you wouldn\226\128\153t
	* normally do while rendering. For example, side effects belong in `useEffect`, not `useMemo`.
	*
	* If no array is provided, a new value will be computed on every render. This is usually a mistake, so `deps` must be
	* explicitly written as `undefined`.
	*
	* @example
	* const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
	*
	* @param factory - A "create" function that computes a value
	* @param deps - An array of dependencies
	* @returns A memoized value
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usememo
]]
local function useMemo(factory, deps)
	local hook = memoizedHook(function()
		return {}
	end)
	local _binding = hook.state
	local prevValue = _binding[1]
	local prevDeps = _binding[2]
	if prevValue ~= nil and (deps and areDepsEqual(deps, prevDeps)) then
		return prevValue
	end
	local nextValue = factory()
	hook.state = { nextValue, deps }
	return nextValue
end
return {
	useMemo = useMemo,
}
 end,Properties={Name="use-memo"},Reference=223,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
--[[
	*
	* @see https://github.com/Kampfkarren/roact-hooks/blob/main/src/createUseContext.lua
]]
local _memoized_hook = TS.import(script, script.Parent.Parent, "utils", "memoized-hook")
local memoizedHook = _memoized_hook.memoizedHook
local resolveCurrentComponent = _memoized_hook.resolveCurrentComponent
local useEffect = TS.import(script, script.Parent, "use-effect").useEffect
local useState = TS.import(script, script.Parent, "use-state").useState
local function copyComponent(component)
	return setmetatable({}, {
		__index = component,
	})
end
--[[
	*
	* Accepts a context object (the value returned from `Roact.createContext`) and returns the current context value, as
	* given by the nearest context provider for the given context.
	*
	* When the nearest `Context.Provider` above the component updates, this Hook will trigger a rerender with the latest
	* context value.
	*
	* If there is no Provider, `useContext` returns the default value of the context.
	*
	* @param context - The Context object to read from
	* @returns The latest context value of the nearest Provider
	*
	* @see https://reactjs.org/docs/hooks-reference.html#usecontext
]]
local function useContext(context)
	local thisContext = context
	local _binding = memoizedHook(function()
		local consumer = copyComponent(resolveCurrentComponent())
		thisContext.Consumer.init(consumer)
		return consumer.contextEntry
	end)
	local contextEntry = _binding.state
	if contextEntry then
		local _binding_1 = useState(contextEntry.value)
		local value = _binding_1[1]
		local setValue = _binding_1[2]
		useEffect(function()
			return contextEntry.onUpdate:subscribe(setValue)
		end, {})
		return value
	else
		return thisContext.defaultValue
	end
end
return {
	useContext = useContext,
}
 end,Properties={Name="use-context"},Reference=221,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = _G[script]
local createBinding = TS.import(script, TS.getModule(script, "@rbxts", "roact").src).createBinding
local memoizedHook = TS.import(script, script.Parent.Parent, "utils", "memoized-hook").memoizedHook
--[[
	*
	* `useBinding` returns a memoized *`Binding`*, a special object that Roact automatically unwraps into values. When a
	* binding is updated, Roact will only change the specific properties that are subscribed to it.
	*
	* The first value returned is a `Binding` object, which will typically be passed as a prop to a Roact host component.
	* The second is a function that can be called with a new value to update the binding.
	*
	* @example
	* const [binding, setBindingValue] = useBinding(initialValue);
	*
	* @param initialValue - Initialized as the `.current` property
	* @returns A memoized `Binding` object, and a function to update the value of the binding.
	*
	* @see https://roblox.github.io/roact/advanced/bindings-and-refs/#bindings
]]
local function useBinding(initialValue)
	return memoizedHook(function()
		local bindingSet = { createBinding(initialValue) }
		return bindingSet
	end).state
end
return {
	useBinding = useBinding,
}
 end,Properties={Name="use-binding"},Reference=219,ClassName="ModuleScript"}}}}}},Properties={Name="roact-hooked"},Reference=216,ClassName="Folder"},{Children={{ClassName="ModuleScript",Closure=function() --[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local GlobalConfig = require(script.GlobalConfig)
local createReconciler = require(script.createReconciler)
local createReconcilerCompat = require(script.createReconcilerCompat)
local RobloxRenderer = require(script.RobloxRenderer)
local strict = require(script.strict)
local Binding = require(script.Binding)

local robloxReconciler = createReconciler(RobloxRenderer)
local reconcilerCompat = createReconcilerCompat(robloxReconciler)

local Roact = strict {
	Component = require(script.Component),
	createElement = require(script.createElement),
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),
	None = require(script.None),
	Portal = require(script.Portal),
	createRef = require(script.createRef),
	forwardRef = require(script.forwardRef),
	createBinding = Binding.create,
	joinBindings = Binding.join,
	createContext = require(script.createContext),

	Change = require(script.PropMarkers.Change),
	Children = require(script.PropMarkers.Children),
	Event = require(script.PropMarkers.Event),
	Ref = require(script.PropMarkers.Ref),

	mount = robloxReconciler.mountVirtualTree,
	unmount = robloxReconciler.unmountVirtualTree,
	update = robloxReconciler.updateVirtualTree,

	reify = reconcilerCompat.reify,
	teardown = reconcilerCompat.teardown,
	reconcile = reconcilerCompat.reconcile,

	setGlobalConfig = GlobalConfig.set,

	-- APIs that may change in the future without warning
	UNSTABLE = {
	},
}

return Roact end,Properties={Name="src"},Reference=178,Children={{Closure=function() local ElementKind = require(script.Parent.ElementKind)
local Type = require(script.Parent.Type)

local function createFragment(elements)
	return {
		[Type] = Type.Element,
		[ElementKind] = ElementKind.Fragment,
		elements = elements,
	}
end

return createFragment end,Properties={Name="createFragment"},Reference=204,ClassName="ModuleScript"},{Closure=function() --[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

local function createSignal()
	local connections = {}
	local suspendedConnections = {}
	local firing = false

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
			disconnected = false,
		}

		-- If the callback is already registered, don't add to the suspendedConnection. Otherwise, this will disable
		-- the existing one.
		if firing and not connections[callback] then
			suspendedConnections[callback] = connection
		end

		connections[callback] = connection

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections[callback] = nil
			suspendedConnections[callback] = nil
		end

		return disconnect
	end

	local function fire(self, ...)
		firing = true
		for callback, connection in pairs(connections) do
			if not connection.disconnected and not suspendedConnections[callback] then
				callback(...)
			end
		end

		firing = false

		for callback, _ in pairs(suspendedConnections) do
			suspendedConnections[callback] = nil
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal
 end,Properties={Name="createSignal"},Reference=208,ClassName="ModuleScript"},{Closure=function() local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)

local function noop()
	return nil
end

local ElementUtils = {}

--[[
	A signal value indicating that a child should use its parent's key, because
	it has no key of its own.

	This occurs when you return only one element from a function component or
	stateful render function.
]]
ElementUtils.UseParentKey = Symbol.named("UseParentKey")

--[[
	Returns an iterator over the children of an element.
	`elementOrElements` may be one of:
	* a boolean
	* nil
	* a single element
	* a fragment
	* a table of elements

	If `elementOrElements` is a boolean or nil, this will return an iterator with
	zero elements.

	If `elementOrElements` is a single element, this will return an iterator with
	one element: a tuple where the first value is ElementUtils.UseParentKey, and
	the second is the value of `elementOrElements`.

	If `elementOrElements` is a fragment or a table, this will return an iterator
	over all the elements of the array.

	If `elementOrElements` is none of the above, this function will throw.
]]
function ElementUtils.iterateElements(elementOrElements)
	local richType = Type.of(elementOrElements)

	-- Single child
	if richType == Type.Element then
		local called = false

		return function()
			if called then
				return nil
			else
				called = true
				return ElementUtils.UseParentKey, elementOrElements
			end
		end
	end

	local regularType = typeof(elementOrElements)

	if elementOrElements == nil or regularType == "boolean" then
		return noop
	end

	if regularType == "table" then
		return pairs(elementOrElements)
	end

	error("Invalid elements")
end

--[[
	Gets the child corresponding to a given key, respecting Roact's rules for
	children. Specifically:
	* If `elements` is nil or a boolean, this will return `nil`, regardless of
		the key given.
	* If `elements` is a single element, this will return `nil`, unless the key
		is ElementUtils.UseParentKey.
	* If `elements` is a table of elements, this will return `elements[key]`.
]]
function ElementUtils.getElementByKey(elements, hostKey)
	if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if Type.of(elements) == Type.Element then
		if hostKey == ElementUtils.UseParentKey then
			return elements
		end

		return nil
	end

	if typeof(elements) == "table" then
		return elements[hostKey]
	end

	error("Invalid elements")
end

return ElementUtils end,Properties={Name="ElementUtils"},Reference=184,ClassName="ModuleScript"},{Closure=function() local Symbol = require(script.Parent.Symbol)
local createFragment = require(script.Parent.createFragment)
local createSignal = require(script.Parent.createSignal)
local Children = require(script.Parent.PropMarkers.Children)
local Component = require(script.Parent.Component)

--[[
	Construct the value that is assigned to Roact's context storage.
]]
local function createContextEntry(currentValue)
	return {
		value = currentValue,
		onUpdate = createSignal(),
	}
end

local function createProvider(context)
	local Provider = Component:extend("Provider")

	function Provider:init(props)
		self.contextEntry = createContextEntry(props.value)
		self:__addContext(context.key, self.contextEntry)
	end

	function Provider:willUpdate(nextProps)
		-- If the provided value changed, immediately update the context entry.
		--
		-- During this update, any components that are reachable will receive
		-- this updated value at the same time as any props and state updates
		-- that are being applied.
		if nextProps.value ~= self.props.value then
			self.contextEntry.value = nextProps.value
		end
	end

	function Provider:didUpdate(prevProps)
		-- If the provided value changed, after we've updated every reachable
		-- component, fire a signal to update the rest.
		--
		-- This signal will notify all context consumers. It's expected that
		-- they will compare the last context value they updated with and only
		-- trigger an update on themselves if this value is different.
		--
		-- This codepath will generally only update consumer components that has
		-- a component implementing shouldUpdate between them and the provider.
		if prevProps.value ~= self.props.value then
			self.contextEntry.onUpdate:fire(self.props.value)
		end
	end

	function Provider:render()
		return createFragment(self.props[Children])
	end

	return Provider
end

local function createConsumer(context)
	local Consumer = Component:extend("Consumer")

	function Consumer.validateProps(props)
		if type(props.render) ~= "function" then
			return false, "Consumer expects a `render` function"
		else
			return true
		end
	end

	function Consumer:init(props)
		-- This value may be nil, which indicates that our consumer is not a
		-- descendant of a provider for this context item.
		self.contextEntry = self:__getContext(context.key)
	end

	function Consumer:render()
		-- Render using the latest available for this context item.
		--
		-- We don't store this value in state in order to have more fine-grained
		-- control over our update behavior.
		local value
		if self.contextEntry ~= nil then
			value = self.contextEntry.value
		else
			value = context.defaultValue
		end

		return self.props.render(value)
	end

	function Consumer:didUpdate()
		-- Store the value that we most recently updated with.
		--
		-- This value is compared in the contextEntry onUpdate hook below.
		if self.contextEntry ~= nil then
			self.lastValue = self.contextEntry.value
		end
	end

	function Consumer:didMount()
		if self.contextEntry ~= nil then
			-- When onUpdate is fired, a new value has been made available in
			-- this context entry, but we may have already updated in the same
			-- update cycle.
			--
			-- To avoid sending a redundant update, we compare the new value
			-- with the last value that we updated with (set in didUpdate) and
			-- only update if they differ. This may happen when an update from a
			-- provider was blocked by an intermediate component that returned
			-- false from shouldUpdate.
			self.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)
				if newValue ~= self.lastValue then
					-- Trigger a dummy state update.
					self:setState({})
				end
			end)
		end
	end

	function Consumer:willUnmount()
		if self.disconnect ~= nil then
			self.disconnect()
		end
	end

	return Consumer
end

local Context = {}
Context.__index = Context

function Context.new(defaultValue)
	return setmetatable({
		defaultValue = defaultValue,
		key = Symbol.named("ContextKey"),
	}, Context)
end

function Context:__tostring()
	return "RoactContext"
end

local function createContext(defaultValue)
	local context = Context.new(defaultValue)

	return {
		Provider = createProvider(context),
		Consumer = createConsumer(context),
	}
end

return createContext
 end,Properties={Name="createContext"},Reference=202,ClassName="ModuleScript"},{Closure=function() --[[
	A utility used to assert that two objects are value-equal recursively. It
	outputs fairly nicely formatted messages to help diagnose why two objects
	would be different.

	This should only be used in tests.
]]

local function deepEqual(a, b)
	if typeof(a) ~= typeof(b) then
		local message = ("{1} is of type %s, but {2} is of type %s"):format(
			typeof(a),
			typeof(b)
		)
		return false, message
	end

	if typeof(a) == "table" then
		local visitedKeys = {}

		for key, value in pairs(a) do
			visitedKeys[key] = true

			local success, innerMessage = deepEqual(value, b[key])
			if not success then
				local message = innerMessage
					:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
					:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

				return false, message
			end
		end

		for key, value in pairs(b) do
			if not visitedKeys[key] then
				local success, innerMessage = deepEqual(value, a[key])

				if not success then
					local message = innerMessage
						:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
						:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

					return false, message
				end
			end
		end

		return true
	end

	if a == b then
		return true
	end

	local message = "{1} ~= {2}"
	return false, message
end

local function assertDeepEqual(a, b)
	local success, innerMessageTemplate = deepEqual(a, b)

	if not success then
		local innerMessage = innerMessageTemplate
			:gsub("{1}", "first")
			:gsub("{2}", "second")

		local message = ("Values were not deep-equal.\n%s"):format(innerMessage)

		error(message, 2)
	end
end

return assertDeepEqual end,Properties={Name="assertDeepEqual"},Reference=200,ClassName="ModuleScript"},{Closure=function() local createSignal = require(script.Parent.createSignal)
local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local BindingImpl = Symbol.named("BindingImpl")

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:subscribe(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)
	if config.typeChecks then
		assert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)
	if config.typeChecks then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in pairs(upstreamBindings) do
			if Type.of(value) ~= Type.Binding then
				local message = (
					"Expected arg #1 to contain only bindings, but key %q had a non-binding value"
				):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in pairs(disconnects) do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi end,Properties={Name="Binding"},Reference=179,ClassName="ModuleScript"},{Closure=function() --[[
	Retrieves at most one child from the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child.
]]
local function oneChild(children)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild end,Properties={Name="oneChild"},Reference=214,ClassName="ModuleScript"},{Children={{Closure=function() local Symbol = require(script.Parent.Parent.Symbol)

local Children = Symbol.named("Children")

return Children end,Properties={Name="Children"},Reference=192,ClassName="ModuleScript"},{Closure=function() local Symbol = require(script.Parent.Parent.Symbol)

local Ref = Symbol.named("Ref")

return Ref end,Properties={Name="Ref"},Reference=194,ClassName="ModuleScript"},{Closure=function() --[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent.Type)

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("RoactHostEvent(%s)"):format(self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event
 end,Properties={Name="Event"},Reference=193,ClassName="ModuleScript"},{Closure=function() --[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent.Type)

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("RoactHostChangeEvent(%s)"):format(self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change
 end,Properties={Name="Change"},Reference=191,ClassName="ModuleScript"}},Properties={Name="PropMarkers"},Reference=190,ClassName="Folder"},{Closure=function() local Symbol = require(script.Parent.Symbol)

local Portal = Symbol.named("Portal")

return Portal end,Properties={Name="Portal"},Reference=189,ClassName="ModuleScript"},{Closure=function() local Symbol = require(script.Parent.Symbol)

-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = Symbol.named("None")

return None end,Properties={Name="None"},Reference=187,ClassName="ModuleScript"},{Closure=function() local function strict(t, name)
	name = name or tostring(t)

	return setmetatable(t, {
		__index = function(self, key)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,

		__newindex = function(self, key, value)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,
	})
end

return strict end,Properties={Name="strict"},Reference=215,ClassName="ModuleScript"},{Closure=function() local None = require(script.Parent.None)

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					target[key] = nil
				else
					target[key] = value
				end
			end
		end
	end

	return target
end

return assign end,Properties={Name="assign"},Reference=201,ClassName="ModuleScript"},{Closure=function() --[[
	Reference renderer intended for use in tests as well as for documenting the
	minimum required interface for a Roact renderer.
]]

local NoopRenderer = {}

function NoopRenderer.isHostObject(target)
	-- Attempting to use NoopRenderer to target a Roblox instance is almost
	-- certainly a mistake.
	return target == nil
end

function NoopRenderer.mountHostNode(reconciler, node)
end

function NoopRenderer.unmountHostNode(reconciler, node)
end

function NoopRenderer.updateHostNode(reconciler, node, newElement)
	return node
end

return NoopRenderer end,Properties={Name="NoopRenderer"},Reference=188,ClassName="ModuleScript"},{Closure=function() --[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol end,Properties={Name="Symbol"},Reference=198,ClassName="ModuleScript"},{Closure=function() --[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Logging = require(script.Parent.Logging)

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local reconcileMessage = [[
Roact.reconcile has been renamed to Roact.update and will be removed in a future release.
Check the call to Roact.reconcile at:
]]

local function createReconcilerCompat(reconciler)
	local compat = {}

	function compat.reify(...)
		Logging.warnOnce(reifyMessage)

		return reconciler.mountVirtualTree(...)
	end

	function compat.teardown(...)
		Logging.warnOnce(teardownMessage)

		return reconciler.unmountVirtualTree(...)
	end

	function compat.reconcile(...)
		Logging.warnOnce(reconcileMessage)

		return reconciler.updateVirtualTree(...)
	end

	return compat
end

return createReconcilerCompat end,Properties={Name="createReconcilerCompat"},Reference=206,ClassName="ModuleScript"},{Closure=function() --[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty end,Properties={Name="getDefaultInstanceProperty"},Reference=211,ClassName="ModuleScript"},{Closure=function() --[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.
	["internalTypeChecks"] = false,
	-- Enables stricter type asserts for Roact's public API.
	["typeChecks"] = false,
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables validation of component props in stateful components.
	["propValidation"] = false,

	-- Temporary config for enabling a bug fix for processing events based on updates to child instances
	-- outside of the standard lifecycle.
	["tempFixUpdateChildrenReEntrancy"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

local Config = {}

function Config.new()
	local self = {}

	self._currentConfig = setmetatable({}, {
		__index = function(_, key)
			local message = (
				"Invalid global configuration key %q. Valid configuration keys are: %s"
			):format(
				tostring(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end
	})

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.get = function(...)
		return Config.get(self, ...)
	end

	self.scoped = function(...)
		return Config.scoped(self, ...)
	end

	self.set(defaultConfig)

	return self
end

function Config:set(configValues)
	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end

		self._currentConfig[key] = value
	end
end

function Config:get()
	return self._currentConfig
end

function Config:scoped(configValues, callback)
	local previousValues = {}
	for key, value in pairs(self._currentConfig) do
		previousValues[key] = value
	end

	self.set(configValues)

	local success, result = pcall(callback)

	self.set(previousValues)

	assert(success, result)
end

return Config end,Properties={Name="Config"},Reference=182,ClassName="ModuleScript"},{Closure=function() local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local Logging = require(script.Parent.Logging)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local multipleChildrenMessage = [[
The prop `Roact.Children` was defined but was overriden by the third parameter to createElement!
This can happen when a component passes props through to a child element but also uses the `children` argument:

	Roact.createElement("Frame", passedProps, {
		child = ...
	})

Instead, consider using a utility function to merge tables of children together:

	local children = mergeTables(passedProps[Roact.Children], {
		child = ...
	})

	local fullProps = mergeTables(passedProps, {
		[Roact.Children] = children
	})

	Roact.createElement("Frame", fullProps)]]

--[[
	Creates a new element representing the given component.

	Elements are lightweight representations of what a component instance should
	look like.

	Children is a shorthand for specifying `Roact.Children` as a key inside
	props. If specified, the passed `props` table is mutated!
]]
local function createElement(component, props, children)
	if config.typeChecks then
		assert(component ~= nil, "`component` is required")
		assert(typeof(props) == "table" or props == nil, "`props` must be a table or nil")
		assert(typeof(children) == "table" or children == nil, "`children` must be a table or nil")
	end

	if props == nil then
		props = {}
	end

	if children ~= nil then
		if props[Children] ~= nil then
			Logging.warnOnce(multipleChildrenMessage)
		end

		props[Children] = children
	end

	local elementKind = ElementKind.fromComponent(component)

	local element = {
		[Type] = Type.Element,
		[ElementKind] = elementKind,
		component = component,
		props = props,
	}

	if config.elementTracing then
		-- We trim out the leading newline since there's no way to specify the
		-- trace level without also specifying a message.
		element.source = debug.traceback("", 2):sub(2)
	end

	return element
end

return createElement end,Properties={Name="createElement"},Reference=203,ClassName="ModuleScript"},{Closure=function() --[[
	Centralized place to handle logging. Lets us:
	- Unit test log output via `Logging.capture`
	- Disable verbose log messages when not debugging Roact

	This should be broken out into a separate library with the addition of
	scoping and logging configuration.
]]

-- Determines whether log messages will go to stdout/stderr
local outputEnabled = true

-- A set of LogInfo objects that should have messages inserted into them.
-- This is a set so that nested calls to Logging.capture will behave.
local collectors = {}

-- A set of all stack traces that have called warnOnce.
local onceUsedLocations = {}

--[[
	Indent a potentially multi-line string with the given number of tabs, in
	addition to any indentation the string already has.
]]
local function indent(source, indentLevel)
	local indentString = ("\t"):rep(indentLevel)

	return indentString .. source:gsub("\n", "\n" .. indentString)
end

--[[
	Indents a list of strings and then concatenates them together with newlines
	into a single string.
]]
local function indentLines(lines, indentLevel)
	local outputBuffer = {}

	for _, line in ipairs(lines) do
		table.insert(outputBuffer, indent(line, indentLevel))
	end

	return table.concat(outputBuffer, "\n")
end

local logInfoMetatable = {}

--[[
	Automatic coercion to strings for LogInfo objects to enable debugging them
	more easily.
]]
function logInfoMetatable:__tostring()
	local outputBuffer = {"LogInfo {"}

	local errorCount = #self.errors
	local warningCount = #self.warnings
	local infosCount = #self.infos

	if errorCount + warningCount + infosCount == 0 then
		table.insert(outputBuffer, "\t(no messages)")
	end

	if errorCount > 0 then
		table.insert(outputBuffer, ("\tErrors (%d) {"):format(errorCount))
		table.insert(outputBuffer, indentLines(self.errors, 2))
		table.insert(outputBuffer, "\t}")
	end

	if warningCount > 0 then
		table.insert(outputBuffer, ("\tWarnings (%d) {"):format(warningCount))
		table.insert(outputBuffer, indentLines(self.warnings, 2))
		table.insert(outputBuffer, "\t}")
	end

	if infosCount > 0 then
		table.insert(outputBuffer, ("\tInfos (%d) {"):format(infosCount))
		table.insert(outputBuffer, indentLines(self.infos, 2))
		table.insert(outputBuffer, "\t}")
	end

	table.insert(outputBuffer, "}")

	return table.concat(outputBuffer, "\n")
end

local function createLogInfo()
	local logInfo = {
		errors = {},
		warnings = {},
		infos = {},
	}

	setmetatable(logInfo, logInfoMetatable)

	return logInfo
end

local Logging = {}

--[[
	Invokes `callback`, capturing all output that happens during its execution.

	Output will not go to stdout or stderr and will instead be put into a
	LogInfo object that is returned. If `callback` throws, the error will be
	bubbled up to the caller of `Logging.capture`.
]]
function Logging.capture(callback)
	local collector = createLogInfo()

	local wasOutputEnabled = outputEnabled
	outputEnabled = false
	collectors[collector] = true

	local success, result = pcall(callback)

	collectors[collector] = nil
	outputEnabled = wasOutputEnabled

	assert(success, result)

	return collector
end

--[[
	Issues a warning with an automatically attached stack trace.
]]
function Logging.warn(messageTemplate, ...)
	local message = messageTemplate:format(...)

	for collector in pairs(collectors) do
		table.insert(collector.warnings, message)
	end

	-- debug.traceback inserts a leading newline, so we trim it here
	local trace = debug.traceback("", 2):sub(2)
	local fullMessage = ("%s\n%s"):format(message, indent(trace, 1))

	if outputEnabled then
		warn(fullMessage)
	end
end

--[[
	Issues a warning like `Logging.warn`, but only outputs once per call site.

	This is useful for marking deprecated functions that might be called a lot;
	using `warnOnce` instead of `warn` will reduce output noise while still
	correctly marking all call sites.
]]
function Logging.warnOnce(messageTemplate, ...)
	local trace = debug.traceback()

	if onceUsedLocations[trace] then
		return
	end

	onceUsedLocations[trace] = true
	Logging.warn(messageTemplate, ...)
end

return Logging end,Properties={Name="Logging"},Reference=186,ClassName="ModuleScript"},{Closure=function() local function internalAssert(condition, message)
	if not condition then
		error(message .. " (This is probably a bug in Roact!)", 3)
	end
end

return internalAssert end,Properties={Name="internalAssert"},Reference=212,ClassName="ModuleScript"},{Closure=function() local assign = require(script.Parent.assign)
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)
local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

--[[
	Calling setState during certain lifecycle allowed methods has the potential
	to create an infinitely updating component. Rather than time out, we exit
	with an error if an unreasonable number of self-triggering updates occur
]]
local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.named("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a Roact component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component[Type] = Type.StatefulComponentClass
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of Roact to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentClass, "Invalid `self` argument to `extend`.")
		assert(typeof(name) == "string", "Component class name must be a string")
	end

	local class = {}

	for key, value in pairs(self) do
		-- Roact opts to make consumers use composition over inheritance, which
		-- lines up with React.
		-- https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class[Type] = Type.StatefulComponentClass
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getDerivedState`")
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			if config.typeChecks then
				assert(typeof(derivedState) == "table", "getDerivedStateFromProps must return a table!")
			end

			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentInstance, "Invalid `self` argument to `extend`.")
	end

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	--[[
		When preparing to update, rendering, or unmounting, it is not safe
		to call `setState` as it will interfere with in-flight updates. It's
		also disallowed during unmounting
	]]
	if lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate or
		lifecyclePhase == ComponentLifecyclePhase.WillUpdate or
		lifecyclePhase == ComponentLifecyclePhase.Render or
		lifecyclePhase == ComponentLifecyclePhase.WillUnmount
	then
		local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		-- If `setState` is called in `init`, we can skip triggering an update!
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.DidMount or
		lifecyclePhase == ComponentLifecyclePhase.DidUpdate or
		lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		--[[
			During certain phases of the component lifecycle, it's acceptable to
			allow `setState` but defer the update until we're done with ones in flight.
			We do this by collapsing it into any pending updates we have.
		]]
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		-- Pause parent events when we are updated outside of our lifecycle
		-- If these events are not paused, our setState can cause a component higher up the
		-- tree to rerender based on events caused by our component while this reconciliation is happening.
		-- This could cause the tree to become invalid.
		local virtualNode = internalData.virtualNode
		local reconciler = internalData.reconciler
		if config.tempFixUpdateChildrenReEntrancy then
			reconciler.suspendParentEvents(virtualNode)
		end

		-- Outside of our lifecycle, the state update is safe to make immediately
		self:__update(nil, newState)

		if config.tempFixUpdateChildrenReEntrancy then
			reconciler.resumeParentEvents(virtualNode)
		end
	else
		local messageTemplate = invalidSetStateMessages.default

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

--[[
	Returns the stack trace of where the element was created that this component
	instance's properties are based on.

	Intended to be used primarily by diagnostic tools.
]]
function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

--[[
	Returns a snapshot of this component given the current props and state. Must
	be overridden by consumers of Roact and should be a pure function with
	regards to props and state.

	TODO (#199): Accept props and state as arguments.
]]
function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(
		tostring(internalData.componentClass)
	)

	error(message, 0)
end

--[[
	Retrieves the context value corresponding to the given key. Can return nil
	if a requested context key is not present
]]
function Component:__getContext(key)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getContext`")
		internalAssert(key ~= nil, "Context key cannot be nil")
	end

	local virtualNode = self[InternalData].virtualNode
	local context = virtualNode.context

	return context[key]
end

--[[
	Adds a new context entry to this component's context table (which will be
	passed down to child components).
]]
function Component:__addContext(key, value)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__addContext`")
	end
	local virtualNode = self[InternalData].virtualNode

	-- Make sure we store a reference to the component's original, unmodified
	-- context the virtual node. In the reconciler, we'll restore the original
	-- context if we need to replace the node (this happens when a node gets
	-- re-rendered as a different component)
	if virtualNode.originalContext == nil then
		virtualNode.originalContext = virtualNode.context
	end

	-- Build a new context table on top of the existing one, then apply it to
	-- our virtualNode
	local existing = virtualNode.context
	virtualNode.context = assign({}, existing, { [key] = value })
end

--[[
	Performs property validation if the static method validateProps is declared.
	validateProps should follow assert's expected arguments:
	(false, message: string) | true. The function may return a message in the
	true case; it will be ignored. If this fails, the function will throw the
	error.
]]
function Component:__validateProps(props)
	if not config.propValidation then
		return
	end

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
			typeof(validator),
			self.__componentName
		))
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "<Validator function did not supply a message>"
		error(("Property validation failed in %s: %s\n\n%s"):format(
			self.__componentName,
			tostring(failureReason),
			self:getElementTraceback() or "<enable element tracebacks>"),
		0)
	end
end

--[[
	An internal method used by the reconciler to construct a new component
	instance and attach it to the given virtualNode.
]]
function Component:__mount(reconciler, virtualNode)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentClass, "Invalid use of `__mount`")
		internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #2 to be of type VirtualNode")
	end

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	-- Contains all the information that we want to keep from consumers of
	-- Roact, or even other parts of the codebase like the reconciler.
	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
	}

	local instance = {
		[Type] = Type.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.legacyContext)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
		assign(instance.state, instance:__getDerivedState(instance.props, instance.state))
	end

	-- It's possible for init() to redefine _context!
	virtualNode.legacyContext = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__unmount`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end
end

--[[
	Internal method used by setState (to trigger updates based on state) and by
	the reconciler (to trigger updates based on props)

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__update(updatedElement, updatedState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__update`")
		internalAssert(
			Type.of(updatedElement) == Type.Element or updatedElement == nil,
			"Expected arg #1 to be of type Element or nil"
		)
		internalAssert(
			typeof(updatedState) == "table" or updatedState == nil,
			"Expected arg #2 to be of type table or nil"
		)
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		-- Consume any pending state we might have
		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		-- Consume a standard update to state or props
		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			-- If the update was short-circuited, bubble the result up to the caller
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

--[[
	Internal method used by __update to apply new props and state

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__resolveUpdate(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__resolveUpdate`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component end,Properties={Name="Component"},Reference=180,ClassName="ModuleScript"},{Closure=function() --[[
	A utility used to create a function spy that can be used to robustly test
	that functions are invoked the correct number of times and with the correct
	number of arguments.

	This should only be used in tests.
]]

local assertDeepEqual = require(script.Parent.assertDeepEqual)

local function createSpy(inner)
	local self = {
		callCount = 0,
		values = {},
		valuesLength = 0,
	}

	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = {...}
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assert(self.values[i] == expected, "value differs")
		end
	end

	self.assertCalledWithDeepEqual = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assertDeepEqual(self.values[i], expected)
		end
	end

	self.captureValues = function(_, ...)
		local len = select("#", ...)
		local result = {}

		assert(self.valuesLength == len, "length of expected values differs from stored values")

		for i = 1, len do
			local key = select(i, ...)
			result[key] = self.values[i]
		end

		return result
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy end,Properties={Name="createSpy"},Reference=209,ClassName="ModuleScript"},{Closure=function() --[[
	Contains markers for annotating the type of an element.

	Use `ElementKind` as a key, and values from it as the value.

		local element = {
			[ElementKind] = ElementKind.Host,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)
local Portal = require(script.Parent.Portal)

local ElementKind = newproxy(true)

local ElementKindInternal = {
	Portal = Symbol.named("Portal"),
	Host = Symbol.named("Host"),
	Function = Symbol.named("Function"),
	Stateful = Symbol.named("Stateful"),
	Fragment = Symbol.named("Fragment"),
}

function ElementKindInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[ElementKind]
end

local componentTypesToKinds = {
	["string"] = ElementKindInternal.Host,
	["function"] = ElementKindInternal.Function,
	["table"] = ElementKindInternal.Stateful,
}

function ElementKindInternal.fromComponent(component)
	if component == Portal then
		return ElementKind.Portal
	else
		return componentTypesToKinds[typeof(component)]
	end
end

getmetatable(ElementKind).__index = ElementKindInternal

strict(ElementKindInternal, "ElementKind")

return ElementKind end,Properties={Name="ElementKind"},Reference=183,ClassName="ModuleScript"},{Closure=function() --[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("Binding")
addType("Element")
addType("HostChangeEvent")
addType("HostEvent")
addType("StatefulComponentClass")
addType("StatefulComponentInstance")
addType("VirtualNode")
addType("VirtualTree")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

strict(TypeInternal, "Type")

return Type end,Properties={Name="Type"},Reference=199,ClassName="ModuleScript"},{Closure=function() --[[
	Renderer that deals in terms of Roblox Instances. This is the most
	well-supported renderer after NoopRenderer and is currently the only
	renderer that does anything.
]]

local Binding = require(script.Parent.Binding)
local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local SingleEventManager = require(script.Parent.SingleEventManager)
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local Ref = require(script.Parent.PropMarkers.Ref)
local Type = require(script.Parent.Type)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local applyPropsError = [[
Error applying props:
	%s
In element:
%s
]]

local updatePropsError = [[
Error updating props:
	%s
In element:
%s
]]

local function identity(...)
	return ...
end

local function applyRef(ref, newHostObject)
	if ref == nil then
		return
	end

	if typeof(ref) == "function" then
		ref(newHostObject)
	elseif Type.of(ref) == Type.Binding then
		Binding.update(ref, newHostObject)
	else
		-- TODO (#197): Better error message
		error(("Invalid ref: Expected type Binding but got %s"):format(
			typeof(ref)
		))
	end
end

local function setRobloxInstanceProperty(hostObject, key, newValue)
	if newValue == nil then
		local hostClass = hostObject.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostObject[key] = newValue

	return
end

local function removeBinding(virtualNode, key)
	local disconnect = virtualNode.bindings[key]
	disconnect()
	virtualNode.bindings[key] = nil
end

local function attachBinding(virtualNode, key, newBinding)
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(function()
			setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "<enable element tracebacks>"
			end

			local fullMessage = updatePropsError:format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
	if virtualNode.bindings ~= nil then
		for _, disconnect in pairs(virtualNode.bindings) do
			disconnect()
		end
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
	if newValue == oldValue then
		return
	end

	if key == Ref or key == Children then
		-- Refs and children are handled in a separate pass
		return
	end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	local newIsBinding = Type.of(newValue) == Type.Binding
	local oldIsBinding = Type.of(oldValue) == Type.Binding

	if oldIsBinding then
		removeBinding(virtualNode, key)
	end

	if newIsBinding then
		attachBinding(virtualNode, key, newValue)
	else
		setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
	end
end

local function applyProps(virtualNode, props)
	for propKey, value in pairs(props) do
		applyProp(virtualNode, propKey, value, nil)
	end
end

local function updateProps(virtualNode, oldProps, newProps)
	-- Apply props that were added or updated
	for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]

		applyProp(virtualNode, propKey, newValue, oldValue)
	end

	-- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end
end

local RobloxRenderer = {}

function RobloxRenderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function RobloxRenderer.mountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement
	local hostParent = virtualNode.hostParent
	local hostKey = virtualNode.hostKey

	if config.internalTypeChecks then
		internalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")
	end
	if config.typeChecks then
		assert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")
		assert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")
	end

	local instance = Instance.new(element.component)
	virtualNode.hostObject = instance

	local success, errorMessage = xpcall(function()
		applyProps(virtualNode, element.props)
	end, identity)

	if not success then
		local source = element.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = applyPropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	instance.Name = tostring(hostKey)

	local children = element.props[Children]

	if children ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	instance.Parent = hostParent
	virtualNode.hostObject = instance

	applyRef(element.props[Ref], instance)

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end
end

function RobloxRenderer.unmountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement

	applyRef(element.props[Ref], nil)

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end

	detachAllBindings(virtualNode)

	virtualNode.hostObject:Destroy()
end

function RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)
	local oldProps = virtualNode.currentElement.props
	local newProps = newElement.props

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:suspend()
	end

	-- If refs changed, detach the old ref and attach the new one
	if oldProps[Ref] ~= newProps[Ref] then
		applyRef(oldProps[Ref], nil)
		applyRef(newProps[Ref], virtualNode.hostObject)
	end

	local success, errorMessage = xpcall(function()
		updateProps(virtualNode, oldProps, newProps)
	end, identity)

	if not success then
		local source = newElement.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = updatePropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	local children = newElement.props[Children]
	if children ~= nil or oldProps[Children] ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end

	return virtualNode
end

return RobloxRenderer
 end,Properties={Name="RobloxRenderer"},Reference=196,ClassName="ModuleScript"},{Closure=function() --[[
	A ref is nothing more than a binding with a special field 'current'
	that maps to the getValue method of the binding
]]
local Binding = require(script.Parent.Binding)

local function createRef()
	local binding, _ = Binding.create(nil)

	local ref = {}

	--[[
		A ref is just redirected to a binding via its metatable
	]]
	setmetatable(ref, {
		__index = function(self, key)
			if key == "current" then
				return binding:getValue()
			else
				return binding[key]
			end
		end,
		__newindex = function(self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			binding[key] = value
		end,
		__tostring = function(self)
			return ("RoactRef(%s)"):format(tostring(binding:getValue()))
		end,
	})

	return ref
end

return createRef end,Properties={Name="createRef"},Reference=207,ClassName="ModuleScript"},{Closure=function() local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local ComponentLifecyclePhase = strict({
	-- Component methods
	Init = Symbol.named("init"),
	Render = Symbol.named("render"),
	ShouldUpdate = Symbol.named("shouldUpdate"),
	WillUpdate = Symbol.named("willUpdate"),
	DidMount = Symbol.named("didMount"),
	DidUpdate = Symbol.named("didUpdate"),
	WillUnmount = Symbol.named("willUnmount"),

	-- Phases describing reconciliation status
	ReconcileChildren = Symbol.named("reconcileChildren"),
	Idle = Symbol.named("idle"),
}, "ComponentLifecyclePhase")

return ComponentLifecyclePhase end,Properties={Name="ComponentLifecyclePhase"},Reference=181,ClassName="ModuleScript"},{Closure=function() --[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent end,Properties={Name="PureComponent"},Reference=195,ClassName="ModuleScript"},{Closure=function() --[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new() end,Properties={Name="GlobalConfig"},Reference=185,ClassName="ModuleScript"},{Closure=function() --[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)

local invalidSetStateMessages = {}

invalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.Render] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, because Roact doesn't know
which part of the lifecycle this component is in.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages end,Properties={Name="invalidSetStateMessages"},Reference=213,ClassName="ModuleScript"},{Closure=function() local Type = require(script.Parent.Type)
local ElementKind = require(script.Parent.ElementKind)
local ElementUtils = require(script.Parent.ElementUtils)
local Children = require(script.Parent.PropMarkers.Children)
local Symbol = require(script.Parent.Symbol)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local InternalData = Symbol.named("InternalData")

--[[
	The reconciler is the mechanism in Roact that constructs the virtual tree
	that later gets turned into concrete objects by the renderer.

	Roact's reconciler is constructed with the renderer as an argument, which
	enables switching to different renderers for different platforms or
	scenarios.

	When testing the reconciler itself, it's common to use `NoopRenderer` with
	spies replacing some methods. The default (and only) reconciler interface
	exposed by Roact right now uses `RobloxRenderer`.
]]
local function createReconciler(renderer)
	local reconciler
	local mountVirtualNode
	local updateVirtualNode
	local unmountVirtualNode

	--[[
		Unmount the given virtualNode, replacing it with a new node described by
		the given element.

		Preserves host properties, depth, and legacyContext from parent.
	]]
	local function replaceVirtualNode(virtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local depth = virtualNode.depth
		local parent = virtualNode.parent

		-- If the node that is being replaced has modified context, we need to
		-- use the original *unmodified* context for the new node
		-- The `originalContext` field will be nil if the context was unchanged
		local context = virtualNode.originalContext or virtualNode.context
		local parentLegacyContext = virtualNode.parentLegacyContext

		unmountVirtualNode(virtualNode)
		local newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)

		-- mountVirtualNode can return nil if the element is a boolean
		if newNode ~= nil then
			newNode.depth = depth
			newNode.parent = parent
		end

		return newNode
	end

	--[[
		Utility to update the children of a virtual node based on zero or more
		updated children given as elements.
	]]
	local function updateChildren(virtualNode, hostParent, newChildElements)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local removeKeys = {}

		-- Changed or removed children
		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementUtils.getElementByKey(newChildElements, childKey)
			local newNode = updateVirtualNode(childNode, newElement)

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		-- Added children
		for childKey, newElement in ElementUtils.iterateElements(newChildElements) do
			local concreteKey = childKey
			if childKey == ElementUtils.UseParentKey then
				concreteKey = virtualNode.hostKey
			end

			if virtualNode.children[childKey] == nil then
				local childNode = mountVirtualNode(
					newElement,
					hostParent,
					concreteKey,
					virtualNode.context,
					virtualNode.legacyContext
				)

				-- mountVirtualNode can return nil if the element is a boolean
				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					childNode.parent = virtualNode
					virtualNode.children[childKey] = childNode
				end
			end
		end
	end

	local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)
		updateChildren(virtualNode, hostParent, newChildElements)
	end

	local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)
		if Type.of(renderResult) == Type.Element
			or renderResult == nil
			or typeof(renderResult) == "boolean"
		then
			updateChildren(virtualNode, hostParent, renderResult)
		else
			error(("%s\n%s"):format(
				"Component returned invalid children:",
				virtualNode.currentElement.source or "<enable element tracebacks>"
			), 0)
		end
	end

	--[[
		Unmounts the given virtual node and releases any held resources.
	]]
	function unmountVirtualNode(virtualNode)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local kind = ElementKind.of(virtualNode.currentElement)

		if kind == ElementKind.Host then
			renderer.unmountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Stateful then
			virtualNode.instance:__unmount()
		elseif kind == ElementKind.Portal then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Fragment then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		else
			error(("Unknown ElementKind %q"):format(tostring(kind)), 2)
		end
	end

	local function updateFunctionVirtualNode(virtualNode, newElement)
		local children = newElement.component(newElement.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)

		return virtualNode
	end

	local function updatePortalVirtualNode(virtualNode, newElement)
		local oldElement = virtualNode.currentElement
		local oldTargetHostParent = oldElement.props.target

		local targetHostParent = newElement.props.target

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		if targetHostParent ~= oldTargetHostParent then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local children = newElement.props[Children]

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)

		return virtualNode
	end

	local function updateFragmentVirtualNode(virtualNode, newElement)
		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)

		return virtualNode
	end

	--[[
		Update the given virtual node using a new element describing what it
		should transform into.

		`updateVirtualNode` will return a new virtual node that should replace
		the passed in virtual node. This is because a virtual node can be
		updated with an element referencing a different component!

		In that case, `updateVirtualNode` will unmount the input virtual node,
		mount a new virtual node, and return it in this case, while also issuing
		a warning to the user.
	]]
	function updateVirtualNode(virtualNode, newElement, newState)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end
		if config.typeChecks then
			assert(
				Type.of(newElement) == Type.Element or typeof(newElement) == "boolean" or newElement == nil,
				"Expected arg #2 to be of type Element, boolean, or nil"
			)
		end

		-- If nothing changed, we can skip this update
		if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountVirtualNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local kind = ElementKind.of(newElement)

		local shouldContinueUpdate = true

		if kind == ElementKind.Host then
			virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)
		elseif kind == ElementKind.Function then
			virtualNode = updateFunctionVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Stateful then
			shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
		elseif kind == ElementKind.Portal then
			virtualNode = updatePortalVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Fragment then
			virtualNode = updateFragmentVirtualNode(virtualNode, newElement)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind)), 2)
		end

		-- Stateful components can abort updates via shouldUpdate. If that
		-- happens, we should stop doing stuff at this point.
		if not shouldContinueUpdate then
			return virtualNode
		end

		virtualNode.currentElement = newElement

		return virtualNode
	end

	--[[
		Constructs a new virtual node but not does mount it.
	]]
	local function createVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		return {
			[Type] = Type.VirtualNode,
			currentElement = element,
			depth = 1,
			parent = nil,
			children = {},
			hostParent = hostParent,
			hostKey = hostKey,

			-- Legacy Context API
			-- A table of context values inherited from the parent node
			legacyContext = legacyContext,

			-- A saved copy of the parent context, used when replacing a node
			parentLegacyContext = legacyContext,

			-- Context API
			-- A table of context values inherited from the parent node
			context = context or {},

			-- A saved copy of the unmodified context; this will be updated when
			-- a component adds new context and used when a node is replaced
			originalContext = nil,
		}
	end

	local function mountFunctionVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local children = element.component(element.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)
	end

	local function mountPortalVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local targetHostParent = element.props.target
		local children = element.props[Children]

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)
	end

	local function mountFragmentVirtualNode(virtualNode)
		local element = virtualNode.currentElement
		local children = element.elements

		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)
	end

	--[[
		Constructs a new virtual node and mounts it, but does not place it into
		the tree.
	]]
	function mountVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		-- Boolean values render as nil to enable terse conditional rendering.
		if typeof(element) == "boolean" then
			return nil
		end

		local kind = ElementKind.of(element)

		local virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)

		if kind == ElementKind.Host then
			renderer.mountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			mountFunctionVirtualNode(virtualNode)
		elseif kind == ElementKind.Stateful then
			element.component:__mount(reconciler, virtualNode)
		elseif kind == ElementKind.Portal then
			mountPortalVirtualNode(virtualNode)
		elseif kind == ElementKind.Fragment then
			mountFragmentVirtualNode(virtualNode)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind)), 2)
		end

		return virtualNode
	end

	--[[
		Constructs a new Roact virtual tree, constructs a root node for
		it, and mounts it.
	]]
	local function mountVirtualTree(element, hostParent, hostKey)
		if config.typeChecks then
			assert(Type.of(element) == Type.Element, "Expected arg #1 to be of type Element")
			assert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
		end

		if hostKey == nil then
			hostKey = "RoactTree"
		end

		local tree = {
			[Type] = Type.VirtualTree,
			[InternalData] = {
				-- The root node of the tree, which starts into the hierarchy of
				-- Roact component instances.
				rootNode = nil,
				mounted = true,
			},
		}

		tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)

		return tree
	end

	--[[
		Unmounts the virtual tree, freeing all of its resources.

		No further operations should be done on the tree after it's been
		unmounted, as indicated by its the `mounted` field.
	]]
	local function unmountVirtualTree(tree)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(internalData.mounted, "Cannot unmounted a Roact tree that has already been unmounted")
		end

		internalData.mounted = false

		if internalData.rootNode ~= nil then
			unmountVirtualNode(internalData.rootNode)
		end
	end

	--[[
		Utility method for updating the root node of a virtual tree given a new
		element.
	]]
	local function updateVirtualTree(tree, newElement)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(Type.of(newElement) == Type.Element, "Expected arg #2 to be a Roact Element")
		end

		internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)

		return tree
	end

	local function suspendParentEvents(virtualNode)
		local parentNode = virtualNode.parent
		while parentNode do
			if parentNode.eventManager ~= nil then
				parentNode.eventManager:suspend()
			end

			parentNode = parentNode.parent
		end
	end

	local function resumeParentEvents(virtualNode)
		local parentNode = virtualNode.parent
		while parentNode do
			if parentNode.eventManager ~= nil then
				parentNode.eventManager:resume()
			end

			parentNode = parentNode.parent
		end
	end

	reconciler = {
		mountVirtualTree = mountVirtualTree,
		unmountVirtualTree = unmountVirtualTree,
		updateVirtualTree = updateVirtualTree,

		createVirtualNode = createVirtualNode,
		mountVirtualNode = mountVirtualNode,
		unmountVirtualNode = unmountVirtualNode,
		updateVirtualNode = updateVirtualNode,
		updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,
		updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,

		suspendParentEvents = suspendParentEvents,
		resumeParentEvents = resumeParentEvents,
	}

	return reconciler
end

return createReconciler
 end,Properties={Name="createReconciler"},Reference=205,ClassName="ModuleScript"},{Closure=function() local assign = require(script.Parent.assign)
local None = require(script.Parent.None)
local Ref = require(script.Parent.PropMarkers.Ref)

local config = require(script.Parent.GlobalConfig).get()

local excludeRef = {
	[Ref] = None,
}

--[[
	Allows forwarding of refs to underlying host components. Accepts a render
	callback which accepts props and a ref, and returns an element.
]]
local function forwardRef(render)
	if config.typeChecks then
		assert(typeof(render) == "function", "Expected arg #1 to be a function")
	end

	return function(props)
		local ref = props[Ref]
		local propsWithoutRef = assign({}, props, excludeRef)

		return render(propsWithoutRef, ref)
	end
end

return forwardRef end,Properties={Name="forwardRef"},Reference=210,ClassName="ModuleScript"},{Closure=function() --[[
	A manager for a single host virtual node's connected events.
]]

local Logging = require(script.Parent.Logging)

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event = pcall(function()
		return self._instance:GetPropertyChangedSignal(key)
	end)

	if not success then
		error(("Cannot get changed signal on property %q: %s"):format(
			tostring(key),
			event
		), 0)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	while index <= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount))

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				Logging.warn("%s", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager end,Properties={Name="SingleEventManager"},Reference=197,ClassName="ModuleScript"}}}},Properties={Name="roact"},Reference=177,ClassName="Folder"},{Children={{ClassName="ModuleScript",Closure=function() local Store = require(script.Store)
local createReducer = require(script.createReducer)
local combineReducers = require(script.combineReducers)
local makeActionCreator = require(script.makeActionCreator)
local loggerMiddleware = require(script.loggerMiddleware)
local thunkMiddleware = require(script.thunkMiddleware)

return {
	Store = Store,
	createReducer = createReducer,
	combineReducers = combineReducers,
	makeActionCreator = makeActionCreator,
	loggerMiddleware = loggerMiddleware.middleware,
	thunkMiddleware = thunkMiddleware,
}
 end,Properties={Name="src"},Reference=248,Children={{Closure=function() --[[
	A middleware that allows for functions to be dispatched.
	Functions will receive a single argument, the store itself.
	This middleware consumes the function; middleware further down the chain
	will not receive it.
]]
local function tracebackReporter(message)
	return debug.traceback(message)
end

local function thunkMiddleware(nextDispatch, store)
	return function(action)
		if typeof(action) == "function" then
			local ok, result = xpcall(function()
				return action(store)
			end, tracebackReporter)

			if not ok then
				-- report the error and move on so it's non-fatal app
				store._errorReporter.reportReducerError(store:getState(), action, {
					message = "Caught error in thunk",
					thrownValue = result,
				})
				return nil
			end

			return result
		end

		return nextDispatch(action)
	end
end

return thunkMiddleware
 end,Properties={Name="thunkMiddleware"},Reference=257,ClassName="ModuleScript"},{Closure=function() return function(initialState, handlers)
	return function(state, action)
		if state == nil then
			state = initialState
		end

		local handler = handlers[action.type]

		if handler then
			return handler(state, action)
		end

		return state
	end
end
 end,Properties={Name="createReducer"},Reference=253,ClassName="ModuleScript"},{Closure=function() --!nocheck

--[[
	Calls a function and throws an error if it attempts to yield.

	Pass any number of arguments to the function after the callback.

	This function supports multiple return; all results returned from the
	given function will be returned.
]]

local function resultHandler(co, ok, ...)
	if not ok then
		local message = (...)
		error(debug.traceback(co, message), 2)
	end

	if coroutine.status(co) ~= "dead" then
		error(debug.traceback(co, "Attempted to yield inside changed event!"), 2)
	end

	return ...
end

local function NoYield(callback, ...)
	local co = coroutine.create(callback)

	return resultHandler(co, coroutine.resume(co, ...))
end

return NoYield
 end,Properties={Name="NoYield"},Reference=249,ClassName="ModuleScript"},{Closure=function() --[[
	A limited, simple implementation of a Signal.

	Handlers are fired in order, and (dis)connections are properly handled when
	executing an event.
]]
local function immutableAppend(list, ...)
	local new = {}
	local len = #list

	for key = 1, len do
		new[key] = list[key]
	end

	for i = 1, select("#", ...) do
		new[len + i] = select(i, ...)
	end

	return new
end

local function immutableRemoveValue(list, removeValue)
	local new = {}

	for i = 1, #list do
		if list[i] ~= removeValue then
			table.insert(new, list[i])
		end
	end

	return new
end

local Signal = {}

Signal.__index = Signal

function Signal.new(store)
	local self = {
		_listeners = {},
		_store = store
	}

	setmetatable(self, Signal)

	return self
end

function Signal:connect(callback)
	if typeof(callback) ~= "function" then
		error("Expected the listener to be a function.")
	end

	if self._store and self._store._isDispatching then
		error(
			'You may not call store.changed:connect() while the reducer is executing. ' ..
				'If you would like to be notified after the store has been updated, subscribe from a ' ..
				'component and invoke store:getState() in the callback to access the latest state. '
		)
	end

	local listener = {
		callback = callback,
		disconnected = false,
		connectTraceback = debug.traceback(),
		disconnectTraceback = nil
	}

	self._listeners = immutableAppend(self._listeners, listener)

	local function disconnect()
		if listener.disconnected then
			error((
				"Listener connected at: \n%s\n" ..
				"was already disconnected at: \n%s\n"
			):format(
				tostring(listener.connectTraceback),
				tostring(listener.disconnectTraceback)
			))
		end

		if self._store and self._store._isDispatching then
			error("You may not unsubscribe from a store listener while the reducer is executing.")
		end

		listener.disconnected = true
		listener.disconnectTraceback = debug.traceback()
		self._listeners = immutableRemoveValue(self._listeners, listener)
	end

	return {
		disconnect = disconnect
	}
end

function Signal:fire(...)
	for _, listener in ipairs(self._listeners) do
		if not listener.disconnected then
			listener.callback(...)
		end
	end
end

return Signal end,Properties={Name="Signal"},Reference=250,ClassName="ModuleScript"},{Closure=function() -- We want to be able to override outputFunction in tests, so the shape of this
-- module is kind of unconventional.
--
-- We fix it this weird shape in init.lua.
local prettyPrint = require(script.Parent.prettyPrint)
local loggerMiddleware = {
	outputFunction = print,
}

function loggerMiddleware.middleware(nextDispatch, store)
	return function(action)
		local result = nextDispatch(action)

		loggerMiddleware.outputFunction(("Action dispatched: %s\nState changed to: %s"):format(
			prettyPrint(action),
			prettyPrint(store:getState())
		))

		return result
	end
end

return loggerMiddleware
 end,Properties={Name="loggerMiddleware"},Reference=254,ClassName="ModuleScript"},{Closure=function() local indent = "    "

local function prettyPrint(value, indentLevel)
	indentLevel = indentLevel or 0
	local output = {}

	if typeof(value) == "table" then
		table.insert(output, "{\n")

		for tableKey, tableValue in pairs(value) do
			table.insert(output, indent:rep(indentLevel + 1))
			table.insert(output, tostring(tableKey))
			table.insert(output, " = ")

			table.insert(output, prettyPrint(tableValue, indentLevel + 1))
			table.insert(output, "\n")
		end

		table.insert(output, indent:rep(indentLevel))
		table.insert(output, "}")
	elseif typeof(value) == "string" then
		table.insert(output, string.format("%q", value))
		table.insert(output, " (string)")
	else
		table.insert(output, tostring(value))
		table.insert(output, " (")
		table.insert(output, typeof(value))
		table.insert(output, ")")
	end

	return table.concat(output, "")
end

return prettyPrint end,Properties={Name="prettyPrint"},Reference=256,ClassName="ModuleScript"},{Closure=function() --[[
	Create a composite reducer from a map of keys and sub-reducers.
]]
local function combineReducers(map)
	return function(state, action)
		-- If state is nil, substitute it with a blank table.
		if state == nil then
			state = {}
		end

		local newState = {}

		for key, reducer in pairs(map) do
			-- Each reducer gets its own state, not the entire state table
			newState[key] = reducer(state[key], action)
		end

		return newState
	end
end

return combineReducers
 end,Properties={Name="combineReducers"},Reference=252,ClassName="ModuleScript"},{Closure=function() local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Signal)
local NoYield = require(script.Parent.NoYield)

local ACTION_LOG_LENGTH = 3

local rethrowErrorReporter = {
	reportReducerError = function(prevState, action, errorResult)
		error(string.format("Received error: %s\n\n%s", errorResult.message, errorResult.thrownValue))
	end,
	reportUpdateError = function(prevState, currentState, lastActions, errorResult)
		error(string.format("Received error: %s\n\n%s", errorResult.message, errorResult.thrownValue))
	end,
}

local function tracebackReporter(message)
	return debug.traceback(tostring(message))
end

local Store = {}

-- This value is exposed as a private value so that the test code can stay in
-- sync with what event we listen to for dispatching the Changed event.
-- It may not be Heartbeat in the future.
Store._flushEvent = RunService.Heartbeat

Store.__index = Store

--[[
	Create a new Store whose state is transformed by the given reducer function.

	Each time an action is dispatched to the store, the new state of the store
	is given by:

		state = reducer(state, action)

	Reducers do not mutate the state object, so the original state is still
	valid.
]]
function Store.new(reducer, initialState, middlewares, errorReporter)
	assert(typeof(reducer) == "function", "Bad argument #1 to Store.new, expected function.")
	assert(middlewares == nil or typeof(middlewares) == "table", "Bad argument #3 to Store.new, expected nil or table.")
	if middlewares ~= nil then
		for i=1, #middlewares, 1 do
			assert(
				typeof(middlewares[i]) == "function",
				("Expected the middleware ('%s') at index %d to be a function."):format(tostring(middlewares[i]), i)
			)
		end
	end

	local self = {}

	self._errorReporter = errorReporter or rethrowErrorReporter
	self._isDispatching = false
	self._reducer = reducer
	local initAction = {
		type = "@@INIT",
	}
	self._actionLog = { initAction }
	local ok, result = xpcall(function()
		self._state = reducer(initialState, initAction)
	end, tracebackReporter)
	if not ok then
		self._errorReporter.reportReducerError(initialState, initAction, {
			message = "Caught error in reducer with init",
			thrownValue = result,
		})
		self._state = initialState
	end
	self._lastState = self._state

	self._mutatedSinceFlush = false
	self._connections = {}

	self.changed = Signal.new(self)

	setmetatable(self, Store)

	local connection = self._flushEvent:Connect(function()
		self:flush()
	end)
	table.insert(self._connections, connection)

	if middlewares then
		local unboundDispatch = self.dispatch
		local dispatch = function(...)
			return unboundDispatch(self, ...)
		end

		for i = #middlewares, 1, -1 do
			local middleware = middlewares[i]
			dispatch = middleware(dispatch, self)
		end

		self.dispatch = function(_self, ...)
			return dispatch(...)
		end
	end

	return self
end

--[[
	Get the current state of the Store. Do not mutate this!
]]
function Store:getState()
	if self._isDispatching then
		error(("You may not call store:getState() while the reducer is executing. " ..
			"The reducer (%s) has already received the state as an argument. " ..
			"Pass it down from the top reducer instead of reading it from the store."):format(tostring(self._reducer)))
	end

	return self._state
end

--[[
	Dispatch an action to the store. This allows the store's reducer to mutate
	the state of the application by creating a new copy of the state.

	Listeners on the changed event of the store are notified when the state
	changes, but not necessarily on every Dispatch.
]]
function Store:dispatch(action)
	if typeof(action) ~= "table" then
		error(("Actions must be tables. " ..
			"Use custom middleware for %q actions."):format(typeof(action)),
			2
		)
	end

	if action.type == nil then
		error("Actions may not have an undefined 'type' property. " ..
			"Have you misspelled a constant? \n" ..
			tostring(action), 2)
	end

	if self._isDispatching then
		error("Reducers may not dispatch actions.")
	end

	local ok, result = pcall(function()
		self._isDispatching = true
		self._state = self._reducer(self._state, action)
		self._mutatedSinceFlush = true
	end)

	self._isDispatching = false

	if not ok then
		self._errorReporter.reportReducerError(
			self._state,
			action,
			{
				message = "Caught error in reducer",
				thrownValue = result,
			}
		)
	end

	if #self._actionLog == ACTION_LOG_LENGTH then
		table.remove(self._actionLog, 1)
	end
	table.insert(self._actionLog, action)
end

--[[
	Marks the store as deleted, disconnecting any outstanding connections.
]]
function Store:destruct()
	for _, connection in ipairs(self._connections) do
		connection:Disconnect()
	end

	self._connections = nil
end

--[[
	Flush all pending actions since the last change event was dispatched.
]]
function Store:flush()
	if not self._mutatedSinceFlush then
		return
	end

	self._mutatedSinceFlush = false

	-- On self.changed:fire(), further actions may be immediately dispatched, in
	-- which case self._lastState will be set to the most recent self._state,
	-- unless we cache this value first
	local state = self._state

	local ok, errorResult = xpcall(function()
		-- If a changed listener yields, *very* surprising bugs can ensue.
		-- Because of that, changed listeners cannot yield.
		NoYield(function()
			self.changed:fire(state, self._lastState)
		end)
	end, tracebackReporter)

	if not ok then
		self._errorReporter.reportUpdateError(
			self._lastState,
			state,
			self._actionLog,
			{
				message = "Caught error flushing store updates",
				thrownValue = errorResult,
			}
		)
	end

	self._lastState = state
end

return Store
 end,Properties={Name="Store"},Reference=251,ClassName="ModuleScript"},{Closure=function() --[[
	A helper function to define a Rodux action creator with an associated name.
]]
local function makeActionCreator(name, fn)
	assert(type(name) == "string", "Bad argument #1: Expected a string name for the action creator")

	assert(type(fn) == "function", "Bad argument #2: Expected a function that creates action objects")

	return setmetatable({
		name = name,
	}, {
		__call = function(self, ...)
			local result = fn(...)

			assert(type(result) == "table", "Invalid action: An action creator must return a table")

			result.type = name

			return result
		end
	})
end

return makeActionCreator
 end,Properties={Name="makeActionCreator"},Reference=255,ClassName="ModuleScript"}}}},Properties={Name="rodux"},Reference=247,ClassName="Folder"},{Children={{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local exports = {}
exports.Provider = TS.import(script, script, "components", "provider").Provider
exports.useDispatch = TS.import(script, script, "hooks", "use-dispatch").useDispatch
exports.useSelector = TS.import(script, script, "hooks", "use-selector").useSelector
exports.useStore = TS.import(script, script, "hooks", "use-store").useStore
exports.shallowEqual = TS.import(script, script, "helpers", "shallow-equal").shallowEqual
exports.RoactRoduxContext = TS.import(script, script, "components", "context").RoactRoduxContext
return exports
 end,Properties={Name="out"},Reference=236,Children={{Children={{Closure=function() -- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local Object = TS.import(script, TS.getModule(script, "@rbxts", "object-utils"))
--[[
	*
	* Compares two arbitrary values for shallow equality. Object values are compared based on their keys, i.e. they must
	* have the same keys and for each key the value must be equal.
]]
local function shallowEqual(left, right)
	if left == right then
		return true
	end
	if not (type(left) == "table") or not (type(right) == "table") then
		return false
	end
	local keysLeft = Object.keys(left)
	local keysRight = Object.keys(right)
	if #keysLeft ~= #keysRight then
		return false
	end
	local _arg0 = function(value, index)
		return value == right[index]
	end
	-- \226\150\188 ReadonlyArray.every \226\150\188
	local _result = true
	for _k, _v in ipairs(keysLeft) do
		if not _arg0(_v, _k - 1, keysLeft) then
			_result = false
			break
		end
	end
	-- \226\150\178 ReadonlyArray.every \226\150\178
	return _result
end
return {
	shallowEqual = shallowEqual,
}
 end,Properties={Name="shallow-equal"},Reference=241,ClassName="ModuleScript"}},Properties={Name="helpers"},Reference=240,ClassName="Folder"},{Closure=function() -- Compiled with roblox-ts v1.2.3
--[[
	*
	* A Roact Context
]]
return nil
 end,Properties={Name="types"},Reference=246,ClassName="ModuleScript"},{Children={{Closure=function() -- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local RoactRoduxContext = TS.import(script, script.Parent, "context").RoactRoduxContext
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useMemo = _roact_hooked.useMemo
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
--[[
	*
	* Makes the Rodux store available to the `useStore()` calls in the component hierarchy below.
]]
local Provider = hooked(function(_param)
	local store = _param.store
	local children = _param[Roact.Children]
	local contextValue = useMemo(function()
		return {
			store = store,
		}
	end, { store })
	local _ptr = {
		value = contextValue,
	}
	local _ptr_1 = {}
	local _length = #_ptr_1
	if children then
		for _k, _v in pairs(children) do
			if type(_k) == "number" then
				_ptr_1[_length + _k] = _v
			else
				_ptr_1[_k] = _v
			end
		end
	end
	return Roact.createElement(RoactRoduxContext.Provider, _ptr, _ptr_1)
end)
return {
	Provider = Provider,
}
 end,Properties={Name="provider"},Reference=239,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local RoactRoduxContext = Roact.createContext(nil)
return {
	RoactRoduxContext = RoactRoduxContext,
}
 end,Properties={Name="context"},Reference=238,ClassName="ModuleScript"}},Properties={Name="components"},Reference=237,ClassName="Folder"},{Children={{Closure=function() -- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local useEffect = _roact_hooked.useEffect
local useMutable = _roact_hooked.useMutable
local useReducer = _roact_hooked.useReducer
local useStore = TS.import(script, script.Parent, "use-store").useStore
--[[
	*
	* This interface allows you to easily create a hook that is properly typed for your store's root state.
	*
	* @example
	* interface RootState {
	*   property: string;
	* }
	*
	* const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
]]
--[[
	*
	* A hook to access the Rodux Store's state. This hook takes a selector function as an argument. The selector is called
	* with the store state.
	*
	* This hook takes an optional equality comparison function as the second parameter that allows you to customize the
	* way the selected state is compared to determine whether the component needs to be re-rendered.
	*
	* @param selector - The selector function
	* @param equalityFn - The function that will be used to determine equality
	*
	* @returns The selected portion of the state
	*
	* @example
	* import Roact from "@rbxts/roact";
	* import { hooked } from "@rbxts/roact-hooked";
	* import { useSelector } from "@rbxts/roact-rodux-hooked";
	* import type { RootState } from "./store";
	*
	* export const CounterComponent = hooked(() => {
	*   const count = useSelector((state: RootState) => state.counter);
	*   return <textlabel Text={`Counter: ${count}`} />;
	* });
]]
local function useSelector(selector, equalityFn)
	if equalityFn == nil then
		equalityFn = function(a, b)
			return a == b
		end
	end
	local _binding = useReducer(function(s)
		return s + 1
	end, 0)
	local forceRender = _binding[2]
	local store = useStore()
	local latestSubscriptionCallbackError = useMutable()
	local latestSelector = useMutable()
	local latestStoreState = useMutable()
	local latestSelectedState = useMutable()
	local storeState = store:getState()
	local selectedState
	TS.try(function()
		local _value = selector ~= latestSelector.current or storeState ~= latestStoreState.current or latestSubscriptionCallbackError.current
		if _value ~= "" and _value then
			local newSelectedState = selector(storeState)
			-- ensure latest selected state is reused so that a custom equality function can result in identical references
			if latestSelectedState.current == nil or not equalityFn(newSelectedState, latestSelectedState.current) then
				selectedState = newSelectedState
			else
				selectedState = latestSelectedState.current
			end
		else
			selectedState = latestSelectedState.current
		end
	end, function(err)
		if latestSubscriptionCallbackError.current ~= nil then
			err ..= "\nThe error may be correlated with this previous error:\n" .. latestSubscriptionCallbackError.current .. "\n\n"
		end
		error(err)
	end)
	useEffect(function()
		latestSelector.current = selector
		latestStoreState.current = storeState
		latestSelectedState.current = selectedState
		latestSubscriptionCallbackError.current = nil
	end)
	useEffect(function()
		local function checkForUpdates(newStoreState)
			local _exitType, _returns = TS.try(function()
				-- Avoid calling selector multiple times if the store's state has not changed
				if newStoreState == latestStoreState.current then
					return TS.TRY_RETURN, {}
				end
				local newSelectedState = latestSelector.current(newStoreState)
				if equalityFn(newSelectedState, latestSelectedState.current) then
					return TS.TRY_RETURN, {}
				end
				latestSelectedState.current = newSelectedState
				latestStoreState.current = newStoreState
			end, function(err)
				-- we ignore all errors here, since when the component
				-- is re-rendered, the selectors are called again, and
				-- will throw again, if neither props nor store state
				-- changed
				latestSubscriptionCallbackError.current = err
			end)
			if _exitType then
				return unpack(_returns)
			end
			task.spawn(forceRender)
		end
		local subscription = store.changed:connect(checkForUpdates)
		checkForUpdates(store:getState())
		return function()
			return subscription:disconnect()
		end
	end, { store })
	return selectedState
end
return {
	useSelector = useSelector,
}
 end,Properties={Name="use-selector"},Reference=244,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local useMutable = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).useMutable
local useStore = TS.import(script, script.Parent, "use-store").useStore
--[[
	*
	* A hook to access the Rodux Store's `dispatch` method.
	*
	* @returns Rodux store's `dispatch` method
	*
	* @example
	* import Roact from "@rbxts/roact";
	* import { hooked } from "@rbxts/roact-hooked";
	* import { useDispatch } from "@rbxts/roact-rodux-hooked";
	* import type { RootStore } from "./store";
	*
	* export const CounterComponent = hooked(() => {
	*   const dispatch = useDispatch<RootStore>();
	*   return (
	*     <textlabel
	*       Text={"Increase counter"}
	*       Event={{
	*         Activated: () => dispatch({ type: "increase-counter" }),
	*       }}
	*     />
	*   );
	* });
]]
local function useDispatch()
	local store = useStore()
	return useMutable(function(action)
		return store:dispatch(action)
	end).current
end
return {
	useDispatch = useDispatch,
}
 end,Properties={Name="use-dispatch"},Reference=243,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local RoactRoduxContext = TS.import(script, script.Parent.Parent, "components", "context").RoactRoduxContext
local useContext = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).useContext
--[[
	*
	* A hook to access the Rodux Store.
	*
	* @returns The Rodux store
	*
	* @example
	* import Roact from "@rbxts/roact";
	* import { hooked } from "@rbxts/roact-hooked";
	* import { useStore } from "@rbxts/roact-rodux-hooked";
	* import type { RootStore } from "./store";
	*
	* export const CounterComponent = hooked(() => {
	*   const store = useStore<RootStore>();
	*   return <textlabel Text={store.getState()} />;
	* });
]]
local function useStore()
	return useContext(RoactRoduxContext).store
end
return {
	useStore = useStore,
}
 end,Properties={Name="use-store"},Reference=245,ClassName="ModuleScript"}},Properties={Name="hooks"},Reference=242,ClassName="Folder"}}}},Properties={Name="roact-rodux-hooked"},Reference=235,ClassName="Folder"},{Closure=function() local HttpService = game:GetService("HttpService")

local Object = {}

function Object.keys(object)
	local result = table.create(#object)
	for key in pairs(object) do
		result[#result + 1] = key
	end
	return result
end

function Object.values(object)
	local result = table.create(#object)
	for _, value in pairs(object) do
		result[#result + 1] = value
	end
	return result
end

function Object.entries(object)
	local result = table.create(#object)
	for key, value in pairs(object) do
		result[#result + 1] = { key, value }
	end
	return result
end

function Object.assign(toObj, ...)
	for i = 1, select("#", ...) do
		local arg = select(i, ...)
		if type(arg) == "table" then
			for key, value in pairs(arg) do
				toObj[key] = value
			end
		end
	end
	return toObj
end

function Object.copy(object)
	local result = table.create(#object)
	for k, v in pairs(object) do
		result[k] = v
	end
	return result
end

local function deepCopyHelper(object, encountered)
	local result = table.create(#object)
	encountered[object] = result

	for k, v in pairs(object) do
		if type(k) == "table" then
			k = encountered[k] or deepCopyHelper(k, encountered)
		end

		if type(v) == "table" then
			v = encountered[v] or deepCopyHelper(v, encountered)
		end

		result[k] = v
	end

	return result
end

function Object.deepCopy(object)
	return deepCopyHelper(object, {})
end

function Object.deepEquals(a, b)
	-- a[k] == b[k]
	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = Object.deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

function Object.toString(data)
	return HttpService:JSONEncode(data)
end

function Object.isEmpty(object)
	return next(object) == nil
end

function Object.fromEntries(entries)
	local entriesLen = #entries

	local result = table.create(entriesLen)
	if entries then
		for i = 1, entriesLen do
			local pair = entries[i]
			result[pair[1]] = pair[2]
		end
	end
	return result
end

return Object
 end,Properties={Name="object-utils"},Reference=176,ClassName="ModuleScript"},{Children={{ClassName="ModuleScript",Closure=function() local Flipper = {
	SingleMotor = require(script.SingleMotor),
	GroupMotor = require(script.GroupMotor),

	Instant = require(script.Instant),
	Linear = require(script.Linear),
	Spring = require(script.Spring),
	
	isMotor = require(script.isMotor),
}

return Flipper end,Properties={Name="src"},Reference=161,Children={{Closure=function() local BaseMotor = require(script.Parent.BaseMotor)

local SingleMotor = setmetatable({}, BaseMotor)
SingleMotor.__index = SingleMotor

function SingleMotor.new(initialValue, useImplicitConnections)
	assert(initialValue, "Missing argument #1: initialValue")
	assert(typeof(initialValue) == "number", "initialValue must be a number!")

	local self = setmetatable(BaseMotor.new(), SingleMotor)

	if useImplicitConnections ~= nil then
		self._useImplicitConnections = useImplicitConnections
	else
		self._useImplicitConnections = true
	end

	self._goal = nil
	self._state = {
		complete = true,
		value = initialValue,
	}

	return self
end

function SingleMotor:step(deltaTime)
	if self._state.complete then
		return true
	end

	local newState = self._goal:step(self._state, deltaTime)

	self._state = newState
	self._onStep:fire(newState.value)

	if newState.complete then
		if self._useImplicitConnections then
			self:stop()
		end

		self._onComplete:fire()
	end

	return newState.complete
end

function SingleMotor:getValue()
	return self._state.value
end

function SingleMotor:setGoal(goal)
	self._state.complete = false
	self._goal = goal

	self._onStart:fire()

	if self._useImplicitConnections then
		self:start()
	end
end

function SingleMotor:__tostring()
	return "Motor(Single)"
end

return SingleMotor
 end,Properties={Name="SingleMotor"},Reference=167,ClassName="ModuleScript"},{Closure=function() local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Signal)

local noop = function() end

local BaseMotor = {}
BaseMotor.__index = BaseMotor

function BaseMotor.new()
	return setmetatable({
		_onStep = Signal.new(),
		_onStart = Signal.new(),
		_onComplete = Signal.new(),
	}, BaseMotor)
end

function BaseMotor:onStep(handler)
	return self._onStep:connect(handler)
end

function BaseMotor:onStart(handler)
	return self._onStart:connect(handler)
end

function BaseMotor:onComplete(handler)
	return self._onComplete:connect(handler)
end

function BaseMotor:start()
	if not self._connection then
		self._connection = RunService.RenderStepped:Connect(function(deltaTime)
			self:step(deltaTime)
		end)
	end
end

function BaseMotor:stop()
	if self._connection then
		self._connection:Disconnect()
		self._connection = nil
	end
end

BaseMotor.destroy = BaseMotor.stop

BaseMotor.step = noop
BaseMotor.getValue = noop
BaseMotor.setGoal = noop

function BaseMotor:__tostring()
	return "Motor"
end

return BaseMotor
 end,Properties={Name="BaseMotor"},Reference=162,ClassName="ModuleScript"},{Closure=function() local Connection = {}
Connection.__index = Connection

function Connection.new(signal, handler)
	return setmetatable({
		signal = signal,
		connected = true,
		_handler = handler,
	}, Connection)
end

function Connection:disconnect()
	if self.connected then
		self.connected = false

		for index, connection in pairs(self.signal._connections) do
			if connection == self then
				table.remove(self.signal._connections, index)
				return
			end
		end
	end
end

local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_connections = {},
		_threads = {},
	}, Signal)
end

function Signal:fire(...)
	for _, connection in pairs(self._connections) do
		connection._handler(...)
	end

	for _, thread in pairs(self._threads) do
		coroutine.resume(thread, ...)
	end
	
	self._threads = {}
end

function Signal:connect(handler)
	local connection = Connection.new(self, handler)
	table.insert(self._connections, connection)
	return connection
end

function Signal:wait()
	table.insert(self._threads, coroutine.running())
	return coroutine.yield()
end

return Signal end,Properties={Name="Signal"},Reference=166,ClassName="ModuleScript"},{Closure=function() local function isMotor(value)
	local motorType = tostring(value):match("^Motor%((.+)%)$")

	if motorType then
		return true, motorType
	else
		return false
	end
end

return isMotor end,Properties={Name="isMotor"},Reference=169,ClassName="ModuleScript"},{Closure=function() local BaseMotor = require(script.Parent.BaseMotor)
local SingleMotor = require(script.Parent.SingleMotor)

local isMotor = require(script.Parent.isMotor)

local GroupMotor = setmetatable({}, BaseMotor)
GroupMotor.__index = GroupMotor

local function toMotor(value)
	if isMotor(value) then
		return value
	end

	local valueType = typeof(value)

	if valueType == "number" then
		return SingleMotor.new(value, false)
	elseif valueType == "table" then
		return GroupMotor.new(value, false)
	end

	error(("Unable to convert %q to motor; type %s is unsupported"):format(value, valueType), 2)
end

function GroupMotor.new(initialValues, useImplicitConnections)
	assert(initialValues, "Missing argument #1: initialValues")
	assert(typeof(initialValues) == "table", "initialValues must be a table!")
	assert(not initialValues.step, "initialValues contains disallowed property \"step\". Did you mean to put a table of values here?")

	local self = setmetatable(BaseMotor.new(), GroupMotor)

	if useImplicitConnections ~= nil then
		self._useImplicitConnections = useImplicitConnections
	else
		self._useImplicitConnections = true
	end

	self._complete = true
	self._motors = {}

	for key, value in pairs(initialValues) do
		self._motors[key] = toMotor(value)
	end

	return self
end

function GroupMotor:step(deltaTime)
	if self._complete then
		return true
	end

	local allMotorsComplete = true

	for _, motor in pairs(self._motors) do
		local complete = motor:step(deltaTime)
		if not complete then
			-- If any of the sub-motors are incomplete, the group motor will not be complete either
			allMotorsComplete = false
		end
	end

	self._onStep:fire(self:getValue())

	if allMotorsComplete then
		if self._useImplicitConnections then
			self:stop()
		end

		self._complete = true
		self._onComplete:fire()
	end

	return allMotorsComplete
end

function GroupMotor:setGoal(goals)
	assert(not goals.step, "goals contains disallowed property \"step\". Did you mean to put a table of goals here?")

	self._complete = false
	self._onStart:fire()

	for key, goal in pairs(goals) do
		local motor = assert(self._motors[key], ("Unknown motor for key %s"):format(key))
		motor:setGoal(goal)
	end

	if self._useImplicitConnections then
		self:start()
	end
end

function GroupMotor:getValue()
	local values = {}

	for key, motor in pairs(self._motors) do
		values[key] = motor:getValue()
	end

	return values
end

function GroupMotor:__tostring()
	return "Motor(Group)"
end

return GroupMotor
 end,Properties={Name="GroupMotor"},Reference=163,ClassName="ModuleScript"},{Closure=function() local VELOCITY_THRESHOLD = 0.001
local POSITION_THRESHOLD = 0.001

local EPS = 0.0001

local Spring = {}
Spring.__index = Spring

function Spring.new(targetValue, options)
	assert(targetValue, "Missing argument #1: targetValue")
	options = options or {}

	return setmetatable({
		_targetValue = targetValue,
		_frequency = options.frequency or 4,
		_dampingRatio = options.dampingRatio or 1,
	}, Spring)
end

function Spring:step(state, dt)
	-- Copyright 2018 Parker Stebbins (parker@fractality.io)
	-- github.com/Fraktality/Spring
	-- Distributed under the MIT license

	local d = self._dampingRatio
	local f = self._frequency*2*math.pi
	local g = self._targetValue
	local p0 = state.value
	local v0 = state.velocity or 0

	local offset = p0 - g
	local decay = math.exp(-d*f*dt)

	local p1, v1

	if d == 1 then -- Critically damped
		p1 = (offset*(1 + f*dt) + v0*dt)*decay + g
		v1 = (v0*(1 - f*dt) - offset*(f*f*dt))*decay
	elseif d < 1 then -- Underdamped
		local c = math.sqrt(1 - d*d)

		local i = math.cos(f*c*dt)
		local j = math.sin(f*c*dt)

		-- Damping ratios approaching 1 can cause division by small numbers.
		-- To fix that, group terms around z=j/c and find an approximation for z.
		-- Start with the definition of z:
		--    z = sin(dt*f*c)/c
		-- Substitute a=dt*f:
		--    z = sin(a*c)/c
		-- Take the Maclaurin expansion of z with respect to c:
		--    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)
		--    z \226\137\136 a - (a^3*c^2)/6 + (a^5*c^4)/120
		-- Rewrite in Horner form:
		--    z \226\137\136 a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6

		local z
		if c > EPS then
			z = j/c
		else
			local a = dt*f
			z = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6
		end

		-- Frequencies approaching 0 present a similar problem.
		-- We want an approximation for y as f approaches 0, where:
		--    y = sin(dt*f*c)/(f*c)
		-- Substitute b=dt*c:
		--    y = sin(b*c)/b
		-- Now reapply the process from z.

		local y
		if f*c > EPS then
			y = j/(f*c)
		else
			local b = f*c
			y = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6
		end

		p1 = (offset*(i + d*z) + v0*y)*decay + g
		v1 = (v0*(i - z*d) - offset*(z*f))*decay

	else -- Overdamped
		local c = math.sqrt(d*d - 1)

		local r1 = -f*(d - c)
		local r2 = -f*(d + c)

		local co2 = (v0 - offset*r1)/(2*f*c)
		local co1 = offset - co2

		local e1 = co1*math.exp(r1*dt)
		local e2 = co2*math.exp(r2*dt)

		p1 = e1 + e2 + g
		v1 = e1*r1 + e2*r2
	end

	local complete = math.abs(v1) < VELOCITY_THRESHOLD and math.abs(p1 - g) < POSITION_THRESHOLD
	
	return {
		complete = complete,
		value = complete and g or p1,
		velocity = v1,
	}
end

return Spring end,Properties={Name="Spring"},Reference=168,ClassName="ModuleScript"},{Closure=function() local Instant = {}
Instant.__index = Instant

function Instant.new(targetValue)
	return setmetatable({
		_targetValue = targetValue,
	}, Instant)
end

function Instant:step()
	return {
		complete = true,
		value = self._targetValue,
	}
end

return Instant end,Properties={Name="Instant"},Reference=164,ClassName="ModuleScript"},{Closure=function() local Linear = {}
Linear.__index = Linear

function Linear.new(targetValue, options)
	assert(targetValue, "Missing argument #1: targetValue")
	
	options = options or {}

	return setmetatable({
		_targetValue = targetValue,
		_velocity = options.velocity or 1,
	}, Linear)
end

function Linear:step(state, dt)
	local position = state.value
	local velocity = self._velocity -- Linear motion ignores the state's velocity
	local goal = self._targetValue

	local dPos = dt * velocity

	local complete = dPos >= math.abs(goal - position)
	position = position + dPos * (goal > position and 1 or -1)
	if complete then
		position = self._targetValue
		velocity = 0
	end
	
	return {
		complete = complete,
		value = position,
		velocity = velocity,
	}
end

return Linear end,Properties={Name="Linear"},Reference=165,ClassName="ModuleScript"}}},{Properties={Name="typings"},Reference=170,ClassName="Folder"}},Properties={Name="flipper"},Reference=160,ClassName="Folder"}},Properties={Name="node_modules"},Reference=155,ClassName="Folder"},{Closure=function() --[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = {__mode = "k"}

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.
]]
local Error do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(errorStrings, table.concat({
				runtimeError.trace or runtimeError.error,
				runtimeError.context,
			}, "\n"))
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end


local function makeErrorHandler(traceback)
	assert(traceback ~= nil)

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", {"Started", "Resolved", "Rejected", "Cancelled"}),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
}
Promise.prototype = {}
Promise.__index = Promise.prototype

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(
			self._source,
			callback,
			resolve,
			reject,
			onCancel
		)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self:getStatus())
end

--[[
	Promise.new, except pcall on a new thread is automatic.
]]
function Promise.defer(callback)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, callback, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[[
	Begins a Promise chain, turning synchronous errors into rejections.
]]
function Promise.try(...)
	return Promise._try(debug.traceback(nil, 2), ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					rejectedCount = rejectedCount + 1

					if amount == nil or #promises - rejectedCount < amount then
						cancel()
						done = true

						reject(...)
					end
				end
			)
		end

		if done then
			cancel()
		end
	end)
end

function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

function Promise.fold(list, callback, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(type(callback) == "function", "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return callback(previousValueResolved, resolvedElement, i)
		end)
	end):andThenReturn(accumulator)
end

function Promise.some(promises, amount)
	assert(type(amount) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, amount)
end

function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(
				function(...)
					resolveOne(i, ...)
				end
			)
		end
	end)
end

--[[
	Races a set of Promises and returns the first one that resolves,
	cancelling the others.
]]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function (...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[[
	Iterates serially over the given an array of values, calling the predicate callback on each before continuing.
	If the predicate returns a Promise, we wait for that Promise to resolve before continuing to the next item
	in the array. If the Promise the predicate returns rejects, the Promise from Promise.each is also rejected with
	the same value.

	Returns a Promise containing an array of the return values from the predicate for each item in the original list.
]]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(type(predicate) == "function", string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return type(object.andThen) == "function"
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and type(rawget(rawget(objectMetatable, "__index"), "andThen")) == "function"
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[[
	Converts a yielding function into a Promise-returning one.
]]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[[
	Creates a Promise that resolves after given number of seconds.
]]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[[
	Rejects the promise after `seconds` seconds.
]]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(
				traceback,
				successHandler,
				resolve,
				reject
			)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(
				traceback,
				failureHandler,
				resolve,
				reject
			)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

function Promise.prototype:andThen(successHandler, failureHandler)
	assert(
		successHandler == nil or type(successHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)
	assert(
		failureHandler == nil or type(failureHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	assert(
		failureCallback == nil or type(failureCallback) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:catch")
	)
	return self:_andThen(debug.traceback(nil, 2), nil, failureCallback)
end

--[[
	Like andThen, but the value passed into the handler is also the
	value returned from the handler.
]]
function Promise.prototype:tap(tapCallback)
	assert(type(tapCallback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapCallback(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[[
	Calls a callback on `andThen` with specific arguments.
]]
function Promise.prototype:andThenCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for an andThen handler that returns the given value.
]]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(
				traceback,
				finallyHandler,
				resolve,
				reject
			)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

function Promise.prototype:finally(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:finally")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[[
	Calls a callback on `finally` with specific arguments.
]]
function Promise.prototype:finallyCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for a finally handler that returns the given value.
]]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Similar to finally, except rejections are propagated through it.
]]
function Promise.prototype:done(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:done")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler, true)
end

--[[
	Calls a callback on `done` with specific arguments.
]]
function Promise.prototype:doneCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[[
	Shorthand for a done handler that returns the given value.
]]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[[
	Calls awaitStatus internally, returns (isResolved, values...)
]]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[[
	Calls await and only returns if the Promise resolves.
	Throws if the Promise rejects or gets cancelled.
]]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				local maybeRuntimeError = chainedPromise._values[1]

				-- Backwards compatibility < v2
				if chainedPromise._error then
					maybeRuntimeError = Error.new({
						error = chainedPromise._error,
						kind = Error.Kind.ExecutionError,
						context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
					})
				end

				if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
					return self:_reject(maybeRuntimeError:extend({
						error = "This Promise was chained to a Promise that errored.",
						trace = "",
						context = string.format(
							"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
							self._source
						),
					}))
				end

				self:_reject(...)
			end
		)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format(
				"Unhandled Promise rejection:\n\n%s\n\n%s",
				err,
				self._source
			)

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[[
	Chains a Promise from this one that is resolved if this Promise is
	resolved, and rejected if it is not resolved.
]]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self:getStatus() == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[[
	Retries a Promise-returning callback N times until it succeeds.
]]
function Promise.retry(callback, times, ...)
	assert(type(callback) == "function", "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = {...}, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[[
	Converts an event into a Promise with an optional predicate
]]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(function()
			disconnect()
		end)
	end)
end

return Promise
 end,Properties={Name="Promise"},Reference=153,ClassName="ModuleScript"}},Properties={Name="include"},Reference=152,ClassName="Folder"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Dashboard = TS.import(script, script.Parent, "views", "Dashboard").default
local DISPLAY_ORDER = 7
local function App()
	return Roact.createElement("ScreenGui", {
		IgnoreGuiInset = true,
		ResetOnSpawn = false,
		ZIndexBehavior = "Sibling",
		DisplayOrder = DISPLAY_ORDER,
	}, {
		Roact.createElement(Dashboard),
	})
end
local default = App
return {
	default = default,
}
 end,Properties={Name="App"},Reference=2,ClassName="ModuleScript"},{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local useAppSelector = TS.import(script, script.Parent, "common", "rodux-hooks").useAppSelector
local getThemes = TS.import(script, script.Parent.Parent, "themes").getThemes
local darkTheme = TS.import(script, script.Parent.Parent, "themes", "dark-theme").darkTheme
local function useTheme(key)
	return useAppSelector(function(state)
		local _exp = getThemes()
		local _arg0 = function(t)
			return t.name == state.options.currentTheme
		end
		-- \226\150\188 ReadonlyArray.find \226\150\188
		local _result = nil
		for _i, _v in ipairs(_exp) do
			if _arg0(_v, _i - 1, _exp) == true then
				_result = _v
				break
			end
		end
		-- \226\150\178 ReadonlyArray.find \226\150\178
		local theme = _result
		return theme and theme[key] or darkTheme[key]
	end)
end
return {
	useTheme = useTheme,
}
 end,Properties={Name="use-theme"},Reference=43,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local useAppSelector = TS.import(script, script.Parent, "common", "rodux-hooks").useAppSelector
local function useCurrentPage()
	return useAppSelector(function(state)
		return state.dashboard.page
	end)
end
local function useIsPageOpen(page)
	return useAppSelector(function(state)
		return state.dashboard.isOpen and state.dashboard.page == page
	end)
end
return {
	useCurrentPage = useCurrentPage,
	useIsPageOpen = useIsPageOpen,
}
 end,Properties={Name="use-current-page"},Reference=39,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local useMemo = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).useMemo
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local usePromise = TS.import(script, script.Parent, "common", "use-promise").usePromise
local function useFriends(deps)
	return usePromise(TS.async(function()
		return Players.LocalPlayer:GetFriendsOnline()
	end), deps)
end
local function useFriendsPlaying(deps)
	local _binding = useFriends(deps)
	local friends = _binding[1]
	local err = _binding[2]
	local status = _binding[3]
	local _friendsPlaying = friends
	if _friendsPlaying ~= nil then
		local _arg0 = function(friend)
			return friend.PlaceId ~= nil and friend.GameId ~= nil
		end
		-- \226\150\188 ReadonlyArray.filter \226\150\188
		local _newValue = {}
		local _length = 0
		for _k, _v in ipairs(_friendsPlaying) do
			if _arg0(_v, _k - 1, _friendsPlaying) == true then
				_length += 1
				_newValue[_length] = _v
			end
		end
		-- \226\150\178 ReadonlyArray.filter \226\150\178
		_friendsPlaying = _newValue
	end
	local friendsPlaying = _friendsPlaying
	return { friendsPlaying, err, status }
end
local function useFriendActivity(deps)
	local _binding = useFriendsPlaying(deps)
	local friends = _binding[1]
	local err = _binding[2]
	local status = _binding[3]
	local games = useMemo(function()
		return {}
	end, deps)
	if not friends or #games > 0 then
		return { games, err, status }
	end
	local _arg0 = function(friend)
		local _arg0_1 = function(g)
			return g.placeId == friend.PlaceId
		end
		-- \226\150\188 ReadonlyArray.find \226\150\188
		local _result = nil
		for _i, _v in ipairs(games) do
			if _arg0_1(_v, _i - 1, games) == true then
				_result = _v
				break
			end
		end
		-- \226\150\178 ReadonlyArray.find \226\150\178
		local gameActivity = _result
		if not gameActivity then
			gameActivity = {
				friends = { friend },
				placeId = friend.PlaceId,
				thumbnail = "https://www.roblox.com/asset-thumbnail/image?assetId=" .. (tostring(friend.PlaceId) .. "&width=768&height=432&format=png"),
			}
			local _gameActivity = gameActivity
			-- \226\150\188 Array.push \226\150\188
			games[#games + 1] = _gameActivity
			-- \226\150\178 Array.push \226\150\178
		else
			local _friends = gameActivity.friends
			-- \226\150\188 Array.push \226\150\188
			_friends[#_friends + 1] = friend
			-- \226\150\178 Array.push \226\150\178
		end
	end
	-- \226\150\188 ReadonlyArray.forEach \226\150\188
	for _k, _v in ipairs(friends) do
		_arg0(_v, _k - 1, friends)
	end
	-- \226\150\178 ReadonlyArray.forEach \226\150\178
	return { games, err, status }
end
return {
	useFriends = useFriends,
	useFriendsPlaying = useFriendsPlaying,
	useFriendActivity = useFriendActivity,
}
 end,Properties={Name="use-friends"},Reference=40,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local useContext = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).useContext
local ScaleContext = TS.import(script, script.Parent.Parent, "context", "scale-context").ScaleContext
local defaultScale = Roact.createBinding(1)
local function useScale()
	local _condition = useContext(ScaleContext)
	if _condition == nil then
		_condition = defaultScale
	end
	return _condition
end
return {
	useScale = useScale,
}
 end,Properties={Name="use-scale"},Reference=42,ClassName="ModuleScript"},{Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local useBinding = _roact_hooked.useBinding
local useEffect = _roact_hooked.useEffect
local UserInputService = TS.import(script, TS.getModule(script, "@rbxts", "services")).UserInputService
local function useMouseLocation(onChange)
	local _binding = useBinding(UserInputService:GetMouseLocation())
	local location = _binding[1]
	local setLocation = _binding[2]
	useEffect(function()
		local handle = UserInputService.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement then
				setLocation(Vector2.new(input.Position.X, input.Position.Y))
				local _result = onChange
				if _result ~= nil then
					_result(Vector2.new(input.Position.X, input.Position.Y))
				end
			end
		end)
		return function()
			handle:Disconnect()
		end
	end, {})
	return location
end
return {
	useMouseLocation = useMouseLocation,
}
 end,Properties={Name="use-mouse-location"},Reference=34,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _roact_rodux_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-rodux-hooked").out)
local useDispatch = _roact_rodux_hooked.useDispatch
local useSelector = _roact_rodux_hooked.useSelector
local useStore = _roact_rodux_hooked.useStore
local useAppSelector = useSelector
local useAppDispatch = function()
	return useDispatch()
end
local useAppStore = function()
	return useStore()
end
return {
	useAppSelector = useAppSelector,
	useAppDispatch = useAppDispatch,
	useAppStore = useAppStore,
}
 end,Properties={Name="rodux-hooks"},Reference=29,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local useEffect = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).useEffect
local _timeout = TS.import(script, script.Parent.Parent.Parent, "utils", "timeout")
local clearInterval = _timeout.clearInterval
local setInterval = _timeout.setInterval
local function useInterval(callback, delay, deps)
	if deps == nil then
		deps = {}
	end
	local _exp = function()
		if delay ~= nil then
			local interval = setInterval(callback, delay)
			return function()
				return clearInterval(interval)
			end
		end
	end
	local _array = { callback, delay }
	local _length = #_array
	table.move(deps, 1, #deps, _length + 1, _array)
	useEffect(_exp, _array)
	return setInterval
end
return {
	useInterval = useInterval,
}
 end,Properties={Name="use-interval"},Reference=33,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local useBinding = _roact_hooked.useBinding
local useEffect = _roact_hooked.useEffect
local useState = _roact_hooked.useState
local Workspace = TS.import(script, TS.getModule(script, "@rbxts", "services")).Workspace
local function useViewportSize(onChange)
	local _binding = useState(Workspace.CurrentCamera)
	local camera = _binding[1]
	local setCamera = _binding[2]
	local _binding_1 = useBinding(camera.ViewportSize)
	local size = _binding_1[1]
	local setSize = _binding_1[2]
	useEffect(function()
		local handle = Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
			if Workspace.CurrentCamera then
				setCamera(Workspace.CurrentCamera)
				setSize(Workspace.CurrentCamera.ViewportSize)
				local _result = onChange
				if _result ~= nil then
					_result(Workspace.CurrentCamera.ViewportSize)
				end
			end
		end)
		return function()
			handle:Disconnect()
		end
	end, {})
	useEffect(function()
		local handle = camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
			setSize(camera.ViewportSize)
			local _result = onChange
			if _result ~= nil then
				_result(camera.ViewportSize)
			end
		end)
		return function()
			handle:Disconnect()
		end
	end, { camera })
	return size
end
return {
	useViewportSize = useViewportSize,
}
 end,Properties={Name="use-viewport-size"},Reference=38,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local useState = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).useState
local function useSetState(initialState)
	local _binding = useState(initialState)
	local state = _binding[1]
	local setState = _binding[2]
	local merge = function(action)
		return setState(function(s)
			local _object = {}
			if type(s) == "table" then
				for _k, _v in pairs(s) do
					_object[_k] = _v
				end
			end
			local _result
			if type(action) == "function" then
				_result = action(s)
			else
				_result = action
			end
			if type(_result) == "table" then
				for _k, _v in pairs(_result) do
					_object[_k] = _v
				end
			end
			return _object
		end)
	end
	return { state, merge }
end
return {
	default = useSetState,
}
 end,Properties={Name="use-set-state"},Reference=36,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local useEffect = _roact_hooked.useEffect
local useMutable = _roact_hooked.useMutable
local useState = _roact_hooked.useState
local _timeout = TS.import(script, script.Parent.Parent.Parent, "utils", "timeout")
local clearTimeout = _timeout.clearTimeout
local setTimeout = _timeout.setTimeout
local nextId = 0
local function clearUpdates(updates, laterThan)
	for id, update in pairs(updates) do
		if laterThan == nil or update.resolveTime >= laterThan then
			-- \226\150\188 Map.delete \226\150\188
			updates[id] = nil
			-- \226\150\178 Map.delete \226\150\178
			clearTimeout(update.timeout)
		end
	end
end
local function useDelayedUpdate(value, delay, isImmediate)
	local _binding = useState(value)
	local delayedValue = _binding[1]
	local setDelayedValue = _binding[2]
	local updates = useMutable({})
	useEffect(function()
		local _result = isImmediate
		if _result ~= nil then
			_result = _result(value)
		end
		if _result then
			clearUpdates(updates.current)
			setDelayedValue(value)
			return nil
		end
		local _original = nextId
		nextId += 1
		local id = _original
		local update = {
			timeout = setTimeout(function()
				setDelayedValue(value)
				-- \226\150\188 Map.delete \226\150\188
				updates.current[id] = nil
				-- \226\150\178 Map.delete \226\150\178
			end, delay),
			resolveTime = os.clock() + delay,
		}
		clearUpdates(updates.current, update.resolveTime)
		-- \226\150\188 Map.set \226\150\188
		updates.current[id] = update
		-- \226\150\178 Map.set \226\150\178
	end, { value })
	useEffect(function()
		return function()
			return clearUpdates(updates.current)
		end
	end, {})
	return delayedValue
end
return {
	useDelayedUpdate = useDelayedUpdate,
}
 end,Properties={Name="use-delayed-update"},Reference=30,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local useEffect = _roact_hooked.useEffect
local useReducer = _roact_hooked.useReducer
local function resolvePromise(promise)
	if type(promise) == "function" then
		return promise()
	end
	return promise
end
local states = {
	pending = "pending",
	rejected = "rejected",
	resolved = "resolved",
}
local defaultState = {
	err = nil,
	result = nil,
	state = states.pending,
}
local function reducer(state, action)
	local _exp = action.type
	repeat
		if _exp == (states.pending) then
			return defaultState
		end
		if _exp == (states.resolved) then
			return {
				err = nil,
				result = action.payload,
				state = states.resolved,
			}
		end
		if _exp == (states.rejected) then
			return {
				err = action.payload,
				result = nil,
				state = states.rejected,
			}
		end
		return state
	until true
end
local function usePromise(promise, deps)
	if deps == nil then
		deps = {}
	end
	local _binding = useReducer(reducer, defaultState)
	local _binding_1 = _binding[1]
	local err = _binding_1.err
	local result = _binding_1.result
	local state = _binding_1.state
	local dispatch = _binding[2]
	useEffect(function()
		promise = resolvePromise(promise)
		if not promise then
			return nil
		end
		local canceled = false
		dispatch({
			type = states.pending,
		})
		local _arg0 = function(result)
			return not canceled and dispatch({
				payload = result,
				type = states.resolved,
			})
		end
		local _arg1 = function(err)
			return not canceled and dispatch({
				payload = err,
				type = states.rejected,
			})
		end
		promise:andThen(_arg0, _arg1)
		return function()
			canceled = true
		end
	end, deps)
	return { result, err, state }
end
return {
	usePromise = usePromise,
}
 end,Properties={Name="use-promise"},Reference=35,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Spring = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src).Spring
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _flipper_hooks = TS.import(script, script.Parent, "flipper-hooks")
local getBinding = _flipper_hooks.getBinding
local useMotor = _flipper_hooks.useMotor
local useNumberSpring = _flipper_hooks.useSpring
local supportedTypes = {
	number = useNumberSpring,
	Color3 = function(color, options)
		local motor = useMotor({ color.R, color.G, color.B })
		motor:setGoal({ Spring.new(color.R, options), Spring.new(color.G, options), Spring.new(color.B, options) })
		return getBinding(motor):map(function(_param)
			local r = _param[1]
			local g = _param[2]
			local b = _param[3]
			return Color3.new(r, g, b)
		end)
	end,
	UDim = function(udim, options)
		local motor = useMotor({ udim.Scale, udim.Offset })
		motor:setGoal({ Spring.new(udim.Scale, options), Spring.new(udim.Offset, options) })
		return getBinding(motor):map(function(_param)
			local s = _param[1]
			local o = _param[2]
			return UDim.new(s, o)
		end)
	end,
	UDim2 = function(udim2, options)
		local motor = useMotor({ udim2.X.Scale, udim2.X.Offset, udim2.Y.Scale, udim2.Y.Offset })
		motor:setGoal({ Spring.new(udim2.X.Scale, options), Spring.new(udim2.X.Offset, options), Spring.new(udim2.Y.Scale, options), Spring.new(udim2.Y.Offset, options) })
		return getBinding(motor):map(function(_param)
			local xS = _param[1]
			local xO = _param[2]
			local yS = _param[3]
			local yO = _param[4]
			return UDim2.new(xS, math.round(xO), yS, math.round(yO))
		end)
	end,
	Vector2 = function(vector2, options)
		local motor = useMotor({ vector2.X, vector2.Y })
		motor:setGoal({ Spring.new(vector2.X, options), Spring.new(vector2.Y, options) })
		return getBinding(motor):map(function(_param)
			local X = _param[1]
			local Y = _param[2]
			return Vector2.new(X, Y)
		end)
	end,
}
local function useSpring(value, options)
	if not options then
		return (Roact.createBinding(value))
	end
	local useSpring = supportedTypes[typeof(value)]
	local _arg1 = "useAnySpring: " .. (typeof(value) .. " is not supported")
	assert(useSpring, _arg1)
	return useSpring(value, options)
end
return {
	useSpring = useSpring,
}
 end,Properties={Name="use-spring"},Reference=37,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local useEffect = _roact_hooked.useEffect
local useMutable = _roact_hooked.useMutable
local function useDidMount(callback)
	local ref = useMutable(callback)
	useEffect(function()
		if ref.current then
			ref.current()
		end
	end, {})
	return ref
end
local function useIsMount()
	local ref = useMutable(true)
	useEffect(function()
		ref.current = false
	end, {})
	return ref.current
end
return {
	useDidMount = useDidMount,
	useIsMount = useIsMount,
}
 end,Properties={Name="use-did-mount"},Reference=31,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local useCallback = _roact_hooked.useCallback
local useState = _roact_hooked.useState
local function useForcedUpdate()
	local _binding = useState(0)
	local setState = _binding[2]
	return useCallback(function()
		return setState(function(state)
			return state + 1
		end)
	end, {})
end
return {
	useForcedUpdate = useForcedUpdate,
}
 end,Properties={Name="use-forced-update"},Reference=32,ClassName="ModuleScript"},{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.getBinding = TS.import(script, script, "get-binding").getBinding
exports.useGoal = TS.import(script, script, "use-goal").useGoal
exports.useInstant = TS.import(script, script, "use-instant").useInstant
exports.useLinear = TS.import(script, script, "use-linear").useLinear
exports.useMotor = TS.import(script, script, "use-motor").useMotor
exports.useSpring = TS.import(script, script, "use-spring").useSpring
return exports
 end,Properties={Name="flipper-hooks"},Reference=22,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local getBinding = TS.import(script, script.Parent, "get-binding").getBinding
local useMotor = TS.import(script, script.Parent, "use-motor").useMotor
local function useGoal(goal)
	local motor = useMotor(goal._targetValue)
	motor:setGoal(goal)
	return getBinding(motor)
end
return {
	useGoal = useGoal,
}
 end,Properties={Name="use-goal"},Reference=24,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Spring = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src).Spring
local useGoal = TS.import(script, script.Parent, "use-goal").useGoal
local function useSpring(targetValue, options)
	return useGoal(Spring.new(targetValue, options))
end
return {
	useSpring = useSpring,
}
 end,Properties={Name="use-spring"},Reference=28,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Linear = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src).Linear
local useGoal = TS.import(script, script.Parent, "use-goal").useGoal
local function useLinear(targetValue, options)
	return useGoal(Linear.new(targetValue, options))
end
return {
	useLinear = useLinear,
}
 end,Properties={Name="use-linear"},Reference=26,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local _flipper = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src)
local GroupMotor = _flipper.GroupMotor
local SingleMotor = _flipper.SingleMotor
local useMutable = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out.hooks).useMutable
local function createMotor(initialValue)
	if type(initialValue) == "number" then
		return SingleMotor.new(initialValue)
	elseif type(initialValue) == "table" then
		return GroupMotor.new(initialValue)
	else
		error("Invalid type for initialValue. Expected 'number' or 'table', got '" .. (tostring(initialValue) .. "'"))
	end
end
local function useMotor(initialValue)
	return useMutable(createMotor(initialValue)).current
end
return {
	useMotor = useMotor,
}
 end,Properties={Name="use-motor"},Reference=27,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local Instant = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src).Instant
local useGoal = TS.import(script, script.Parent, "use-goal").useGoal
local function useInstant(targetValue)
	return useGoal(Instant.new(targetValue))
end
return {
	useInstant = useInstant,
}
 end,Properties={Name="use-instant"},Reference=25,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.Parent.include.RuntimeLib)
local isMotor = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src).isMotor
local createBinding = TS.import(script, TS.getModule(script, "@rbxts", "roact").src).createBinding
local AssignedBinding = setmetatable({}, {
	__tostring = function()
		return "AssignedBinding"
	end,
})
local function getBinding(motor)
	assert(motor, "Missing argument #1: motor")
	local _arg0 = isMotor(motor)
	assert(_arg0, "Provided value is not a motor")
	if motor[AssignedBinding] ~= nil then
		return motor[AssignedBinding]
	end
	local binding, setBindingValue = createBinding(motor:getValue())
	motor:onStep(setBindingValue)
	motor[AssignedBinding] = binding
	return binding
end
return {
	getBinding = getBinding,
}
 end,Properties={Name="get-binding"},Reference=23,ClassName="ModuleScript"}}}},Properties={Name="common"},Reference=21,ClassName="Folder"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Spring = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src).Spring
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _flipper_hooks = TS.import(script, script.Parent, "common", "flipper-hooks")
local getBinding = _flipper_hooks.getBinding
local useMotor = _flipper_hooks.useMotor
local useMouseLocation = TS.import(script, script.Parent, "common", "use-mouse-location").useMouseLocation
local useViewportSize = TS.import(script, script.Parent, "common", "use-viewport-size").useViewportSize
local function useParallaxOffset()
	local mouseLocationMotor = useMotor({ 0, 0 })
	local mouseLocation = getBinding(mouseLocationMotor)
	local viewportSize = useViewportSize()
	local offset = Roact.joinBindings({
		viewportSize = viewportSize,
		mouseLocation = mouseLocation,
	}):map(function(_param)
		local viewportSize = _param.viewportSize
		local _binding = _param.mouseLocation
		local x = _binding[1]
		local y = _binding[2]
		return Vector2.new((x - viewportSize.X / 2) / viewportSize.X, (y - viewportSize.Y / 2) / viewportSize.Y)
	end)
	useMouseLocation(function(location)
		mouseLocationMotor:setGoal({ Spring.new(location.X, {
			dampingRatio = 5,
		}), Spring.new(location.Y, {
			dampingRatio = 5,
		}) })
	end)
	return offset
end
return {
	useParallaxOffset = useParallaxOffset,
}
 end,Properties={Name="use-parallax-offset"},Reference=41,ClassName="ModuleScript"}},Properties={Name="hooks"},Reference=20,ClassName="Folder"},{Children={{ClassName="ModuleScript",Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local exports = {}
exports.default = TS.import(script, script, "Acrylic").default
return exports
 end,Properties={Name="Acrylic"},Reference=4,Children={{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useCallback = _roact_hooked.useCallback
local useEffect = _roact_hooked.useEffect
local useMemo = _roact_hooked.useMemo
local useMutable = _roact_hooked.useMutable
local Workspace = TS.import(script, TS.getModule(script, "@rbxts", "services")).Workspace
local acrylicInstance = TS.import(script, script.Parent, "acrylic-instance").acrylicInstance
local useAppSelector = TS.import(script, script.Parent.Parent.Parent, "hooks", "common", "rodux-hooks").useAppSelector
local map = TS.import(script, script.Parent.Parent.Parent, "utils", "number-util").map
local scale = TS.import(script, script.Parent.Parent.Parent, "utils", "udim2").scale
local cylinderAngleOffset = CFrame.Angles(0, math.rad(90), 0)
local function viewportPointToWorld(location, distance)
	local unitRay = Workspace.CurrentCamera:ScreenPointToRay(location.X, location.Y)
	local _origin = unitRay.Origin
	local _arg0 = unitRay.Direction * distance
	return _origin + _arg0
end
local function getOffset()
	return map(Workspace.CurrentCamera.ViewportSize.Y, 0, 2560, 8, 56)
end
local AcrylicBlur
local function Acrylic(_param)
	local radius = _param.radius
	local distance = _param.distance
	local isAcrylicBlurEnabled = useAppSelector(function(state)
		return state.options.config.acrylicBlur
	end)
	local _children = {}
	local _length = #_children
	local _child = isAcrylicBlurEnabled and Roact.createElement(AcrylicBlur, {
		radius = radius,
		distance = distance,
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	return Roact.createFragment(_children)
end
local default = hooked(Acrylic)
local function AcrylicBlurComponent(_param)
	local radius = _param.radius
	if radius == nil then
		radius = 0
	end
	local distance = _param.distance
	if distance == nil then
		distance = 0.001
	end
	local frameInfo = useMutable({
		topleft2d = Vector2.new(),
		topright2d = Vector2.new(),
		bottomright2d = Vector2.new(),
		topleftradius2d = Vector2.new(),
	})
	local acrylic = useMemo(function()
		local clone = acrylicInstance:Clone()
		clone.Parent = Workspace
		return clone
	end, {})
	useEffect(function()
		return function()
			return acrylic:Destroy()
		end
	end, {})
	local updateFrameInfo = useCallback(function(size, position)
		local _arg0 = size / 2
		local topleftRaw = position - _arg0
		local info = frameInfo.current
		info.topleft2d = Vector2.new(math.ceil(topleftRaw.X), math.ceil(topleftRaw.Y))
		local _topleft2d = info.topleft2d
		local _vector2 = Vector2.new(size.X, 0)
		info.topright2d = _topleft2d + _vector2
		info.bottomright2d = info.topleft2d + size
		local _topleft2d_1 = info.topleft2d
		local _vector2_1 = Vector2.new(radius, 0)
		info.topleftradius2d = _topleft2d_1 + _vector2_1
	end, { distance, radius })
	local updateInstance = useCallback(function()
		local _binding = frameInfo.current
		local topleft2d = _binding.topleft2d
		local topright2d = _binding.topright2d
		local bottomright2d = _binding.bottomright2d
		local topleftradius2d = _binding.topleftradius2d
		local topleft = viewportPointToWorld(topleft2d, distance)
		local topright = viewportPointToWorld(topright2d, distance)
		local bottomright = viewportPointToWorld(bottomright2d, distance)
		local topleftradius = viewportPointToWorld(topleftradius2d, distance)
		local cornerRadius = (topleftradius - topleft).Magnitude
		local width = (topright - topleft).Magnitude
		local height = (topright - bottomright).Magnitude
		local center = CFrame.fromMatrix((topleft + bottomright) / 2, Workspace.CurrentCamera.CFrame.XVector, Workspace.CurrentCamera.CFrame.YVector, Workspace.CurrentCamera.CFrame.ZVector)
		if radius ~= nil and radius > 0 then
			acrylic.Horizontal.CFrame = center
			acrylic.Horizontal.Mesh.Scale = Vector3.new(width - cornerRadius * 2, height, 0)
			acrylic.Vertical.CFrame = center
			acrylic.Vertical.Mesh.Scale = Vector3.new(width, height - cornerRadius * 2, 0)
		else
			acrylic.Horizontal.CFrame = center
			acrylic.Horizontal.Mesh.Scale = Vector3.new(width, height, 0)
		end
		if radius ~= nil and radius > 0 then
			local _cFrame = CFrame.new(-width / 2 + cornerRadius, height / 2 - cornerRadius, 0)
			acrylic.TopLeft.CFrame = center * _cFrame * cylinderAngleOffset
			acrylic.TopLeft.Mesh.Scale = Vector3.new(0, cornerRadius * 2, cornerRadius * 2)
			local _cFrame_1 = CFrame.new(width / 2 - cornerRadius, height / 2 - cornerRadius, 0)
			acrylic.TopRight.CFrame = center * _cFrame_1 * cylinderAngleOffset
			acrylic.TopRight.Mesh.Scale = Vector3.new(0, cornerRadius * 2, cornerRadius * 2)
			local _cFrame_2 = CFrame.new(-width / 2 + cornerRadius, -height / 2 + cornerRadius, 0)
			acrylic.BottomLeft.CFrame = center * _cFrame_2 * cylinderAngleOffset
			acrylic.BottomLeft.Mesh.Scale = Vector3.new(0, cornerRadius * 2, cornerRadius * 2)
			local _cFrame_3 = CFrame.new(width / 2 - cornerRadius, -height / 2 + cornerRadius, 0)
			acrylic.BottomRight.CFrame = center * _cFrame_3 * cylinderAngleOffset
			acrylic.BottomRight.Mesh.Scale = Vector3.new(0, cornerRadius * 2, cornerRadius * 2)
		end
	end, { radius, distance })
	useEffect(function()
		updateInstance()
		local posHandle = Workspace.CurrentCamera:GetPropertyChangedSignal("CFrame"):Connect(updateInstance)
		local fovHandle = Workspace.CurrentCamera:GetPropertyChangedSignal("FieldOfView"):Connect(updateInstance)
		local viewportHandle = Workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(updateInstance)
		return function()
			posHandle:Disconnect()
			fovHandle:Disconnect()
			viewportHandle:Disconnect()
		end
	end, { updateInstance })
	return Roact.createElement("Frame", {
		[Roact.Change.AbsoluteSize] = function(rbx)
			local blurOffset = getOffset()
			local _absoluteSize = rbx.AbsoluteSize
			local _vector2 = Vector2.new(blurOffset, blurOffset)
			local size = _absoluteSize - _vector2
			local _absolutePosition = rbx.AbsolutePosition
			local _arg0 = rbx.AbsoluteSize / 2
			local position = _absolutePosition + _arg0
			updateFrameInfo(size, position)
			task.spawn(updateInstance)
		end,
		[Roact.Change.AbsolutePosition] = function(rbx)
			local blurOffset = getOffset()
			local _absoluteSize = rbx.AbsoluteSize
			local _vector2 = Vector2.new(blurOffset, blurOffset)
			local size = _absoluteSize - _vector2
			local _absolutePosition = rbx.AbsolutePosition
			local _arg0 = rbx.AbsoluteSize / 2
			local position = _absolutePosition + _arg0
			updateFrameInfo(size, position)
			task.spawn(updateInstance)
		end,
		Size = scale(1, 1),
		BackgroundTransparency = 1,
	})
end
AcrylicBlur = hooked(AcrylicBlurComponent)
return {
	default = default,
}
 end,Properties={Name="Acrylic"},Reference=5,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Provider = TS.import(script, TS.getModule(script, "@rbxts", "roact-rodux-hooked").out).Provider
local Acrylic = TS.import(script, script.Parent, "Acrylic").default
local DashboardPage = TS.import(script, script.Parent.Parent.Parent, "store", "models", "dashboard.model").DashboardPage
local configureStore = TS.import(script, script.Parent.Parent.Parent, "store", "store").configureStore
local hex = TS.import(script, script.Parent.Parent.Parent, "utils", "color3").hex
local _udim2 = TS.import(script, script.Parent.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
return function(target)
	local handle = Roact.mount(Roact.createElement(Provider, {
		store = configureStore({
			dashboard = {
				isOpen = true,
				page = DashboardPage.Apps,
				hint = nil,
				apps = {},
			},
		}),
	}, {
		Roact.createElement("Frame", {
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = scale(0.3, 0.7),
			Size = px(250, 350),
			BackgroundColor3 = hex("#000000"),
			BackgroundTransparency = 0.5,
			BorderSizePixel = 0,
		}, {
			Roact.createElement("UICorner", {
				CornerRadius = UDim.new(0, 64),
			}),
			Roact.createElement(Acrylic, {
				radius = 52,
			}),
		}),
	}), target, "Acrylic")
	return function()
		return Roact.unmount(handle)
	end
end
 end,Properties={Name="Acrylic.story"},Reference=6,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.Parent.include.RuntimeLib)
local Make = TS.import(script, TS.getModule(script, "@rbxts", "make"))
local fill = {
	Color = Color3.new(0, 0, 0),
	Material = Enum.Material.Glass,
	Size = Vector3.new(1, 1, 0),
	Anchored = true,
	CanCollide = false,
	Locked = true,
	CastShadow = false,
	Transparency = 0.999,
}
local corner = {
	Color = Color3.new(0, 0, 0),
	Material = Enum.Material.Glass,
	Size = Vector3.new(0, 1, 1),
	Anchored = true,
	CanCollide = false,
	Locked = true,
	CastShadow = false,
	Transparency = 0.999,
}
local _object = {}
local _left = "Children"
local _object_1 = {
	Name = "Horizontal",
	Children = { Make("SpecialMesh", {
		MeshType = Enum.MeshType.Brick,
		Offset = Vector3.new(0, 0, -0.000001),
	}) },
}
for _k, _v in pairs(fill) do
	_object_1[_k] = _v
end
local _exp = Make("Part", _object_1)
local _object_2 = {
	Name = "Vertical",
	Children = { Make("SpecialMesh", {
		MeshType = Enum.MeshType.Brick,
		Offset = Vector3.new(0, 0, 0.000001),
	}) },
}
for _k, _v in pairs(fill) do
	_object_2[_k] = _v
end
local _exp_1 = Make("Part", _object_2)
local _object_3 = {
	Name = "TopRight",
	Children = { Make("SpecialMesh", {
		MeshType = Enum.MeshType.Cylinder,
	}) },
}
for _k, _v in pairs(corner) do
	_object_3[_k] = _v
end
local _exp_2 = Make("Part", _object_3)
local _object_4 = {
	Name = "TopLeft",
	Children = { Make("SpecialMesh", {
		MeshType = Enum.MeshType.Cylinder,
	}) },
}
for _k, _v in pairs(corner) do
	_object_4[_k] = _v
end
local _exp_3 = Make("Part", _object_4)
local _object_5 = {
	Name = "BottomRight",
	Children = { Make("SpecialMesh", {
		MeshType = Enum.MeshType.Cylinder,
	}) },
}
for _k, _v in pairs(corner) do
	_object_5[_k] = _v
end
local _exp_4 = Make("Part", _object_5)
local _object_6 = {
	Name = "BottomLeft",
	Children = { Make("SpecialMesh", {
		MeshType = Enum.MeshType.Cylinder,
	}) },
}
for _k, _v in pairs(corner) do
	_object_6[_k] = _v
end
_object[_left] = { _exp, _exp_1, _exp_2, _exp_3, _exp_4, Make("Part", _object_6) }
local acrylicInstance = Make("Model", _object)
return {
	acrylicInstance = acrylicInstance,
}
 end,Properties={Name="acrylic-instance"},Reference=7,ClassName="ModuleScript"}}},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local _binding_util = TS.import(script, script.Parent.Parent, "utils", "binding-util")
local asBinding = _binding_util.asBinding
local mapBinding = _binding_util.mapBinding
local hex = TS.import(script, script.Parent.Parent, "utils", "color3").hex
local px = TS.import(script, script.Parent.Parent, "utils", "udim2").px
local function Border(_param)
	local size = _param.size
	if size == nil then
		size = 1
	end
	local radius = _param.radius
	if radius == nil then
		radius = 0
	end
	local color = _param.color
	if color == nil then
		color = hex("#ffffff")
	end
	local transparency = _param.transparency
	if transparency == nil then
		transparency = 0
	end
	local children = _param[Roact.Children]
	local _attributes = {
		Size = mapBinding(size, function(s)
			return UDim2.new(1, -s * 2, 1, -s * 2)
		end),
		Position = mapBinding(size, function(s)
			return px(s, s)
		end),
		BackgroundTransparency = 1,
	}
	local _children = {}
	local _length = #_children
	local _attributes_1 = {
		Thickness = size,
		Color = color,
		Transparency = transparency,
	}
	local _children_1 = {}
	local _length_1 = #_children_1
	if children then
		for _k, _v in pairs(children) do
			if type(_k) == "number" then
				_children_1[_length_1 + _k] = _v
			else
				_children_1[_k] = _v
			end
		end
	end
	_children[_length + 1] = Roact.createElement("UIStroke", _attributes_1, _children_1)
	_children[_length + 2] = Roact.createElement("UICorner", {
		CornerRadius = Roact.joinBindings({
			radius = asBinding(radius),
			size = asBinding(size),
		}):map(function(_param_1)
			local radius = _param_1.radius
			local size = _param_1.size
			return radius == "circular" and UDim.new(1, 0) or UDim.new(0, radius - size * 2)
		end),
	})
	return Roact.createElement("Frame", _attributes, _children)
end
local default = hooked(Border)
return {
	default = default,
}
 end,Properties={Name="Border"},Reference=9,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Spring = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src).Spring
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useCallback = _roact_hooked.useCallback
local useEffect = _roact_hooked.useEffect
local useState = _roact_hooked.useState
local UserInputService = TS.import(script, TS.getModule(script, "@rbxts", "services")).UserInputService
local _flipper_hooks = TS.import(script, script.Parent.Parent, "hooks", "common", "flipper-hooks")
local getBinding = _flipper_hooks.getBinding
local useMotor = _flipper_hooks.useMotor
local _udim2 = TS.import(script, script.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local Border = TS.import(script, script.Parent, "Border").default
local Canvas = TS.import(script, script.Parent, "Canvas").default
local Fill = TS.import(script, script.Parent, "Fill").default
local _Glow = TS.import(script, script.Parent, "Glow")
local Glow = _Glow.default
local GlowRadius = _Glow.GlowRadius
local SPRING_OPTIONS = {
	frequency = 8,
}
local Drag
local function BrightSlider(_param)
	local min = _param.min
	local max = _param.max
	local initialValue = _param.initialValue
	local size = _param.size
	local position = _param.position
	local radius = _param.radius
	local color = _param.color
	local accentColor = _param.accentColor
	local borderEnabled = _param.borderEnabled
	local borderColor = _param.borderColor
	local transparency = _param.transparency
	local indicatorTransparency = _param.indicatorTransparency
	local onValueChanged = _param.onValueChanged
	local onRelease = _param.onRelease
	local children = _param[Roact.Children]
	local valueMotor = useMotor(initialValue)
	local valueBinding = getBinding(valueMotor)
	useEffect(function()
		local _result = onValueChanged
		if _result ~= nil then
			_result(initialValue)
		end
	end, {})
	useEffect(function()
		return function()
			return valueMotor:destroy()
		end
	end, {})
	local _attributes = {
		size = size,
		position = position,
	}
	local _children = {
		Roact.createElement(Glow, {
			radius = GlowRadius.Size70,
			color = accentColor,
			size = valueBinding:map(function(v)
				return UDim2.new((v - min) / (max - min), 36, 1, 36)
			end),
			position = px(-18, 5 - 18),
			transparency = 0,
			maintainCornerRadius = true,
		}),
		Roact.createElement(Fill, {
			color = color,
			radius = radius,
			transparency = transparency,
		}),
		Roact.createElement(Canvas, {
			size = valueBinding:map(function(v)
				return scale((v - min) / (max - min), 1)
			end),
			clipsDescendants = true,
		}, {
			Roact.createElement("Frame", {
				Size = size,
				BackgroundColor3 = accentColor,
				BackgroundTransparency = indicatorTransparency,
			}, {
				Roact.createElement("UICorner", {
					CornerRadius = UDim.new(0, radius),
				}),
			}),
		}),
	}
	local _length = #_children
	local _child = borderEnabled and Roact.createElement(Border, {
		color = borderColor,
		radius = radius,
		transparency = 0.8,
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children[_length + 1] = Roact.createElement(Drag, {
		onChange = function(alpha)
			valueMotor:setGoal(Spring.new(alpha * (max - min) + min, SPRING_OPTIONS))
			local _result = onValueChanged
			if _result ~= nil then
				_result(alpha * (max - min) + min)
			end
		end,
		onRelease = function(alpha)
			local _result = onRelease
			if _result ~= nil then
				_result = _result(alpha * (max - min) + min)
			end
			return _result
		end,
	})
	if children then
		for _k, _v in pairs(children) do
			if type(_k) == "number" then
				_children[_length + 1 + _k] = _v
			else
				_children[_k] = _v
			end
		end
	end
	return Roact.createElement(Canvas, _attributes, _children)
end
local default = hooked(BrightSlider)
local function DragComponent(_param)
	local onChange = _param.onChange
	local onRelease = _param.onRelease
	local _binding = useState()
	local inputHandle = _binding[1]
	local setHandle = _binding[2]
	local updateValue = useCallback(function(alpha)
		alpha = math.clamp(alpha, 0, 1)
		onChange(alpha)
	end, {})
	local getValueFromPosition = useCallback(function(x, rbx)
		return (x - rbx.AbsolutePosition.X) / rbx.AbsoluteSize.X
	end, {})
	useEffect(function()
		return function()
			local _result = inputHandle
			if _result ~= nil then
				_result:Disconnect()
			end
		end
	end, {})
	return Roact.createElement("Frame", {
		Active = true,
		Size = scale(1, 1),
		BackgroundTransparency = 1,
		[Roact.Event.InputBegan] = function(rbx, input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				local _result = inputHandle
				if _result ~= nil then
					_result:Disconnect()
				end
				local handle = UserInputService.InputChanged:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						updateValue(getValueFromPosition(input.Position.X, rbx))
					end
				end)
				setHandle(handle)
				updateValue(getValueFromPosition(input.Position.X, rbx))
			end
		end,
		[Roact.Event.InputEnded] = function(rbx, input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				local _result = inputHandle
				if _result ~= nil then
					_result:Disconnect()
				end
				setHandle(nil)
				onRelease(getValueFromPosition(input.Position.X, rbx))
			end
		end,
	})
end
Drag = hooked(DragComponent)
return {
	default = default,
}
 end,Properties={Name="BrightSlider"},Reference=11,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useBinding = _roact_hooked.useBinding
local useScale = TS.import(script, script.Parent.Parent, "hooks", "use-scale").useScale
local asBinding = TS.import(script, script.Parent.Parent, "utils", "binding-util").asBinding
local map = TS.import(script, script.Parent.Parent, "utils", "number-util").map
local _udim2 = TS.import(script, script.Parent.Parent, "utils", "udim2")
local applyUDim2 = _udim2.applyUDim2
local px = _udim2.px
local Canvas = TS.import(script, script.Parent, "Canvas").default
local GlowRadius
do
	local _inverse = {}
	GlowRadius = setmetatable({}, {
		__index = _inverse,
	})
	GlowRadius.Size70 = "rbxassetid://8992230903"
	_inverse["rbxassetid://8992230903"] = "Size70"
	GlowRadius.Size146 = "rbxassetid://8992584561"
	_inverse["rbxassetid://8992584561"] = "Size146"
	GlowRadius.Size198 = "rbxassetid://8992230677"
	_inverse["rbxassetid://8992230677"] = "Size198"
end
local RADIUS_TO_CENTER_OFFSET = {
	[GlowRadius.Size70] = 70 / 2,
	[GlowRadius.Size146] = 146 / 2,
	[GlowRadius.Size198] = 198 / 2,
}
local function Glow(_param)
	local radius = _param.radius
	local size = _param.size
	local position = _param.position
	local color = _param.color
	local gradient = _param.gradient
	local transparency = _param.transparency
	if transparency == nil then
		transparency = 0
	end
	local maintainCornerRadius = _param.maintainCornerRadius
	local children = _param[Roact.Children]
	local _binding = useBinding(Vector2.new())
	local absoluteSize = _binding[1]
	local setAbsoluteSize = _binding[2]
	local scaleFactor = useScale()
	local centerOffset = RADIUS_TO_CENTER_OFFSET[radius]
	local sizeModifier = maintainCornerRadius and Roact.joinBindings({
		absoluteSize = absoluteSize,
		scaleFactor = scaleFactor,
		size = asBinding(size),
	}):map(function(_param_1)
		local absoluteSize = _param_1.absoluteSize
		local size = _param_1.size
		local scaleFactor = _param_1.scaleFactor
		local currentSize = applyUDim2(absoluteSize, size, scaleFactor)
		return px(math.max(currentSize.X, centerOffset * 2), math.max(currentSize.Y, centerOffset * 2))
	end) or size
	local transparencyModifier = maintainCornerRadius and Roact.joinBindings({
		absoluteSize = absoluteSize,
		scaleFactor = scaleFactor,
		size = asBinding(size),
		transparency = asBinding(transparency),
	}):map(function(_param_1)
		local absoluteSize = _param_1.absoluteSize
		local size = _param_1.size
		local transparency = _param_1.transparency
		local scaleFactor = _param_1.scaleFactor
		local minSize = centerOffset * 2
		local currentSize = applyUDim2(absoluteSize, UDim2.fromScale(size.X.Scale, size.Y.Scale), scaleFactor).X
		if currentSize < minSize then
			return 1 - (1 - transparency) * map(currentSize, 0, minSize, 0, 1)
		else
			return transparency
		end
	end) or transparency
	local _attributes = {
		onChange = {
			AbsoluteSize = maintainCornerRadius and function(rbx)
				return setAbsoluteSize(rbx.AbsoluteSize)
			end or nil,
		},
	}
	local _children = {}
	local _length = #_children
	local _attributes_1 = {
		Image = radius,
		ImageColor3 = color,
		ImageTransparency = transparencyModifier,
		ScaleType = "Slice",
		SliceCenter = Rect.new(Vector2.new(centerOffset, centerOffset), Vector2.new(centerOffset, centerOffset)),
		SliceScale = scaleFactor:map(function(factor)
			return factor * 0.1 + 0.9
		end),
		Size = sizeModifier,
		Position = position,
		BackgroundTransparency = 1,
	}
	local _children_1 = {}
	local _length_1 = #_children_1
	local _child = gradient and (Roact.createFragment({
		gradient = Roact.createElement("UIGradient", {
			Color = gradient.color,
			Transparency = gradient.transparency,
			Rotation = gradient.rotation,
		}),
	}))
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children_1[_length_1 + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children_1[_length_1 + _k] = _v
			end
		end
	end
	_length_1 = #_children_1
	if children then
		for _k, _v in pairs(children) do
			if type(_k) == "number" then
				_children_1[_length_1 + _k] = _v
			else
				_children_1[_k] = _v
			end
		end
	end
	_children[_length + 1] = Roact.createElement("ImageLabel", _attributes_1, _children_1)
	return Roact.createElement(Canvas, _attributes, _children)
end
local default = hooked(Glow)
return {
	GlowRadius = GlowRadius,
	RADIUS_TO_CENTER_OFFSET = RADIUS_TO_CENTER_OFFSET,
	default = default,
}
 end,Properties={Name="Glow"},Reference=15,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local mapBinding = TS.import(script, script.Parent.Parent, "utils", "binding-util").mapBinding
local scale = TS.import(script, script.Parent.Parent, "utils", "udim2").scale
local function ParallaxImage(_param)
	local image = _param.image
	local imageSize = _param.imageSize
	local offset = _param.offset
	local padding = _param.padding
	local children = _param[Roact.Children]
	local _attributes = {
		Image = image,
	}
	local _arg0 = padding * 2
	_attributes.ImageRectSize = imageSize - _arg0
	_attributes.ImageRectOffset = mapBinding(offset, function(o)
		local _arg0_1 = o * padding
		return padding + _arg0_1
	end)
	_attributes.ScaleType = "Crop"
	_attributes.Size = scale(1, 1)
	_attributes.BackgroundTransparency = 1
	local _children = {}
	local _length = #_children
	if children then
		for _k, _v in pairs(children) do
			if type(_k) == "number" then
				_children[_length + _k] = _v
			else
				_children[_k] = _v
			end
		end
	end
	return Roact.createElement("ImageLabel", _attributes, _children)
end
local default = ParallaxImage
return {
	default = default,
}
 end,Properties={Name="ParallaxImage"},Reference=16,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Border = TS.import(script, script.Parent, "Border").default
local Canvas = TS.import(script, script.Parent, "Canvas").default
local Fill = TS.import(script, script.Parent, "Fill").default
local _Glow = TS.import(script, script.Parent, "Glow")
local Glow = _Glow.default
local GlowRadius = _Glow.GlowRadius
local hex = TS.import(script, script.Parent.Parent, "utils", "color3").hex
local _udim2 = TS.import(script, script.Parent.Parent, "utils", "udim2")
local px = _udim2.px
local scale = _udim2.scale
local function BrightButton(_param)
	local size = _param.size
	if size == nil then
		size = px(100, 100)
	end
	local position = _param.position
	if position == nil then
		position = px(0, 0)
	end
	local radius = _param.radius
	if radius == nil then
		radius = 8
	end
	local color = _param.color
	if color == nil then
		color = hex("#FFFFFF")
	end
	local borderEnabled = _param.borderEnabled
	local borderColor = _param.borderColor
	if borderColor == nil then
		borderColor = hex("#FFFFFF")
	end
	local transparency = _param.transparency
	if transparency == nil then
		transparency = 0
	end
	local onActivate = _param.onActivate
	local onPress = _param.onPress
	local onRelease = _param.onRelease
	local onHover = _param.onHover
	local children = _param[Roact.Children]
	local _attributes = {
		size = size,
		position = position,
	}
	local _children = {
		Roact.createElement(Glow, {
			radius = GlowRadius.Size70,
			color = color,
			size = UDim2.new(1, 36, 1, 36),
			position = px(-18, 5 - 18),
			transparency = transparency,
		}),
		Roact.createElement(Fill, {
			color = color,
			radius = radius,
			transparency = transparency,
		}),
	}
	local _length = #_children
	local _child = borderEnabled and Roact.createElement(Border, {
		color = borderColor,
		radius = radius,
		transparency = 0.8,
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	_children[_length + 1] = Roact.createElement("TextButton", {
		Text = "",
		AutoButtonColor = false,
		Size = scale(1, 1),
		BackgroundTransparency = 1,
		[Roact.Event.Activated] = function()
			local _result = onActivate
			if _result ~= nil then
				_result = _result()
			end
			return _result
		end,
		[Roact.Event.MouseButton1Down] = function()
			local _result = onPress
			if _result ~= nil then
				_result = _result()
			end
			return _result
		end,
		[Roact.Event.MouseButton1Up] = function()
			local _result = onRelease
			if _result ~= nil then
				_result = _result()
			end
			return _result
		end,
		[Roact.Event.MouseEnter] = function()
			local _result = onHover
			if _result ~= nil then
				_result = _result(true)
			end
			return _result
		end,
		[Roact.Event.MouseLeave] = function()
			local _result = onHover
			if _result ~= nil then
				_result = _result(false)
			end
			return _result
		end,
	})
	if children then
		for _k, _v in pairs(children) do
			if type(_k) == "number" then
				_children[_length + 1 + _k] = _v
			else
				_children[_k] = _v
			end
		end
	end
	return Roact.createElement(Canvas, _attributes, _children)
end
local default = hooked(BrightButton)
return {
	default = default,
}
 end,Properties={Name="BrightButton"},Reference=10,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local mapBinding = TS.import(script, script.Parent.Parent, "utils", "binding-util").mapBinding
local scale = TS.import(script, script.Parent.Parent, "utils", "udim2").scale
local function Canvas(_param)
	local size = _param.size
	if size == nil then
		size = scale(1, 1)
	end
	local position = _param.position
	if position == nil then
		position = scale(0, 0)
	end
	local anchor = _param.anchor
	local padding = _param.padding
	local clipsDescendants = _param.clipsDescendants
	local zIndex = _param.zIndex
	local onChange = _param.onChange
	if onChange == nil then
		onChange = {}
	end
	local children = _param[Roact.Children]
	local _attributes = {
		Size = size,
		Position = position,
		AnchorPoint = anchor,
		ClipsDescendants = clipsDescendants,
		BackgroundTransparency = 1,
		ZIndex = zIndex,
	}
	for _k, _v in pairs(onChange) do
		_attributes[Roact.Change[_k]] = _v
	end
	local _children = {}
	local _length = #_children
	local _child = padding ~= nil and (Roact.createFragment({
		padding = Roact.createElement("UIPadding", {
			PaddingTop = mapBinding(padding.top, function(px)
				return UDim.new(0, px)
			end),
			PaddingRight = mapBinding(padding.right, function(px)
				return UDim.new(0, px)
			end),
			PaddingBottom = mapBinding(padding.bottom, function(px)
				return UDim.new(0, px)
			end),
			PaddingLeft = mapBinding(padding.left, function(px)
				return UDim.new(0, px)
			end),
		}),
	}))
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	if children then
		for _k, _v in pairs(children) do
			if type(_k) == "number" then
				_children[_length + _k] = _v
			else
				_children[_k] = _v
			end
		end
	end
	return Roact.createElement("Frame", _attributes, _children)
end
local default = hooked(Canvas)
return {
	default = default,
}
 end,Properties={Name="Canvas"},Reference=12,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local mapBinding = TS.import(script, script.Parent.Parent, "utils", "binding-util").mapBinding
local hex = TS.import(script, script.Parent.Parent, "utils", "color3").hex
local scale = TS.import(script, script.Parent.Parent, "utils", "udim2").scale
local function Fill(_param)
	local color = _param.color
	if color == nil then
		color = hex("#ffffff")
	end
	local gradient = _param.gradient
	local transparency = _param.transparency
	if transparency == nil then
		transparency = 0
	end
	local radius = _param.radius
	if radius == nil then
		radius = 0
	end
	local children = _param[Roact.Children]
	local _attributes = {
		Size = scale(1, 1),
		BackgroundColor3 = color,
		BackgroundTransparency = transparency,
	}
	local _children = {}
	local _length = #_children
	local _child = gradient and (Roact.createFragment({
		gradient = Roact.createElement("UIGradient", {
			Color = gradient.color,
			Transparency = gradient.transparency,
			Rotation = gradient.rotation,
		}),
	}))
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	local _child_1 = radius ~= nil and (Roact.createFragment({
		corner = Roact.createElement("UICorner", {
			CornerRadius = mapBinding(radius, function(r)
				return r == "circular" and UDim.new(1, 0) or UDim.new(0, r)
			end),
		}),
	}))
	if _child_1 then
		if _child_1.elements ~= nil or _child_1.props ~= nil and _child_1.component ~= nil then
			_children[_length + 1] = _child_1
		else
			for _k, _v in ipairs(_child_1) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	if children then
		for _k, _v in pairs(children) do
			if type(_k) == "number" then
				_children[_length + _k] = _v
			else
				_children[_k] = _v
			end
		end
	end
	return Roact.createElement("Frame", _attributes, _children)
end
local default = hooked(Fill)
return {
	default = default,
}
 end,Properties={Name="Fill"},Reference=14,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out)
local hooked = _roact_hooked.hooked
local useState = _roact_hooked.useState
local BrightButton = TS.import(script, script.Parent, "BrightButton").default
local _rodux_hooks = TS.import(script, script.Parent.Parent, "hooks", "common", "rodux-hooks")
local useAppDispatch = _rodux_hooks.useAppDispatch
local useAppSelector = _rodux_hooks.useAppSelector
local useSpring = TS.import(script, script.Parent.Parent, "hooks", "common", "use-spring").useSpring
local _dashboard_action = TS.import(script, script.Parent.Parent, "store", "actions", "dashboard.action")
local clearHint = _dashboard_action.clearHint
local setHint = _dashboard_action.setHint
local setJobActive = TS.import(script, script.Parent.Parent, "store", "actions", "jobs.action").setJobActive
local px = TS.import(script, script.Parent.Parent, "utils", "udim2").px
local function ActionButton(_param)
	local action = _param.action
	local hint = _param.hint
	local theme = _param.theme
	local image = _param.image
	local position = _param.position
	local canDeactivate = _param.canDeactivate
	local dispatch = useAppDispatch()
	local active = useAppSelector(function(state)
		return state.jobs[action].active
	end)
	local _binding = useState(false)
	local hovered = _binding[1]
	local setHovered = _binding[2]
	local accent = theme.highlight[action] ~= nil and theme.highlight[action] or theme.background
	if not (theme.highlight[action] ~= nil) then
		warn("ActionButton: " .. (action .. " is not in theme.highlight"))
	end
	local _result
	if active then
		_result = accent
	else
		local _result_1
		if hovered then
			local _condition = theme.button.backgroundHovered
			if _condition == nil then
				_condition = theme.button.background:Lerp(accent, 0.1)
			end
			_result_1 = _condition
		else
			_result_1 = theme.button.background
		end
		_result = _result_1
	end
	local background = useSpring(_result, {})
	local foreground = useSpring(active and theme.button.foregroundAccent and theme.button.foregroundAccent or theme.button.foreground, {})
	return Roact.createElement(BrightButton, {
		onActivate = function()
			if active and canDeactivate then
				dispatch(setJobActive(action, false))
			elseif not active then
				dispatch(setJobActive(action, true))
			end
		end,
		onHover = function(hovered)
			if hovered then
				setHovered(true)
				dispatch(setHint(hint))
			else
				setHovered(false)
				dispatch(clearHint())
			end
		end,
		size = px(61, 49),
		position = position,
		radius = 8,
		color = background,
		borderEnabled = theme.button.outlined,
		borderColor = foreground,
		transparency = theme.button.backgroundTransparency,
	}, {
		Roact.createElement("ImageLabel", {
			Image = image,
			ImageColor3 = foreground,
			ImageTransparency = useSpring(active and 0 or (hovered and theme.button.foregroundTransparency - 0.25 or theme.button.foregroundTransparency), {}),
			Size = px(36, 36),
			Position = px(12, 6),
			BackgroundTransparency = 1,
		}),
	})
end
local default = hooked(ActionButton)
return {
	default = default,
}
 end,Properties={Name="ActionButton"},Reference=8,ClassName="ModuleScript"},{Closure=function() -- Compiled with roblox-ts v1.2.7
local TS = require(script.Parent.Parent.include.RuntimeLib)
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").out).hooked
local Acrylic = TS.import(script, script.Parent, "Acrylic").default
local Border = TS.import(script, script.Parent, "Border").default
local Canvas = TS.import(script, script.Parent, "Canvas").default
local Fill = TS.import(script, script.Parent, "Fill").default
local _Glow = TS.import(script, script.Parent, "Glow")
local Glow = _Glow.default
local GlowRadius = _Glow.GlowRadius
local useDelayedUpdate = TS.import(script, script.Parent.Parent, "hooks", "common", "use-delayed-update").useDelayedUpdate
local useSpring = TS.import(script, script.Parent.Parent, "hooks", "common", "use-spring").useSpring
local useIsPageOpen = TS.import(script, script.Parent.Parent, "hooks", "use-current-page").useIsPageOpen
local px = TS.import(script, script.Parent.Parent, "utils", "udim2").px
local function Card(_param)
	local index = _param.index
	local page = _param.page
	local theme = _param.theme
	local size = _param.size
	local position = _param.position
	local children = _param[Roact.Children]
	local isOpen = useIsPageOpen(page)
	local isActive = useDelayedUpdate(isOpen, index * 40)
	local _uDim2 = UDim2.new(UDim.new(), position.Y)
	local _arg0 = px((size.X.Offset + 48) * 2 - position.X.Offset, 0)
	local _arg0_1 = px(size.X.Offset + 48 * 2, 0)
	local positionWhenHidden = _uDim2 - _arg0 - _arg0_1
	local _attributes = {
		anchor = Vector2.new(0, 1),
		size = size,
		position = useSpring(isActive and position or positionWhenHidden, {
			frequency = 2,
			dampingRatio = 0.8,
		}),
	}
	local _children = {
		Roact.createElement(Glow, {
			radius = GlowRadius.Size198,
			size = UDim2.new(1, 100, 1, 96),
			position = px(-50, -28),
			color = theme.dropshadow,
			gradient = theme.dropshadowGradient,
			transparency = theme.dropshadowTransparency,
		}),
		Roact.createElement(Fill, {
			color = theme.background,
			gradient = theme.backgroundGradient,
			transparency = theme.transparency,
			radius = 16,
		}),
	}
	local _length = #_children
	if children then
		for _k, _v in pairs(children) do
			if type(_k) == "number" then
				_children[_length + _k] = _v
			else
				_children[_k] = _v
			end
		end
	end
	_length = #_children
	local _child = theme.acrylic and Roact.createFragment({
		acrylic = Roact.createElement(Acrylic),
	})
	if _child then
		if _child.elements ~= nil or _child.props ~= nil and _child.component ~= nil then
			_children[_length + 1] = _child
		else
			for _k, _v in ipairs(_child) do
				_children[_length + _k] = _v
			end
		end
	end
	_length = #_children
	local _child_1 = theme.outlined and Roact.createElement(Border, {
		color = theme.foreground,
		radius = 16,
		transparency = 0.8,
	})
	if _child_1 then
		if _child_1.elements ~= nil or _child_1.props ~= nil and _child_1.component ~= nil then
			_children[_length + 1] = _child_1
		else
			for _k, _v in ipairs(_child_1) do
				_children[_length + _k] = _v
			end
		end
	end
	return Roact.createElement(Canvas, _attributes, _children)
end
local default = hooked(Card)
return {
	default = default,
}
 end,Properties={Name="Card"},Reference=13,ClassName="ModuleScript"}},Properties={Name="components"},Reference=3,ClassName="Folder"}},Properties={Name="Orca"},Reference=1,ClassName="Folder"}} do local a,b='0.3.0',game:GetService'RunService'local c,d,e,f,g,h,i,j,k=b:IsServer(),b:IsClient(),getfenv(0),{},{},{},{},{},{}local function l(m)local n,o=pcall(Instance.new,m.ClassName)if not n then return end f[m.Reference]=o if m.Closure then h[o]=m.Closure if o:IsA'BaseScript'then table.insert(j,o)end end if m.Properties then for p,q in next,m.Properties do pcall(function()o[p]=q end)end end if m.RefProperties then for p,q in next,m.RefProperties do table.insert(g,{InstanceObject=o,Property=p,ReferenceId=q})end end if m.Attributes then for p,q in next,m.Attributes do pcall(o.SetAttribute,o,p,q)end end if m.Children then for p,q in next,m.Children do local r=l(q)if r then r.Parent=o end end end return o end local m={}do for n,o in next,ModuleRoot do table.insert(m,l(o))end end local function n(o)local p=i[o]if o.ClassName=='ModuleScript'and p then return unpack(p)end local q=h[o]if not q then return end do local r local s={['maui']=table.freeze{Version=a,GetScript=function()return script end,GetShared=function()return k end},['script']=o,['require']=function(s,...)if s and s.ClassName=='ModuleScript'and h[s]then return n(s)end return require(s,...)end,['getfenv']=function(s,...)if type(s)=='number'and s>=0 then if s==0 then return r else local t,u=pcall(getfenv,s)if t and u==e then return r end end end return getfenv(s,...)end,['setfenv']=function(s,t,...)if type(s)=='number'and s>=0 then if s==0 then return setfenv(r,t)else local u,v=pcall(getfenv,s)if u and v==e then return setfenv(r,t)end end end return setfenv(s,t,...)end}r=setmetatable({},{__index=function(t,u)local v=rawget(r,u)if v~=nil then return v end local w=s[u]if w~=nil then return w end return e[u]end})setfenv(q,r)end local r=coroutine.wrap(q)if o:IsA'BaseScript'then local s,t=not o.Disabled and task.defer(r)t=o:GetPropertyChangedSignal'Disabled':Connect(function(u)t:Disconnect()if u==false then n(o)else pcall(task.cancel,s)end end)return else local s={r()}i[o]=s return unpack(s)end end for o,p in next,g do pcall(function()p.InstanceObject[p.Property]=f[p.ReferenceId]end)end for q,r in next,j do if(c and r.ClassName=='Script')or(d and r.ClassName=='LocalScript')then n(r)end end end
